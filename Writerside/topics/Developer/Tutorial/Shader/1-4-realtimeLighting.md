# 动态光照与阴影

<secondary-label ref="wip"/>

<tldr>

在上一节中，我们初步认识了几何缓冲的相关知识，在延迟渲染中实现了场景光照。本章我们将会更进一步，将光照方向变更为实时计算，并为场景投影。

</tldr>

## 动态光照

回顾一下上一节的内容，我们成功在延迟处理实现了基本的光照，但是光照方向是固定的，而且如果你尝试过将时间切换至夜晚或者放置几个光源方块就会发现，场景并不会随着光照的变化而变化。

### 基本光照

在原版中，我们的天空光照除了在日出和日落时会进行视觉变化，光照的方向实际上是固定的，也就是说明暗关系始终不变。光是还原原版渲染肯定不能满足我们，因此我们将利用 OptiFine 提供的其他数据来编写一个随光源位置而动态响应的光照。

你应该知道，Minecraft 的太阳和月亮实际上不会随着日落和日出而被替换，而是始终存在于世界中，只不过白天时月亮位于地平线以下，夜晚则反之。OptiFine 提供了它们的位置，并且为了和它的阴影（下一节我们就将实现它）联动，还给出了目前用于投影的光源位置：
```glsl
uniform vec3 sunPosition;         //视口空间的太阳位置
uniform vec3 moonPosition;        //视口空间的月亮位置
uniform vec3 shadowLightPosition; //视口空间的投影光源 (日或月) 位置
```

上一节我们使用了原版的光照函数，它接受两个光照方向、法线和反照率，并返回运算之后的场景颜色。现在忘了它吧，我们将自己手动一步步实现光照函数，并进行手动混合。

光照的核心是**点乘**，它们可以描述两个向量的同向程度，希望你还记得，我们只要将向量转化到单位向量，就能将其结果限制在 $[-1,1]$ 。

所谓的光照方向就是指向光源位置的单位向量，我们使用 `normalize()` 函数就可以将向量转换为单位向量。于是我们只需要将表面法线与光照方向做点乘，就能求到光照强度了。但是当法线与光照的夹角大于 $90\degree$ 时，就会产生负值，而背光面本身就不会被照亮，因此我们还需要钳制一下最小值：
```glsl
vec3 lightDir = normalize(shadowLightPosition);
float lit = max(dot(lightDir, normal), 0.0);
```

这样，我们就拿到了场景的光照数据了，我们将它和反照率（所谓反射光的概“_率_”或者占比）相乘，就能得到应用了光照之后的场景颜色了：
```glsl
fragColor = albedo * lit;
```

![](shadows_realtimeLighting.webp)

不过你会看到，场景没有被光照射到的区域一片纯黑，这可不是我们期望的。为此，我们可以添加一个**环境光**亮度，基本上就是手动给计算好的光照加一个小值：
```glsl
fragColor = albedo * (lit + 0.3);
```

然后，你就能看到随着更改时间而变化的场景光照了：

![](shadows_differentTime.webp)

如果你还没忘记怪可怜的原版 AO，可以将它乘入环境光照明，让它发挥本来的作用：模拟环境光的遮挡。

```glsl
fragColor = albedo * (lit + 0.3 * albedo.a);
```

如果你觉得背光面太暗了，或者想要随时调节环境光照，也可以将它们写入光影设置。

> Photoshop 中的“正片叠底”模式的英文名称就是 Multiply，即相乘。由于普通图像的分量最大值只能是 `1.0` ，因此将图层混合模式选为正片叠底之后实际上是将其当作了阴影。
> 
{title="你知道吗"}

### 光照贴图



## 实时阴影

### 阴影几何缓冲

### 延迟渲染坐标变换

[//]: # (延迟渲染变换的不是顶点位置，而是纹理的位置信息)

### 绘制阴影

# 进阶延迟处理：光照

<secondary-label ref="wip"/>

<show-structure depth="2"/>

<tldr>

在之前的章节中，我们完成了场景的初步光照，当然，这个光照依然很简陋。我们目前所做的光照一直拘泥于顶点数据，而且明暗对比也和逊色。

在这一节中，我们将着手优化场景的光照效果，为光照引入更多细节，并让画面的明暗比对更加出色。

本节的内容较多，因此会拆分为两个部分，第一部分我们主要聚焦于光照本身，而第二部分我们则聚焦于环境和其他处理。

</tldr>

## 光照模型

之前我们在延迟处理中编写的光照逻辑都是在原版游戏上很有限的“扩写”，场景的细节与亮度都非常受限。为此，我们为场景的表面添加更多光照细节，并将更多可容纳的色彩压入我们屏幕的可见范围内，从而形成更好的明暗对比。

### 高光

目前我们的几何表面都只有简单的纹理颜色和光照强度。在现实生活中，如果一个表面足够光滑，我们可以通过这些表面观察到清晰的景物倒影，也就是反射。而那些明亮光源在表面上反射带来的亮斑，则就被称为**高光**。

在着色器中实现完整的镜面反射比较麻烦，对于我们来说还为时尚早，但是高光则非常简单，我们只需要知道高光产生的位置即可。我们已经拿到了光源的位置和几何表面的法线信息，回忆一下我们小学二年级就学过的反射虚像的位置，很显然它就在以几何表面为对称轴的镜像光源位置。

GLSL 为我们提供了一个用来反射向量的函数 `reflect(vec3 I, vec3 N)` ，其中 `I` 表示入射角度，`N` 表示表面的法线角度，入射角度即光源相对片段的方向。和之前一样，对于平行光来说，光源的方向就是光源相对片段的方向。这样，我们就直接求到了高光反射的角度：
```glsl
vec3 reflectDir = reflect(lightDir, normal);
```

因为表面通常不会绝对光滑，因此轻微的偏移只是会造成片段产生的高光减弱，不会导致只有一个点能接受到高光，换句话说，高光的强度取决于我们的视线 ^**1**^ 靠近反射中的光源方向的程度，说到两个向量的靠近程度，自然而然的，我们就能知道需要将高光方向与视线方向进行点乘。每个片段与我们摄像机的差值就是当前片段的视线方向，因此我们只需要求得当前片段相对摄像机的方向与反射目标方向的同向程度，就可以算出高光的强度了。为此，我们还需要知道当前片段的方向。

**[1]** 这里的视线不只是我们摄像机和眼睛聚焦的中央区域，而是我们整个可视范围内所有与观察点的连线，因此会有朝向一个方向时一些视线靠近反射高光方向，另一些视线背离反射高光方向的情况。

我们的光源坐标都在视口空间中，因此我们同样只需要求得视口空间的片段方向即可。在视口空间中，摄像机的坐标始终是 $(0,0,0)$，因此片段的方向就是简单的片段坐标归一化。

片段的视口坐标在之前处理阴影空间时短暂出现过，希望你还记得：
$$
P_\text{View} \xleftarrow{透视除法} {P_\text{Clip}}^* \leftarrow M_{G\text{Projection}}^{-1} \cdot P_\text{NDC} \leftarrow P_\text{Screen} \times 2 - 1
$$
在 [那一节](1-4-realtimeLighting.md#rebuildCoord){summary=""} 中，我们也将 `ViewPos` 进行了保留，如果你没有保留，可以回去翻找或者按上式自行计算。

最后，我们将视口方向与反射方向进行点乘，就可以在场景中产生高光了：
```glsl
vec3 viewDir = normalize(ViewPos.xyz);
lit += max(dot(viewDir, reflectDir), 0.0);
```

> 在 Learn OpenGL 的教程中，对于 `reflectDir` 和 `viewDir` 被解释为了每个片段的出射光方向和片段朝摄像机的方向，因此它考虑的是片段出射光偏离视口的角度。这和我们考虑的高光虚像产生方向与视线观察方向的角度是等效的，只不过我们的向量按来源是首尾相接，在图上计算夹角时需要移动一个向量到尾尾相连。

![你好，高光！](advancedLighting_helloSpecular.webp){width="700"}

你可以看出画面中“靠近”太阳的左侧地面产生的反射明显比右侧更亮，但是这个效果仍然很微妙。如果我们想产生更强烈和集中的高光来模拟光滑表面呢？很简单，我们只需要给点乘结果一个指数幂。

回想一下幂函数 $x^a$ 在区间 $[0,1]$ 上曲线随 $a$ 的变化规律，当 $a$ 逐渐增加，整个曲线会越来越下凹，整条曲线前半部分的增长会越来越放缓，而之后靠近 1 的部分会升得更快。这和我们高光的变化就非常相似了，靠近光源的地方光照强度值接近 1，而远离光源的地方光照强度则接近 0。因此，我们只需要给光照结果一个大于 0 的指数幂即可产生更加锐利的高光。

GLSL 同样为我们提供了幂函数 `pow(<gtype> x, <gtype> y)` ，其中 `x` 是底数，`y` 是指数，底数和指数需要同维。我们只需要将它套在运算结果之外即可，为了产生锐利的高光斑，我们将指数设置为了一个较大的值：
```glsl
lit += pow(max(dot(viewDir, reflectDir), 0.0), 256);
```

![更锐利的高光](advancedLighting_sharpSpecular.webp){width="700"}

现在，地面上已经产生了很明显的光斑了，这也就是大名鼎鼎的**冯氏照明**（Phong Lighting）。

### 材质

每种物体的表面都有不同的质地，它们有些是金属的，有些很光滑，这就是它们的**材质**。光线在不同的材质上会呈现不同的行为，最终反射出来的像也会有所区别。回看我们刚才写好的高光反射，在草方块上这样突兀的一团反射让它的质地看起来更像是粗糙的金属了。我们更希望针对不同的纹理定制不同的材质，从而产生不同的反射观感。

除了普通的颜色纹理，OptiFine 还会额外读取两种特殊后缀的材质纹理，只需要在资源包中颜色贴图的相同路径下添加与之同名且附带后缀 `_s` 或 `_n` 的图片即可。其中，`_s` 就被 OptiFine 定义为了**高光纹理**，它定义了几何表面的材质。在几何缓冲中，我们使用
```glsl
uniform sampler2D specular;
```
就可以访问它。和 `gtexture` 类似，它们也会在相同的位置进行拼贴，因此可以使用相同的纹理坐标进行采样。我们已经使用了 0 ~ 4 号缓冲区（有些人可能在之前还为自发光单开了一个缓冲区），因此材质数据我们就顺理成章地保存在 5 号缓冲区中了。

我们只需要为每种几何缓冲程序添加一个输出目标，然后接在之前纹理写入的末尾即可。
```glsl
[... 片段着色器部分 ...]
/* DRAWBUFFERS:...5 */
[...]
layout(location = [DRAWBUFFERS:5的索引]) out vec4 spec;
[... main ...]
spec = texture(specular, fs_in.uv);
```

特别注意 `gbuffers_color_only.glsl` 中的特殊处理，我们需要根据是否有纹理来决定是否写入高光缓冲区：
```glsl
#ifndef TEXLESS
/* DRAWBUFFERS:05 */
layout(location = 0) out vec4 fragColor;
layout(location = 1) out vec4 spec;
#else
/* DRAWBUFFERS:0 */
layout(location = 0) out vec4 fragColor;
#endif
```

> 高光纹理的每个通道都表示了固定的材质属性，因此你需要斟酌保留半透明几何的材质信息还是保留它背后的固体几何材质信息。为了方便，我们就保留半透明几何的数据了。
> 
{style="note"}

如果你没有为着色器程序设置混合模式，或者在之前偷懒将某些程序的混合模式做了统一修改，那么你还需要更改缓冲区的混合方式：
```properties
blend.<program>.colortex5 = off
```
当然，如果你在没有安装任何额外资源包的情况下直接在延迟处理中读取它的话会发现什么都没有，因为 OptiFine 没有默认高光贴图，它们的颜色都被设置为了 `vec4(0.0)`。现在，你应该前往 [图形站](https://www.minegraph.cn/) 或者 [Modrinth](https://modrinth.com/) 或者 [CurseForge](https://www.curseforge.com/minecraft/search?page=1&pageSize=20&sortBy=relevancy&class=texture-packs) 或者任何什么能下载到资源包地方，下载任意支持高光贴图的资源包 ^**1**^ 。如果你拿不定主意，可以试试 [SPBR](https://modrinth.com/resourcepack/spbr/versions)，他是基于原版纹理的 PBR 资源包，支持高光贴图和我们之后会用到的法线贴图。

**[1]** 现代大多数光影都使用 [PBR](terms.md#pbr){summary=""} 系统，所以这类资源包也常被称为 PBR 资源包，以前它们叫高光包（Specular Pack）。

安装好之后，重载一下光影，你就能在游戏中看到效果了：

![高光贴图视图](advancedLighting_specularMap.webp){width="700"}

我们的教程将会使用 [LabPBR 格式](labpbrMaterialStandard.md)，这是目前社区中 Java 版光影和资源包常用的格式，它定义了每个通道的数据用于处理何种效果，我们先前下载的 SPBR 也是这个格式（你不会下了其他的吧……）。

目前我们暂时只关心表面的光滑度，表面越光滑，我们之前的指数也就越大，但是要注意一个问题：如果粗糙度为 0，而高光亮度也为 0，就会出现 $0^0$ 的情况，这在 GLSL 中是未定义的，因此我们可以给材质加一个最小粗糙度。

LabPBR 不使用粗糙度，而是使用**感知平滑度** ^**1**^。其保存在了红色通道中，因此我们只需要在后处理中先读取材质信息，再将对应分量信息添加进光照函数中：

```glsl
vec4 material = texture(colortex5, uv);
[...]
lit += pow(max(dot(viewDir, reflectDir), 0.0), 1024 * min(material.r + .001, 1.0));
```

**[1]** $ \mathrm{粗糙度} = (1 - \mathrm{感知平滑度})^2 $

这里我们再次提高了固定倍数的值，因为现在我们的高光强度是可变的了，高光滑度的表面可以放心地产生更锐利的高光：

![带材质的高光](advancedLighting_betterSpecular.webp){width="700"}

### 高光优化

现在让我们来想象这样一个纯镜面高光场景，我们的位置和光源几乎处于观察点的同一侧，而地面非常粗糙，那么场景看起来就会像这样：

![纯反射场景](advancedLighting_pureSpecular.webp){width="700"}

眼睛尖的你应该已经发现了，高光的边缘过渡变得非常难看。这是因为当我们与光源位于观察点同一侧时，我们与反射光的夹角大于了 90°。对于完美的光滑平面来说这是没有问题的，但是对于一个粗糙的表面呢？

![夹角过大问题](advancedLighting_phongDisAdv.webp){width="700"}

这里我们提前引入**微平面**（Micro Facets），这是一个在 PBR 渲染中常用的概念。我们的纹理分辨率是有限的，因此用于存储表面额外朝向的信息最多只能记录到纹素尺度（我们将在下一节认识它），那么对于小于一个纹素尺度的法线信息，我们只能使用粗糙度来表征它们表面的朝向（法线）离散程度。

因此那些看似夹角大于 90° 的区域，实际上也是会有部分微平面反射光线，而不只是一片纯黑。

> 你可能会思考，既然都是反射，那高光反射为什么不同样用于漫反射？这是因为所谓的“漫反射”实际上指的是光线进入材料的表层内部经过多次吸收和释放（即散射）之后，逃逸出材料的表面并向四面八方扩散，最终被我们的眼睛接收的光线，因此每个点的散射亮度理论上在各个方向上都是均匀的。次表面散射就是一种模拟散射较强的材料从入射方向的侧面和背面逸出光线的技术。
> 
> 虽然当我们从掠角（即与平面几乎平行）进行观察时，几何自身会形成自遮蔽，但是它们本身又会进行散射和反射来照亮周围，掠角时漫反射贡献微乎其微，因此我们在渲染时基本不考虑它们。
> 
> 而“高光反射”（我们更习惯于称为镜面反射），则是真正意义上没有被材料吸收，仅在材料表面进行反弹之后就扩散到四周的光线，而粗糙度就表征了反弹方向相对表面朝向的离散程度，某些 PBR 系统还拆分出了几何粗糙度和表面粗糙度用于表面的自遮蔽和反射扩散程度。当我们的视线越靠近光线的扩散范围，会接收到的光照理应就更多。
> 
> 事实上，反射也会受到光照角度的影响，因为入射光的总量会变少，但现实生活又告诉我们，反射光的强度似乎不会在光源方向几乎平行表面时减弱，这些内容我们一会儿都会了解。
> 
{title="小知识"}

考虑一下，我们先前绘制高光的方法是点乘反射光和视线，而反射光则来自光照方向和法线，罪魁祸首可以说就算反射向量。那假如我们不使用反射向量，只在平面上考虑呢？当我们在平面上正正好好看到反射中光源的像时，我们会发现从片段和视口的连线到片段与光源连线上的一半方向是和法线**同向**的，当我们稍微偏离时，这个方向也会稍微偏离，这就是所谓的**半程向量**（Halfway Vector）。

![半程向量](advancedLighting_halfwayDir.webp){width="700"}

我们将半程向量与法线做点乘，无论光源和视口怎么变化，只要两者都在反射面的同一侧，半程向量与法线的夹角就始终不会大于 90°！这就是大名鼎鼎的**布林-冯氏光照**（Blinn-Phong Lighting）。

要想求得半程向量非常简单，我们只需要将片段指向光源的方向与片段指向视口的方向进行平均即可，由于我们使用单位向量进行求值，因此也不需要除以平均值，只需要归一化即可。光源方向我们已经有了，片段指向视口的向量即片段的视口坐标取反：
```glsl
vec3 viewportDir = normalize(-ViewPos.xyz);
vec3 halfwayVec = normalize(lightDir + viewportDir);
```

此外，求半程向量时我们一定要记得归一化，否则半程向量的方向就会朝两者更长的方向偏移。最后，我们将半程向量与法线做点乘，新的高光效果就出来了：
```glsl
fragColor = vec4(max(dot(normal, halfwayVec), 0.0));
```

![布林-冯氏照明](advancedLighting_pureBlinn.webp){width="700"}

布林-冯氏照明相比较于单纯的冯氏照明会更加明亮和平滑，因为半程向量与法线的夹角变化更慢，所有的角度相比之前都会有增亮。

最后一件事，如果你和光源在表面的两侧，可能会观察到下图的问题：

![布林-冯氏照明的问题](advancedLighting_blinnProblem.webp){width="700"}

这是由于半程向量始终在两方向所成的劣弧上（两向量平行时甚至可能导致 `normalize` 除 0），而劣弧几乎总是会覆盖视口侧，这就导致了半程向量与法线的夹角有很大概率会小于 90°：

![布林-冯氏照明问题的根源](advancedLighting_blinnProblemExplain.webp){width="700"}

解决这个问题也很简单，只需要判断表面是否和光源同侧即可：
```glsl
fragColor = dot(lightDir, normal) > 0.0 ? vec4(max(dot(normal, halfwayVec), 0.0)) : vec4(0.0);
```
这样可能会导致一些光照突变，我们一会儿会处理它。你也可以直接用先前计算的漫反射强度值直接进行判定，它们的公式是一致的。

### 让光照更“正确”

回看我们写出来的高光效果，你是否会感觉似乎所有表面看起来都很像金属？这是因为我们单纯地将镜面反射叠加到了本来的光照上，这些高光在非金属材质上不应该总是如此明显。

如果你仔细阅读了上一节中的小知识，或许会开始思考这个问题：既然几何表面接受到光照之后会产生漫反射和镜面反射，那在入射光强度一定时，漫反射和镜面反射的强度应该是此消彼长的，再考虑到材料内部散射被吸收的部分，总的出射光应该比入射光强度更弱。换句话说，漫反射和镜面反射的能量总和不应该大于入射光的能量，这就是**能量守恒**。

虽然这已经涉及到 PBR 了，但是我们暂时不做深入，也暂时不会将那个让人头大的渲染方程搬过来解释半天。我们会沿用布林-冯氏光照的基本算法，并将其改造为简单的能量守恒光照，而不会使用完整意义上的 <tooltip term="BRDF">BRDF</tooltip>。

根据我们之前所说的，漫反射在各个方向上实际应该是均匀的，而光照与表面法线的夹角应该同时影响镜面反射，因此我们会将它乘在整个光照函数的末尾，因此我们的漫反射就只和材料的表面颜色（或者说固有色） ^**1**^ 有关。

**[1]** 表面颜色与反照率的微妙关系导致了其在任何物理渲染中无法做到一视同仁，在非金属材质中，表面颜色通常就用于反照率，而在金属材质中，由于金属会吸收所有几乎散射光而只剩下镜面反射，因此表面颜色会作为镜面反射的颜色。

在之前的光照处理中，我们总是将高光反射与漫反射一视同仁，一同全量叠加在表面上。然而在现实中，当你从掠角（与表面几乎平行，与表面法线几乎垂直）观察几何表面时，你会发现非金属材质的反射要比视线与表面垂直时强得多，这被称为**菲涅尔现象**（Fresnel Effect）。

![菲涅尔球](advancedLighting_fresnel.webp){width="384"}

菲涅尔现象实际上表征的是折射和反射的比例，而散射则是在非均质材质中的折射，因此菲涅尔方程可以用来计算漫射和折射的比例。完整的菲涅尔相当复杂，我们就不列出了，幸好 Schlick 提出了一种近似方法，将其简化为了：

$$
F = F_0 + (1-F_0)(1-\cos\theta_i)^5
$$

而且其中的 $\cos\theta_i$ 就是半程向量和视线的点乘值，因此还可以改写为 $h \cdot v$。式中另一项令我们在意的是 $F_0$，它表征了当视线与表面垂直时的**基础反射率**，由 $\theta_i = 0$ 推导菲涅尔方程中的任意一个得到：

$$
\begin{aligned}
F_0 &= \left| \frac{n_1 \cos0 - n_2\sqrt{1-\left({\frac{n_1}{n_2} \sin0}\right)^2}}{n_1 \cos0 + n_2\sqrt{1-\left({\frac{n_1}{n_2}\sin0}\right)^2}} \right|^2 \\
&= \left| \frac{n_1 \times 1 - n_2\sqrt{1-\left({\frac{n_1}{n_2} \times 0}\right)^2}}{n_1\times 1 + n_2\sqrt{1-\left({\frac{n_1}{n_2}\times 0}\right)^2}} \right|^2 \\
&= \left|\frac{n_1-n_2}{n_1+n_2}\right|^2
\end{aligned}
$$

其中 $n_1 n_2$ 表示两介质的折射率

要想准确计算材质的 $F_0$ 比较复杂，可以在 [RefractiveIndex.info](https://refractiveindex.info/) 的 _Fresnel reflection calculator_ 板块查询每种材质在观察角度为 0 时波长对应到 RGB 的 $R$、$R_s$ 或 $R_p$ 值即 $F_0$（$R = \frac{R_s + R_p}{2}$，观察角度为垂直表面时三个值相等）。非金属没有反射颜色，只需要计算一个值，而金属有色泽，因此需要进行完整计算。

回看我们之前取到的表面材质信息，它的 G 通道就表示了材质的所谓**金属性**（Metallic）。尽管现实生活中不存在“半金属”，但是我们可以利用这个值来控制 $F_0$，并且一个纹素无法表达多种材质，因此它也可以用来表示一些复合材质，比如嵌在沙堆里的金属碎屑。

在我们目前所使用的 LabPBR 格式中，还预留了 230 ~ 254 的区间用于定义金属材质，只不过目前只用到了 237，其还包含了材质的**复折射率**（Complex refractive index）$n+\mathrm{i}k$，其实部表示折射率（Refractive index），虚部表示消光系数（Extinction coefficient），它也可以用来计算 $F_0$：

| 金属 | 颜色值 |        N (R, G, B)        |      K (R, G, B)       |
|----|-----|:-------------------------:|:----------------------:|
| 铁  | 230 |  2.9114, 2.9497, 2.5845   | 3.0893, 2.9318, 2.7670 |
| 金  | 231 | 0.18299, 0.42108, 1.3734  | 3.4242, 2.3459, 1.7704 |
| 铝  | 232 | 1.3456, 0.96521, 0.61722  | 7.4746, 6.3995, 5.3031 |
| 铬  | 233 |  3.1071, 3.1812, 2.3230   | 3.3314, 3.3291, 3.1350 |
| 铜  | 234 | 0.27105, 0.67693, 1.3164  | 3.6092, 2.6248, 2.2921 |
| 铅  | 235 |  1.9100, 1.8300, 1.4400   | 3.5100, 3.4000, 3.1800 |
| 铂  | 236 |  2.3757, 2.0847, 1.8453   | 4.2655, 3.7153, 3.1365 |
| 银  | 237 | 0.15943, 0.14512, 0.13547 | 3.9291, 3.1900, 2.3808 |
{width="800"}

没错，我们之前所使用的介质折射率 $n$ 实际上都是复数。如果将 $n_1$ 代入空气折射率 $1 + 0\mathrm{i}$，$n_2$ 代入材料折射率，基础反射率 $F_0$ 就可以继续推导为：
$$
F_0 = \left| \frac{(1 + 0\mathrm{i}) - (n + \mathrm{i}k)}{(1 + 0\mathrm{i}) + (n + \mathrm{i}k)} \right|^2 = \left| \frac{1 - n - \mathrm{i}k}{1 + n + \mathrm{i}k} \right|^2 = \frac{(n-1)^2 + k^2}{(n+1)^2 + k^2}
$$

将它们进行预计算之后可以整理出下表：

| 金属 | $F_0$ (R, G, B)  |
|----|------------------|
| 铁  | 0.56, 0.57, 0.58 |
| 金  | 1.00, 0.71, 0.29 |
| 铝  | 0.91, 0.92, 0.92 |
| 铬  | 0.86, 0.90, 0.94 |
| 铜  | 0.95, 0.64, 0.54 |
| 铅  | 0.63, 0.63, 0.64 |
| 铂  | 0.68, 0.64, 0.59 |
| 银  | 0.95, 0.93, 0.88 |
{width="400"}

对于普通的非金属而言，我们可以设置一个较小的值，在很多教程包括 LearnOpenGL 中，它们都将其设置为了 0.04，对编者来说，这个值似乎有点过大，以自己的喜好为准。

希望你还没有被上面这一大串理论搞晕，我们接下来就开始逐步将它们翻译为 GLSL。

我们之前将材质信息取在了 `vec4 material` 中，现在，我们需要将材质的金属性，也就是 G 通道取出来以便处理 $F_0$。之前我们提过，在金属中，我们通常使用表面颜色来表示反射的颜色，那么对于现实中不存在的半金属来说，我们可以人为地认为纹素中倾向于为金属材质的比例：
```glsl
vec3 f0 = mix(vec3(0.04), albedo.rgb, material.g);
```

对于硬编码区间，我们可以直接比对 G 通道中的索引：
```glsl
int metallicIndex = int(floor(material.g * 255.0 + 0.5));
```
这里进行 `floor(x + 0.5)` 是为了确保不会由于缓冲区精度丢失而导致索引错误的位置。然后，根据索引值返回对应的 $F_0$ 即可：
```glsl
vec3 f0 = mix(vec3(0.04), albedo.rgb, material.g);
if(metallicIndex > 229) {
    if     (metallicIndex == 230) f0 = vec3(0.56, 0.57, 0.58);
    else if(metallicIndex == 231) f0 = vec3(1.00, 0.71, 0.29);
    else if(metallicIndex == 232) f0 = vec3(0.91, 0.92, 0.92);
    else if(metallicIndex == 233) f0 = vec3(0.86, 0.90, 0.94);
    else if(metallicIndex == 234) f0 = vec3(0.95, 0.64, 0.54);
    else if(metallicIndex == 235) f0 = vec3(0.63, 0.63, 0.64);
    else if(metallicIndex == 236) f0 = vec3(0.68, 0.64, 0.59);
    else if(metallicIndex == 237) f0 = vec3(0.95, 0.93, 0.88);
    else f0 = albedo.rgb;
}
```
LabPBR 要求我们在硬编码之后未使用的区域全部按照完全金属处理，因此也就有了末尾的 `else f0 = albedo.rgb;` 这一行。

处理完 $F_0$ 之后，我们只需要将它代入 Schlick 的拟合函数中就可以算出菲涅尔反射的强度了：
```glsl
vec3 f_Schlick = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(normal, viewportDir), 0.0, 1.0), 5.0);
```
这里我们进行了一次 `clamp()` 是为了避免法线与视线完全同向时可能产生的黑点。

最后，我们按其的比例混合漫反射（其实就是表面颜色了）和镜面反射的强度，再在末尾乘上光照与表面法线的夹角余弦和阴影强度的积，就可以得到更加准确的照明了：
```glsl
float lit = max(dot(lightDir, normal), 0.0);
const float bias = 1e-3;
float shadowMultiplier = step(currentDepth - max(bias * (1.0-lit), bias * .1), closestDepth);
if(uv_OutBound(uv_shadowMap) || currentDepth >= 1.0) shadowMultiplier = 1.0;
lit *= shadowMultiplier;

vec3 litScene = (1.0 - f_schlick) * albedo.rgb
              + f_schlick * pow(max(dot(normal, halfwayVec), 0.0),
                                8192 * min(material.r + .001, 1.0))
              * 4 * pow(min(material.r + 0.001, 1.0), 2.0);
litScene *= lit;
```
由于我们的表面颜色已经参与了光照计算，因此不再需要其再乘在光照计算之后。你可能已经注意到了，反射项的系数又被进一步增大了，这也是布林-冯氏照明更为平缓的缘故；此外，我们还在反射项后额外乘了一个光滑度，因为越光滑的平面反射的光强越集中，因此应当会产生更为明亮的光斑，当然，这只是一个经验近似。

如果你想加上环境光照，可以通过传统的办法 `+ 0.4 * albedo.rgb`，也可以像这样尝试让环境光再走一遍上述流程，只不过由于环境光没有方向，镜面反射项就只与菲涅尔强度相关了：
```glsl
vec3 litSceneAmbient = (1.0 - f_schlick) * albedo.rgb + f_schlick;
fragColor.rgb = litScene * .6 + litSceneAmbient * .4 * albedo.a;
```
如果你这样做了，会发觉画面看起来像下面这样：

![奇怪的菲涅尔环境光](advancedLighting_fresnelAmbient.webp){width="700"}

大多数地方看起来都很正常，除了那些与视线几乎相切的表面。这是因为环境光来自法半球内的所有方向，因此没有一个确定半程向量来计算菲涅尔效应。再者，我们目前也没有考虑任何粗糙度，因此掠角的反射率总是较高。为此，我们可以使用 [Sébastien Lagarde](https://seblagarde.wordpress.com/2011/08/17/hello-world/) 提出的在 Schlick 近似方程中引入粗糙度的方案来缓解这个问题：
$$
F = F_0 + (\max(1 - R, F_0) - F_0) (1 - \cos\theta_i)^5
$$
当粗糙度增大时，后面一项会随之减小，直到光滑度（1-粗糙度）小于 $F_0$ 时被截断。将它翻译成 GLSL 函数就是：
```glsl
vec3 f_schlick(vec3 f0, float cosTheta, float roughness) {
    return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(1.0 - cosTheta, 5.0);
}
```
LabPBR 使用感知平滑度，因此我们还需要将其转换到正确的粗糙度：
```glsl
float roughness = pow(1.0 - material.r, 2.0);
```

有了粗糙度作为系数之后，场景中的总菲涅尔就已经降低了不少，因为场景中的大多数几何体粗糙度都不会太高。可以按照你的喜好在这两种菲涅尔拟合中二选一。

![粗糙菲涅尔对比](advancedLighting_fresnelRoughness.webp){width="700"}

最后，我们可以将环境光乘上天空的颜色，然后将阳光亮度和场景亮度解耦：
```glsl
[... Settings.glsl ...]
#define SUN_BRIGHTNESS 1.0
#define AMBIENT_BRIGHTNESS 0.8
[... Uniforms.glsl ...]
uniform vec3 skyColor;
[...]
fragColor.rgb = litScene * SUN_BRIGHTNESS
              + litSceneAmbient * skyColor * AMBIENT_BRIGHTNESS * albedo.a;
```

场景看起来就已经有点门路了，这是在直接光照和环境光照中均使用的粗糙度菲涅尔函数的效果：

![带粗糙菲涅尔的光照场景](advancedLighting_finalSpecular.webp){width="700"}

## 表面法线

[//]: # (表面法线映射之后可能背离场景。)

## 柔和阴影

## 高动态范围

### 伽马校正

#### 色彩空间

### 色彩映射

## 习题

1. 整理光照模型小节中使用的函数，将菲涅尔反射之类的公式封装到 `Lighting.glsl` 中。

# 光线追踪专题

<show-structure depth="2"/>

<primary-label ref="basic"/>

<secondary-label ref="latest"/>
<secondary-label ref="shaderDoc"/>

> 在三维计算机图形学中，光线追踪是一种**对光线传输进行建模**的技术，用于生成数字图像的各种渲染算法。
> 
> 在计算成本和视觉保真度方面，基于光线追踪的渲染技术，如**光线投射**、**递归光线追踪**、**分布光线追踪**、**光子映射**和**路径追踪**，通常比扫描线渲染方法更慢，保真度更高。 因此，**光线追踪首先被部署在可以花费相对较长的时间进行渲染的应用中**，如静态渲染的计算机图像，以及电影和电视视觉效果（VFX），但不太适合实时应用，如视频游戏，因为在渲染每一帧时，**速度**是至关重要的。
> 
> 然而，自2018年以来，实时光线追踪的硬件加速已成为新的商业显卡的标准，图形API也紧随其后，允许开发人员在游戏和其他实时应用中使用**混合光线追踪和基于光栅化的渲染**，对帧渲染时间的冲击较小。
> 
> 光线追踪能够模拟各种光学效果，如反射、折射、软阴影、散射、景深、运动模糊、黄昏、环境遮蔽和色散现象（如色差）。它还可以用来追踪声波的路径，其方式与光波类似，通过渲染逼真的混响和回声，使其成为视频游戏中更具沉浸感的声音设计的可行选择。事实上，**任何具有近似线性运动的物理波或粒子现象都可以用光线追踪来模拟**。
> 
> 基于光线追踪的渲染技术，涉及到在一个区域内对光线进行采样，会产生**图像噪声伪影**，可以通过**追踪大量的光线**或**使用去噪技术**来解决。
> 
> ——_[Ray Tracing | 维基百科](https://en.wikipedia.org/wiki/Ray_tracing_(graphics))_

## 从光栅化到光线追踪

上世纪 70 年代，_PARC_ 开发了具备8位帧缓冲器的先进绘图系统，标志着光栅化成像技术的诞生。这一技术能够在屏幕上呈现复杂图形画面，为现代计算机图形学的发展奠定了基础。

在光栅化渲染过程中，需要将三维场景转换为二维图像，通过将场景中的对象分解离散，并映射到屏幕像素上来实现。虽然这种方法在速度上非常高效，但准确性较差，同时由于其在映射后会抛弃空间几何信息，只能通过 [帧缓冲](terms.md#缓冲区 "存储图像的区域") 进行处理的特性，光栅化在处理画面之外的信息时有天然的劣势。

1968 年，*Arthur Appel* 首次提出了**光线投射**的概念，形成了光线追踪技术的雏形。光线投射技术从一个点向一个方向发射出光线，与场景中的物体相交时停止。其模拟光子运动的特性，造就了更真实的光照效果。

随后的二十年里，_Turner Whitted_ 和 *Robert Cook* 分别提出了**递归光线追踪**和**分布光线追踪**，实现了光线追踪中光线的反射、折射和散射三大机制，光线追踪也成为了影视制作等离线渲染领域的主要解决方案。

随着硬件性能的不断提升，人们开始对实时渲染提出更高的画面规格要求，光线追踪技术就此走上实时渲染的舞台。

目前应用的光线追踪技术，大多数是**从视点出发追踪到光源**，而非直接从光源出发。这种技术遵循物理上的**光路可逆**原则，同时能减少性能消耗。在开始之前，需要先通过切割立方体（体素方法）或切割三角面两种方式，构建三维空间，然后按照下图所示的流程进行光线追踪渲染（以下为简化流程图）。

![光线追踪流程图](pt_step.png "光线追踪流程图"){width="700"}

## 广义的光线追踪

光线追踪是一个非常实用的技术，其核心思想被应用在了除图形渲染外的各个领域。在物理引擎的开发中，我们也经常使用光线追踪的方法进行物体之间的碰撞检测，这类技术被称为射线碰撞检测。

> 解析几何里对圆和直线联立方程组进行交点坐标的求解，实际上就是我们在脑内进行了一个二维平面内的光线追踪过程，并在草稿纸上完成了光线（直线）-物体（圆）求交的数值计算。

为了避免纠纷，一般把用于图形渲染的（包含一整套光照着色管线）此类技术称作**光线追踪**，而在其它领域则称作**射线追踪**，但是它们最基础的思想在本质上都是一样的。

## 追踪方案

### 最原始的光线追踪

最初的光线追踪由光源发出光子并在场景中行进，场景中被撞击的位置被照亮，其他位置则是阴影。其只能计算直接光照，且在处理多光源时会更加吃力，在现代渲染中几乎不会使用。

### 逆向光线追踪

光子不再由光源发出，而是从摄像机的每一个像素出发，根据光路可逆原则求出光照，可以节省很多在原始光线追踪中被浪费的光线（发射到屏幕外或者被遮挡），是现代光线追踪算法的核心。

### 路径追踪

路径追踪是目前使用较多的追踪方案，虽然它们有时候仍然会被称为光线追踪。

如果要提到路径追踪，我们想先介绍计算机图形学领域的大师——_Jim Kajiya_。作为研究图形学光传输框架的先驱之一，他的贡献为整个行业带来了深远影响。

*Kajiya* 最著名的贡献就是于 1986 年提出的**渲染方程**，这是计算机图形学中进行物理真实感渲染极为重要的理论基础。该方程描述了三维场景中光线的能量传播及衰减，至今仍是全局光照算法的核心。由于引入了辐射度量学，它有效终结了图形学中真实感渲染混乱无章的时代，使得真实感渲染朝着物理准确迈进。

不过，渲染方程作为麦克斯韦电磁理论的近似，它仅适用于理论上波长远小于面微分的情况。也就是说，仅仅基于辐射度量学的渲染方程不能模拟出物理光学中的衍射、干涉等现象，只能模拟线性的能量传输。

路径追踪正是基于渲染方程，同样由 *Kajiya* 提出。不过渲染方程是一个极其复杂的积分方程，几乎不能求得解析解，因此采用了**蒙特卡洛积分法**，通过随机采样光线路径来估计积分值，从而获得最终的渲染结果。
- **蒙特卡洛积分法是利用随机采样求和估计数值的一种积分方法**，在路径追踪中，它被用于计算光线在场景中相互作用后产生的散射效果。为了提高相同采样率下的渲染质量，工程师们大规模应用了重要性采样来引导渲染方程的积分值估计。

与传统光线追踪流程相比，路径追踪在求出交点后，会根据物体材质属性随机选择新的传播方向，继续追踪光线，重复上述过程，直至光线抵达光源（或达到退出条件），最后将所有采样光线的贡献累加，从而计算出像素颜色。

传统光线追踪与路径追踪的最大区别就是求解的光能传输方程以及求解策略的不同。路径追踪求解的是渲染方程；而传统光线追踪一般是一些简单的初等方程，例如Lambert漫反射方程、Phong高光方程。  
此外，这两个方程在 <tooltip term="PBR">PBR</tooltip> 普及前的游戏（几乎所有，那时的游戏几乎全部基于光栅化）中有极为广泛的应用。方法上，传统光线追踪是确定性地求解，而路径跟踪是随机采样。由此可见，无论是光线追踪、路径追踪还是光栅化，它们都只是手段，而求解光能传输才是目的。

简单来说，$路径追踪 = 逆向光线追踪 + 反弹 + 蒙特卡洛积分$。

#### 完全追踪 {id="fullRT"}

完全光线追踪直接抛弃了所有的光栅化流程，一般仅使用蒙特卡洛随机采样的办法进行光照求解，且只通过发射随机光线与场景几何进行求交来获取几何信息。这是目前很多**电影**的渲染方法。

需要注意的是，完全追踪不一定就是最耗费性能的方案。在场景几何复杂到光栅化的时间复杂度远超过光线追踪时，使用完全追踪将带来巨幅的性能提升。因为光栅化的时间复杂度是线性的，而具有树结构遍历过程的光线追踪是对数的。

### 混合追踪

也称**部分追踪**。现阶段的 *实时* 光线追踪技术处于**初步发展阶段**，而传统的光栅技术已达到炉火纯青的境界。

将场景以传统光栅方式渲染，然后用光线追踪补足细节，是目前**大多数游戏所使用**的手段，这样也能在画质与帧率间找到平衡。

> PTGI 的思路也与此类似：使用传统阴影贴图渲染太阳阴影，然后辅以体素和屏幕空间追踪全局光照（主要是间接光照）和反射来增强细节。

### 屏幕空间追踪 {id="sst"}

**<tooltip term="SST">SST</tooltip>**，是受限于 [帧缓冲](terms.md#缓冲区){summary=""} ，只能与 [屏幕空间](terms.md#屏幕空间){summary=""} 场景求交的光线追踪算法，是一种高质量的屏幕空间效果，同时也是廉价的光线追踪解决方案。

> SST 表现出来的效果酷似 [屏幕空间反射](terms.md#ssr){summary=""} 。因为两者在算法与最终效果上都有许多相似之处。
> 
> 在世界空间中进行的光线追踪通常使用精确的原始几何数据，我们也可将其称之为**几何光线追踪**。  
> 相对的，SST 的求交对象是帧缓冲上的几何信息，而不是真实的几何体，我们也可称之为**屏幕光线追踪**。

## 数据存储和扩展

### 直接访问几何场景

对于现代大多数渲染接口来说，只要经过正确的设置，我们都可以直接访问几何数据，很遗憾，Java 版不在此列，其性能开销较大，几乎只在硬件加速的场景下才这样做。

### 体素化

**Voxelize**，将场景切割成小的立方体并存储其信息，是一种较为高效的数据存储方案，与 Minecraft 有天然的亲和力。

#### 稀疏存储

仅存储场景中有意义的元素，可以大大提升空旷场景下的几何数据存储距离。

#### 曼哈顿距离场

在空旷地带扩散距离场，从而提升追踪距离。

### 符号距离场

**<tooltip term="SDF">SDF</tooltip>**，记录场景中每个点到最近几何表面的距离，符号用以区分内外。是包括 Lumen 软件光追模式在内使用的方案。

## 加速方案

### 硬件加速

利用硬件进行光线追踪求交加速，同时也需要软件的支持，很遗憾，OpenGL 不在此列。

### 包围盒

利用二叉树生成紧靠的 AABB 包围盒，光线每次只需和两个包围盒求交，若不在其中一个包围盒则必定在另一个包围盒，如此往复递进最终确定光线与场景的交点。

## 商业上的光追

在 _英伟达_ 、_AMD_ 和 _英特尔_ 推出的现代高性能显卡中，均内置了**光线追踪加速单元**。光线追踪流程涉及大量计算密集型的步骤，这些步骤的工作流程相对固定，因此业界专门设计了一种**加速电路**来分担任务。如我们在之前展示的光线追踪流程图所示，加速单元主要用于加速光线与场景求交部分的计算，且在光线追踪流程中的大量着色器仍需要传统的通用计算单元参与计算。

> 以下图片摘自 *英伟达* 的 RTX 20 系列显卡发布会，提到了 RTX 显卡是 GTX 显卡光追性能的数倍，可见即使是 GTX 显卡也有光追能力
> 
> ![即使是 GTX 系列显卡也有着光追计算能力](nv_briefing_gtx_rt_performance.png "即使是GTX系列显卡也有着光追计算能力"){thumbnail="true"}

对于*全景光线追踪*，也就是 ***英伟达* 所宣传的** *路径追踪* 和 *光线追踪* 实为一种营销概念。在这里援引 *英伟达 RTX Remix 开发团队* 的顶级工程师之一 *Mark* 的 Discord 聊天记录：
> ![图片](nv_mark_0.jpg "术语变化"){thumbnail="true"}
> 
> 旧行业术语：  
> 光线追踪 = 30 年前的原始技术，光线在碰到某物时停止。  
> 路径追踪 = 对光线追踪的明显升级，在此技术中，你会追踪光子的完整路径，包括反射、折射等。
>
> 现在人们在混合渲染引擎中称为光线追踪的所有东西，实际上是我所说的路径追踪。现在已经没有人真正只做基础的光线追踪了。
>
> 这些营销术语实际上想要表达的区别：
>
> 现代营销术语：  
> 光线追踪 = 混合渲染引擎使用一些路径追踪技术，向主要的光栅管线添加信息。  
> 路径追踪 = 完全不使用光栅化的路径追踪渲染引擎。

> ![图片](nv_mark_2.jpg){thumbnail="true"}
> 
> 英伟达的营销部门似乎不喜欢“混合渲染 vs 完全光线追踪”这样的说法，所以他们将混合渲染称为“光线追踪”，然后将完全光线追踪称为“路径追踪”……糟践这些术语本已薄弱的定义。

> ![图片](nv_mark_1.jpg){thumbnail="true"}
> 
> 所以在这次对话之后，我又做了一些关于（现代的）“光线追踪”和“路径追踪”区别的研究，并且觉得我应该发布一些澄清：
>
> 光线追踪：
> - 核心渲染仍然使用光栅管线完成
> - 诸如阴影、反射、全局照明等单独效果通过光线追踪完成，然后与光栅管线集成
> - 这是目前市场上大多数光线追踪游戏所采用的方法
> - 在 RTX 20 系列之前，即使是这样的实时渲染也被认为是痴人说梦
>
> 路径追踪（或全景光线追踪）：
> - 所有渲染都通过光线追踪完成
> - 整个照明算法简单而优雅
> - 完全不使用光栅渲染
> - 电影行业已经使用这种技术很长时间了
> - RTX 版《传送门》，RTX Remix 模组，以及《赛博朋克 2077》中的路径追踪模式表明，使用现代 RTX 硬件实时完成这一过程是可能的。
>
> 英伟达的一篇博客文档详细介绍了这个话题 - 包括解释“路径追踪”术语的实际历史：[What Is Path Tracing? | NVIDIA Blog](https://blogs.nvidia.com/blog/what-is-path-tracing/)

## 附录：光线追踪特性表 {id="JERTFeature"}

<primary-label ref="je"/>

这里列举了一些已知光影的追踪效果信息

<table style="both">
<tr><td>光影名称</td>                   <td colspan="2">间接光照</td>               <td>直接光照</td>                <td>反射</td>    <td>折射</td>  <td><a href="terms.md" anchor="焦散" summary="">焦散</a></td>  <td>数据存储方法</td></tr>
<tr><td>SEUS PTGI / GFME</td>         <td colspan="2">✓</td>                    <td>✕</td>                      <td>✓</td>      <td>✕</td>    <td>✕</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>Sundial</td>                  <td>✓</td><td>✕</td>                      <td>✓ <sup><b>1</b></sup></td>  <td>✓</td>      <td>✕</td>    <td>✓</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>iterationRP</td>              <td colspan="2">✓</td>                    <td>✕</td>                      <td>✓</td>      <td>✕</td>    <td>✕</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>Kappa</td>                    <td>✕</td><td>✓</td>                      <td>✕</td>                      <td>✕</td>      <td>✕</td>    <td>✕</td>                                                    <td>屏幕缓冲</td></tr>
<tr><td>Kappa PT</td>                 <td colspan="2">✓</td>                    <td>✕</td>                      <td>✓</td>      <td>✕</td>    <td>✓</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>Nostalgia</td>                <td>✕</td><td>✓</td>                      <td>✕</td>                      <td>✕</td>      <td>✕</td>    <td>✕</td>                                                    <td>屏幕缓冲</td></tr>
<tr><td>Nostalgia VX</td>             <td colspan="2">✓</td>                    <td>✕</td>                      <td>✓</td>      <td>✕</td>    <td>✓</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>Soft Voxels</td>              <td colspan="2">✓</td>                    <td>✓</td>                      <td>✓</td>      <td>✕</td>    <td>✕</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>Soft Voxels Lite</td>         <td colspan="2">✓</td>                    <td>✓</td>                      <td>✕</td>      <td>✕</td>    <td>✕</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>MollyVX</td>                  <td colspan="2">✓</td>                    <td>✓</td>                      <td>✓</td>      <td>✕</td>    <td>✓</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>ApolloRT</td>                 <td colspan="2">✓</td>                    <td>✓</td>                      <td>✓</td>      <td>✕</td>    <td>✓</td>                                                    <td>体素和屏幕缓冲</td></tr>
<tr><td>Rethinking Voxels</td>        <td>✓ <sup><b>2</b></sup></td><td>✕</td>  <td>✓ <sup><b>3</b></sup></td>  <td>✓</td>      <td>✕</td>    <td>✕</td>                                                    <td>距离场 <sup><b>4</b></sup></td></tr>
<tr><td>Chocapic13 <sup>V9</sup></td> <td>✕</td><td>✓</td>                      <td>✕</td>                      <td>✕</td>      <td>✕</td>    <td>✕</td>                                                    <td>屏幕缓冲</td></tr>
<tr><td>Continuum RT</td>             <td>✓</td><td>✕</td>                      <td>✓</td>                      <td>✓</td>      <td>✓</td>    <td>✓</td>                                                    <td>体素</td></tr>
<tr><td>Vanilla Pudding Tart</td>     <td>✓</td><td>✕</td>                      <td>✓</td>                      <td>✓</td>      <td>✕</td>    <td>✕</td>                                                    <td>屏幕缓冲体素 <sup><b>5</b></sup></td></tr>
<tr><td colspan="8">离线渲染（静帧）光影</td></tr>
<tr><td>Chronos</td>                  <td>✓</td><td>✕</td>                      <td>✓</td>                      <td>✓</td>      <td>✓</td>    <td>✓</td>                                                    <td>体素</td></tr>
<tr><td>Octray Rewrite</td>           <td>✓</td><td>✕</td>                      <td>✓</td>                      <td>✓</td>      <td>✓</td>    <td>✓</td>                                                    <td>稀疏体素</td></tr>
<tr><td>VXPT</td>                     <td>✓</td><td>✕</td>                      <td>✓</td>                      <td>✓</td>      <td>✓</td>    <td>✓</td>                                                    <td>体素</td></tr>
</table>

**间接光照** 第二列表示**屏幕空间**间接光照  
**直接光照** 除注释外仅针对太阳（月亮）光  
**反射和折射** 仅针对世界空间  
**焦散** 仅针对光线追踪  
**[1]** 仅用于优化接触处阴影  
**[2]** 仅使用辐照度进行间接光照  
**[3]** 方块光源按直接光照追踪，太阳（月亮）光使用阴影贴图  
**[4]** Rethinking Voxels 自 **r0.1-beta3** 起使用符号距离场 (<tooltip term="SDF">SDF</tooltip>) 代替体素化，可以无差别保存实体和方块数据。  
**[5]** 原版没有提供 <tooltip term="SSBO">SSBO</tooltip> 或阴影贴图，只能将体素信息保存在屏幕缓冲中。

<seealso>
  <category ref="related">
    <a href="raytracingCorrection.md" summary="大众对于光线追踪的各种误区">误区纠正 - 光线追踪</a>
  </category>
  <category ref="advance">
    <a href="https://media.contentapi.ea.com/content/dam/ea/seed/presentations/2019-ray-tracing-gems-chapter-25-barre-brisebois-et-al.pdf">混合追踪管线 (Ray Tracing Gems, EA SEED)</a>
    <a href="https://www.pbr-book.org/4ed/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies">光线追踪加速结构 (PBRT v4, Matt Pharr et al.)</a>
  </category>
</seealso>

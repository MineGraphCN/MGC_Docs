<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-12T10:41:34.502183353"><title>结构和管线 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"optifine","level":0,"title":"OptiFine 加载光影的方法","anchor":"#optifine"},{"id":"pipeline","level":0,"title":"管线","anchor":"#pipeline"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="结构和管线 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/0-1-filepipeline.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="结构和管线 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/0-1-filepipeline.html#webpage",
    "url": "https://docs.minegraph.cn/md/0-1-filepipeline.html",
    "name": "结构和管线 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="0-1-filePipeline" data-main-title="结构和管线" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Developer.md|创作者文档///shaderTutorial.md|光影开发教程///创作之前"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="0-1-filePipeline" id="0-1-filePipeline.md">结构和管线</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-d3j68h_6\&quot;\u003e本章节将会为你介绍 OptiFine 的光影加载方法和处理管线，是创作光影必须的前置知识。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="optifine" data-toc="optifine">OptiFine 加载光影的方法</h2><p id="-d3j68h_7">OptiFine 会遍历 <code class="code" id="-d3j68h_31">shaderpacks</code> 下的文件夹和 <code class="code" id="-d3j68h_32">.zip</code> 压缩包，将所有包含 <code class="code" id="-d3j68h_33">shaders</code> 文件夹的内容都视为光影外壳（<code class="code" id="-d3j68h_34">shaders</code> 也是这一层级下唯一的寻找目标，其中包含了所有着色器和配置文件），我们将它们称为<span class="control" id="-d3j68h_35">外壳文件夹</span> 。除了读取外壳文件夹，OptiFine 还会读取 <code class="code" id="-d3j68h_36">.txt</code> 文件，如果这个文件的名字与外壳文件夹相同（如果是压缩包，则包含 <code class="code" id="-d3j68h_37">.zip</code> 后缀名），则会视为<span class="control" id="-d3j68h_38">光影设置文件</span>。</p><div class="code-block" data-lang="bash">
└─ shaderpacks
   ├─ aWOWshaderA            # 文件夹光影
   ├─ aWOWshaderA.txt        # 光影对应的配置文件
   ├─ aFancyshaderB.zip      # 压缩包光影
   └─ aFancyshaderB.zip.txt  # 保留 .zip 后缀的 .txt 文本文件
</div><ul class="list _bullet" id="-d3j68h_9"><li class="list__item" id="-d3j68h_39"><p id="-d3j68h_40">需要注意的是，OptiFine 会先寻找外壳文件夹，然后在外壳内寻找 <code class="code" id="-d3j68h_43">shaders</code> 文件夹，因此，如果将一个包含着色器文件的 <code class="code" id="-d3j68h_44">shaders</code> 文件夹直接放在 <code class="code" id="-d3j68h_45">shaderpacks</code> 下，或者外壳内还嵌套了一个文件夹（常见于压缩包，一些压缩软件会在打包时自动新建一层文件夹），则在新版本的 OptiFine 下不会读取。</p><div class="code-block" data-lang="bash">
└─ shaderpacks
   ├─ shaderNameA
   │  └─ shaders # 正常读取
   │     └─ &lt;着色器程序&gt;
   ├─ shaders # 缺少外壳，无法读取
   │   └─ &lt;着色器程序&gt;
   └─ shaderNameB
      └─ folderB
         └─ shaders # 多重嵌套，无法读取
            └─ &lt;着色器程序&gt;
</div><aside class="prompt" data-type="tip" data-title="" id="-d3j68h_42"><p id="-d3j68h_46">老版本的 OptiFine 会认为前者的名字就叫 <span class="emphasis" id="-d3j68h_47">shaders</span> ，并把它视为外壳文件夹，然后试图寻找这个外壳文件夹中的 <code class="code" id="-d3j68h_48">shaders</code> 文件夹；如果是后者的情况，OptiFine 只会试图在第一层外壳下寻找 <code class="code" id="-d3j68h_49">shaders</code> 文件夹。因此这两种情况都会导致光影虽然显示在列表中，却无法正确加载。</p></aside></li></ul><p id="-d3j68h_10">我们将 <code class="code" id="-d3j68h_50">shaders</code> 文件夹称为<span class="control" id="-d3j68h_51">主文件夹</span>。</p><p id="-d3j68h_11">在 <code class="code" id="-d3j68h_52">shaders</code> 下， OptiFine 首先会寻找配置文件</p><ul class="list _bullet" id="-d3j68h_12"><li class="list__item" id="-d3j68h_53"><p><code class="code" id="-d3j68h_55">shaders.properties</code> ，当前光影的内部配置文件，我们称为<span class="control" id="-d3j68h_56">光影配置</span>。</p></li><li class="list__item" id="-d3j68h_54"><p><code class="code" id="-d3j68h_57">entities.properties</code>、 <code class="code" id="-d3j68h_58">item.properties</code> 和 <code class="code" id="-d3j68h_59">block.properties</code> ，实体、物品和方块类型在当前光影中的映射 ID，我们称为<span class="control" id="-d3j68h_60">实体／物品／方块 ID 配置</span>。</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="-d3j68h_13"><p id="-d3j68h_61">此处的配置文件并非前文所述的光影<span class="emphasis" id="-d3j68h_62">设置</span>文件，前者主要用于配置着色器的状态和提前处理部分数据，而后者是用于调整光影的宏定义和常量从而影响着色器效果。</p></aside><p id="-d3j68h_14">获取到配置文件之后，OptiFine 会继续寻找 <code class="code" id="-d3j68h_63">lang</code> 和 <code class="code" id="-d3j68h_64">world&lt;ID&gt;</code> 文件夹。</p><ul class="list _bullet" id="-d3j68h_15"><li class="list__item" id="-d3j68h_65"><p><code class="code" id="-d3j68h_67">lang</code> 文件夹下包含对可调宏定义和 <code class="code" id="-d3j68h_68">const</code> 修饰符变量的翻译文件，或者说<span class="control" id="-d3j68h_69">语言文件</span> ，它做的实际上是将 <span class="emphasis" id="-d3j68h_70">宏定义</span>、 <span class="emphasis" id="-d3j68h_71">常量</span> 和 <span class="emphasis" id="-d3j68h_72">选项卡</span> 重映射为对应字符串以用于光影设置页面。 </p><ul class="list _bullet" id="-d3j68h_73"><li class="list__item" id="-d3j68h_74"><p>语言文件的命名规则是 <code class="code" id="-d3j68h_76">&lt;语言&gt;_&lt;地区&gt;.lang</code> ，如 <code class="code" id="-d3j68h_77">zh_cn.lang</code> 。其中地区可以大写，但在某些 OptiFine 版本下，可能会导致包括中文在内的一些语言无法读取，因此，我们建议都使用小写。</p></li><li class="list__item" id="-d3j68h_75"><p>光影设置会尝试读取对应当前游戏设置的语言文件，如果语言文件不存在，则先尝试读取英语语言文件（<code class="code" id="-d3j68h_78">en_us.lang</code> ），如果英语语言文件也不存在，则直接显示定义名。</p></li></ul></li><li class="list__item" id="-d3j68h_66"><p><code class="code" id="-d3j68h_79">world&lt;ID&gt;</code> 文件夹下是对应维度的着色器， <code class="code" id="-d3j68h_80">world0</code> 表示主世界， <code class="code" id="-d3j68h_81">world-1</code> 表示下界， <code class="code" id="-d3j68h_82">world1</code> 表示末地，其他模组额外生成的世界通常也会有一个序号，如暮色森林是 <code class="code" id="-d3j68h_83">world7</code> 。OptiFine 会优先使用这里的着色器渲染对应的世界，当文件夹不存在时，会使用主文件夹下的着色器。 </p><ul class="list _bullet" id="-d3j68h_84"><li class="list__item" id="-d3j68h_85"><p>我们将 <code class="code" id="-d3j68h_86">world&lt;ID&gt;</code> 称为<span class="control" id="-d3j68h_87">维度文件夹</span> ，对应的着色器称为<span class="control" id="-d3j68h_88">维度着色器</span>。</p></li></ul></li></ul><p id="-d3j68h_16">回到 <code class="code" id="-d3j68h_89">shaders</code> 文件夹下，OptiFine 在检查了所有默认读取的文件和文件夹之后，开始编译光影。它会将主文件夹和每个维度文件夹下着色器文件的代码编译为程序。根据管线顺序，OptiFine 会主动读取并编译 <code class="code" id="-d3j68h_90">.vsh</code>、 <code class="code" id="-d3j68h_91">.gsh</code>、 <code class="code" id="-d3j68h_92">.fsh</code> 和 <code class="code" id="-d3j68h_93">.csh</code> 文件，分别对应 <span class="emphasis" id="-d3j68h_94">顶点着色器</span>、 <span class="emphasis" id="-d3j68h_95">几何着色器</span>、 <span class="emphasis" id="-d3j68h_96">片段着色器</span> 和 <span class="emphasis" id="-d3j68h_97">计算着色器</span>。</p><aside class="prompt" data-type="tip" data-title="" id="-d3j68h_17"><p id="-d3j68h_98">着色器类型简介见 <a href="shaderbasic.html#whatWasYourMissionInShader" id="-d3j68h_99" data-tooltip="光影通常以多个着色器组成，着色器接收渲染模组提供的各种变量，以及先前乃至上一帧计算好的存入缓冲区的信息，按照程序进行计算后输出到指定的缓冲区。不同渲染模组的工作原理不尽相同，所对应的光影包规格也有所区别。">着色器 基本概念</a>。</p></aside><p id="-d3j68h_18">OptiFine 允许我们使用类似 C / C++ 的 <code class="code" id="-d3j68h_100">#include</code> 宏来调用其不会主动读取的文件，路径的根目录为主文件夹（<code class="code" id="-d3j68h_101">shaders</code>）：</p><p id="-d3j68h_19">例如使用</p><div class="code-block" data-lang="glsl">
#include &quot;/lib/shadow.glsl&quot;
</div><p id="-d3j68h_21">来调用位于</p><div class="code-block" data-lang="bash">
└─ shaders
   └─ lib
</div><p id="-d3j68h_23">下的文件 <code class="code" id="-d3j68h_102">shadow.glsl</code></p><aside class="prompt" data-type="tip" data-title="" id="-d3j68h_24"><p id="-d3j68h_103">这样做的好处是，当我们想对某些相同的程序或函数进行修改时，只需修改一次，减少出错。在我们的教程中，自定义文件的扩展名统一为 <code class="code" id="-d3j68h_104">.glsl</code> ，我们的插件会自动识别 <code class="code" id="-d3j68h_105">.glsl</code> 后缀，省去了自己设置的麻烦。当然，你也可以按照着色器的类型将其后缀设置为 <code class="code" id="-d3j68h_106">.vertex</code>、 <code class="code" id="-d3j68h_107">.fragment</code>、 <code class="code" id="-d3j68h_108">.geometry</code>、 <code class="code" id="-d3j68h_109">.compute</code> 以及其他自定义后缀。</p></aside><p id="-d3j68h_25">这里总结了 OptiFine 默认读取的光影文件。</p><div class="code-block" data-lang="bash">
└─ shaderpacks
   └─ &lt;光影名称 | 光影名称.zip&gt;
      └─ shaders
         ├─ lang
         │  └─ &lt;语言文件&gt;
         ├─ world-1
         │  └─ &lt;下界着色器程序&gt;
         ├─ world0
         │  └─ &lt;主世界着色器程序&gt;
         ├─ world1
         │  └─ &lt;末地着色器程序&gt;
         ├─ world&lt;ID&gt;
         │  └─ &lt;其他世界着色器程序&gt;
         ├─ &lt;通用着色器程序&gt;
         ├─ block.properties
         ├─ entities.properties
         ├─ item.properties
         └─ shaders.properties
</div></section><section class="chapter"><h2 id="pipeline" data-toc="pipeline">管线</h2><p id="-d3j68h_110">现代常用的渲染方法包括 <a href="shaderbasic.html#向前渲染法" id="-d3j68h_121" data-tooltip="">向前渲染法</a> 和 <a href="shaderbasic.html#延迟渲染法" id="-d3j68h_122" data-tooltip="">延迟渲染法</a>。</p><p id="-d3j68h_111">OptiFine 使用的是延迟渲染法：</p><ol class="list _decimal" id="-d3j68h_112" type="1"><li class="list__item" id="-d3j68h_123"><p>在几何缓冲阶段将所有几何体按类型分批传入不同的着色器，并将计算结果写入缓冲区。</p></li><li class="list__item" id="-d3j68h_124"><p>在延迟处理阶段，计算颜色并输出结果。</p></li></ol><p id="-d3j68h_113">不过你也可以忽略延迟渲染阶段，直接在几何缓冲阶段进行渲染。</p><aside class="prompt" data-type="note" data-title="" id="-d3j68h_114"><p id="-d3j68h_125">我们约定将<span class="control" id="-d3j68h_126">没有半透明</span>效果或<span class="control" id="-d3j68h_127">仅有完全镂空纹理</span> （如树叶和普通玻璃）的几何体称为<span class="control" id="-d3j68h_128">固体几何</span>； <br><span class="control" id="-d3j68h_130">有半透明</span>效果（如染色玻璃和水）的称为<span class="control" id="-d3j68h_131">半透明几何</span>； <br><span class="control" id="-d3j68h_133">其他粒子</span>则称为<span class="control" id="-d3j68h_134">粒子几何</span>。</p></aside><p id="-d3j68h_115">OptiFine 接管了从 GUI 开始直到场景输出的全部管线，下图列出了整个画面输出流程。</p><p> <a data-external="true" id="-d3j68h_116" href="resources/ofpp_simple_bg.png" target="_blank" rel="noopener noreferrer"><figure id="-d3j68h_135"><img alt="OptiFine 管线" src="MGC_Docs/ofpp_simple.png" title="OptiFine 管线" data-dark-src="MGC_Docs/ofpp_simple_dark.png" width="2217" height="1782"></figure></a></p><p id="-d3j68h_117">单击图片查看和保存附带深色背景的原图。</p><p id="-d3j68h_118">有关每个程序的处理对象，见 <a href="a03-gbuffertargets.html" id="-d3j68h_136" data-tooltip="几何缓冲程序处理对象">几何缓冲程序处理对象</a>。</p><p id="-d3j68h_120">现在，你已经全面了解了 OptiFine 的光影包结构。在下一章中，我们将学习 GLSL 的语法并了解它的特性。</p></section><div class="last-modified">Last modified: 12 March 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="0-2-prepare.html" class="navigation-links__prev">准备工作</a><a href="0-3-helloglsl.html" class="navigation-links__next">初识 GLSL</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
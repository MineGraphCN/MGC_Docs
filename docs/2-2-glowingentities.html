<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-21T10:28:39.758997223"><title>发光实体再处理 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"-wh6ww7_6","level":0,"title":"直接写入任何数据","anchor":"#-wh6ww7_6"},{"id":"-wh6ww7_14","level":1,"title":"声明扩展","anchor":"#-wh6ww7_14"},{"id":"-wh6ww7_15","level":1,"title":"使用图像类型","anchor":"#-wh6ww7_15"},{"id":"-wh6ww7_7","level":0,"title":"描边与原版实现","anchor":"#-wh6ww7_7"},{"id":"-wh6ww7_8","level":0,"title":"多程序处理","anchor":"#-wh6ww7_8"},{"id":"-wh6ww7_9","level":0,"title":"习题","anchor":"#-wh6ww7_9"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="发光实体再处理 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/2-2-glowingentities.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="发光实体再处理 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/2-2-glowingentities.html#webpage",
    "url": "https://docs.minegraph.cn/md/2-2-glowingentities.html",
    "name": "发光实体再处理 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="2-2-glowingEntities" data-main-title="发光实体再处理" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="创作者文档///shaderTutorial.md|光影开发教程///我们需要再深入一些"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="2-2-glowingEntities" data-annotation-ids="wip" id="2-2-glowingEntities.md">发光实体再处理</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-wh6ww7_10\&quot;\u003e在上一节中，我们将第一轮中所有的几何缓冲程序都进行了初步处理，它们现在都会在场景中正确绘制，除了几个来捣乱的半透明程序。\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;-wh6ww7_11\&quot;\u003e这一节我们将会进一步处理发光实体的专用着色器，让它在屏幕上绘制出正确的轮廓，并且不会被遮挡。\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;-wh6ww7_12\&quot;\u003e本节的内容较少但很重要，因此也请认真阅读。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="-wh6ww7_6" data-toc="-wh6ww7_6">直接写入任何数据</h2><p id="-wh6ww7_13">在之前的片段着色器中，我们一直使用片段着色器常规的输出方式，在全局空间声明 <code class="code" id="-wh6ww7_16">out</code> 变量，然后绘制到每个像素。不幸的是，在 OptiFine 的设置中，这些片段着色器都会主动进行深度测试，而且无法取消，为此我们只能寻求变通。幸运的是，GL 还有一种写入缓冲区的方案，而这个方案最初由英伟达作为扩展添加，并在 GLSL 4.20 转正为内置特性。</p><section class="chapter"><h3 id="-wh6ww7_14" data-toc="-wh6ww7_14">声明扩展</h3><p id="-wh6ww7_17">由于我们所声明的 GLSL 版本较低，因此需要使用 <code class="code" id="-wh6ww7_24">#extension</code> 指令来调用扩展：</p><div class="code-block" data-lang="glsl">
#extension GL_ARB_shader_image_load_store : enable
</div><p id="-wh6ww7_19">宏命令 <code class="code" id="-wh6ww7_25">#extension</code> 我们都知道了，它紧接的内容是扩展的名称，并辅以各种前缀：</p><ul class="list _bullet" id="-wh6ww7_20"><li class="list__item" id="-wh6ww7_26"><p id="-wh6ww7_28">现代规范要求扩展以 <code class="code" id="-wh6ww7_29">GL</code> 前缀开头；</p></li><li class="list__item" id="-wh6ww7_27"><p id="-wh6ww7_30"><code class="code" id="-wh6ww7_31">ARB</code> 表示获得了 OpenGL ARB 协会批准的正式扩展，类似的还有 <code class="code" id="-wh6ww7_32">EXT</code> 表示泛用的扩展，但是可能部分硬件厂商未予以实现；</p></li></ul><p id="-wh6ww7_21">如果名称使用 <code class="code" id="-wh6ww7_33">all</code> ，则会启用所有支持的扩展。</p><p id="-wh6ww7_22">指定了宏之后，我们还需要指定扩展的行为，在扩展名称后接 <code class="code" id="-wh6ww7_34">:</code> 即可进行定义。扩展的行为可以为 <code class="code" id="-wh6ww7_35">require</code>、 <code class="code" id="-wh6ww7_36">enable</code>、 <code class="code" id="-wh6ww7_37">warn</code> 和 <code class="code" id="-wh6ww7_38">disable</code> ，它们的具体行为由下表决定：</p><div class="table-wrapper"><table class="wide" id="-wh6ww7_23"><thead><tr class="ijRowHead" id="-wh6ww7_39"><th id="-wh6ww7_44"><p>行为</p></th><th id="-wh6ww7_45"><p>直接使用该扩展时</p></th><th id="-wh6ww7_46"><p>被其他扩展调用时</p></th><th id="-wh6ww7_47"><p>硬件不支持时</p></th></tr></thead><tbody><tr id="-wh6ww7_40"><td id="-wh6ww7_48"><p><code class="code" id="-wh6ww7_52">require</code></p></td><td id="-wh6ww7_49"><p>可行</p></td><td id="-wh6ww7_50"><p>可行</p></td><td id="-wh6ww7_51"><p>报错并中止</p></td></tr><tr id="-wh6ww7_41"><td id="-wh6ww7_53"><p><code class="code" id="-wh6ww7_57">enable</code></p></td><td id="-wh6ww7_54"><p>可行</p></td><td id="-wh6ww7_55"><p>可行</p></td><td id="-wh6ww7_56"><p>警告并继续</p></td></tr><tr id="-wh6ww7_42"><td id="-wh6ww7_58"><p><code class="code" id="-wh6ww7_62">warn</code></p></td><td id="-wh6ww7_59"><p>警告并继续</p></td><td id="-wh6ww7_60"><p>可行</p></td><td id="-wh6ww7_61"><p>警告并继续</p></td></tr><tr id="-wh6ww7_43"><td id="-wh6ww7_63"><p><code class="code" id="-wh6ww7_67">disable</code></p></td><td id="-wh6ww7_64"><p>报错并中止</p></td><td id="-wh6ww7_65"><p>报错并中止</p></td><td id="-wh6ww7_66"><p>-</p></td></tr></tbody></table></div></section><section class="chapter"><h3 id="-wh6ww7_15" data-toc="-wh6ww7_15">使用图像类型</h3><p id="-wh6ww7_68">和纹理类似，在着色器程序的全局空间使用 <code class="code" id="-wh6ww7_88">uniform</code> 关键字即可声明图像类型 <code class="code" id="-wh6ww7_89"><em id="-wh6ww7_93">g</em>image</code> ，我们可以在任何着色器中访问 0 ~ 5 号颜色缓冲区和两个阴影颜色缓冲区，只需要把它们的后缀从 <code class="code" id="-wh6ww7_90">tex</code> 改为 <code class="code" id="-wh6ww7_91">img</code> 。有一点不同的是，我们需要在之前使用 <code class="code" id="-wh6ww7_92">layout()</code> 指定图像的格式。</p><p id="-wh6ww7_69">上一节，我们将几何 ID 保存在了单通道8位无符号整数的 3 号缓冲区中，并且已经为发光实体保存了独特的 ID，但是这个 ID 实际只能用于为显露的发光实体处理额外特效。由于发光实体的描边特效仅描边外轮廓，而几何 ID 则覆盖了几何的内部，当发光实体被其他几何遮挡而强行写入时，延迟处理中的几何 ID 就会产生误判。</p><p id="-wh6ww7_70">因此，我们将会启用 4 号缓冲区，用以保存发光实体需要绘制的轮廓依据。在原版中虽然在写入原始数据时只有 <code class="code" id="-wh6ww7_94">1</code> （发光区域） 和 <code class="code" id="-wh6ww7_95">0</code> （非发光区域），但是后续进行模糊扩散处理要求插值过渡和独立处理描边的不透明度。为此，我们将 4 号缓冲区设置为双通道 16 位浮点来避免过渡断层，并依照上文的方法调用：</p><div class="code-block" data-lang="glsl">
[... Settings ...]
/*
const int colortex4Format = RG16F;
*/
[... gbuffers_entities_glowing ...]
layout(rg16f) uniform image2D colorimg4;
</div><p id="-wh6ww7_72">当然，你也可以将 3 号缓冲区的格式改为三通道，并将发光数据存入其中，但同时也需要处理先前的整型几何 ID，将它们转换为浮点值（习题 1）。</p><aside class="prompt" data-type="tip" data-title="" id="-wh6ww7_73"><p id="-wh6ww7_96">由于只能将 0 ~ 5 号缓冲区以图像格式读取，而几何缓冲又无法按常规方法读取 0 ~ 3 号缓冲区，可以在任何阶段以任何方式读写的颜色缓冲区实际上只有 4 号和 5 号，计算着色器还会更加放大这个问题。</p><p id="-wh6ww7_97">因此在几何缓冲阶段，如果只是要使用之前的屏幕缓冲区数据，则推荐把这些数据存入 5 号之后的缓冲区；而延迟处理阶段中，也最好将 4、5 号缓冲区特意留出。</p></aside><p id="-wh6ww7_74">我们可以使用函数 <code class="code" id="-wh6ww7_98">imageLoad(gimage image, ivec coord)</code> 来读取图像区域内任意坐标的内容，和 <code class="code" id="-wh6ww7_99">texelFetch()</code> 类似，它使用整数坐标，唯一的区别是图像不可以指定细节等级，此外，也可以使用 <code class="code" id="-wh6ww7_100">imageSize()</code> 函数来取到图像的尺寸，它直接返回整型值。</p><p id="-wh6ww7_75">同样的，使用 <code class="code" id="-wh6ww7_101">imageStore(gimage image, ivec coord, gvec4 data)</code> 来写入任意位置。无论几通道，第三项 <code class="code" id="-wh6ww7_102">data</code> 均为四维向量，由 GLSL 自动裁切。</p><p id="-wh6ww7_76">在实际写入之前，还需要注意的是，它不会进行任何深度测试和 Alpha 测试（或者说自动深度测试已经是程序结束之后了），所以如果你想要描边完美贴合实体，应当在 Alpha 测试的 <code class="code" id="-wh6ww7_103">discard</code> 之后才调用写入函数。</p><p id="-wh6ww7_77"><code class="code" id="-wh6ww7_104">discard</code> 指令在图像写入与片段着色器的普通输出之间有些许差别。如果触发了 <code class="code" id="-wh6ww7_105">discard</code> 指令，像素着色器的普通输出会停止并丢弃当前像素的任何东西；而图像写入则只会在当前位置停下，而不影响先前写入的内容。</p><div class="code-comparer" id="-wh6ww7_78" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="向图像写入">
vec4 color = vec4(1.0);
bool cond = doSth();

imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // 正常写入
if(cond) discard;
color = vec4(0.0);
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
</div><div class="code-block" data-lang="glsl" data-title="像素着色器输出">
vec4 color = vec4(1.0);
bool cond = doSth();

fragColor = color; // if()为假，写入；if()为真，无效
if(cond) discard;
color = vec4(0.0);
fragColor = color; // if()为假，写入；if()为真，无效
</div></div><p id="-wh6ww7_79">要想用普通输出达到图像写入的功能，可以使用反转条件：</p><div class="code-block" data-lang="glsl">
fragColor = color; // 正常写入
if(!cond) {
    color = vec4(0.0);
    fragColor = color; // if()为真，写入；if()为假，无效
}
</div><p id="-wh6ww7_81">要想用图像写入达到普通输出功能，可以延后图像写入到条件判定之后（虽然在我们这个例子中看起来有点神经&hellip;&hellip;）：</p><div class="code-block" data-lang="glsl">
if(cond) discard;
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
color = vec4(0.0);
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
</div><p id="-wh6ww7_83">最后，我们的 <code class="code" id="-wh6ww7_108">gbuffers_entities_glowing.glsl</code> 就长这样了：</p><div class="code-block" data-lang="glsl">
[... 片段着色器部分 ...]
#extension GL_ARB_shader_image_load_store : enable
[...]
layout(rg16f) uniform image2D colorimg4;
[... main ...]
[...]
if(fragColor.a &lt;= alphaTestRef) discard; // 先进行 Alpha 测试！
imageStore(colorimg4, ivec2(gl_FragCoord.xy), vec4(1.0));
[...]
</div><p id="-wh6ww7_85">如果直接读取发光实体缓冲，看起来就像这样：</p><figure id="-wh6ww7_86"><img alt="发光实体缓冲区" src="MGC_Docs/glowingEntities_glowingBuffer.webp" title="发光实体缓冲区" width="700" height="394"></figure><aside class="prompt" data-type="tip" data-title="" id="-wh6ww7_87"><p id="-wh6ww7_109">除此之外，图像类型还可以进行原子操作，即当不同着色器程序向同一张图像的同一个位置写入相同数据时，会严格按照程序的执行顺序进行处理，不会出现次序问题。</p><p id="-wh6ww7_110">可以用于原子操作的图像格式有严格的限制，只可以是 <code class="code" id="-wh6ww7_115">R32I/r32i</code> 或 <code class="code" id="-wh6ww7_116">R32UI/r32ui</code> ，但是通过格式转换是可以在其他格式上使用的，例如将一个 <code class="code" id="-wh6ww7_117">RGBA8I</code> （4x8=32位）声明为 <code class="code" id="-wh6ww7_118">R32I</code> （1x32=32位），不过这就需要手动进行移位来处理具体内容了。</p><p id="-wh6ww7_111">所有原子操作返回的值都是图像位置上的原始值，下列的 <code class="code" id="-wh6ww7_119"><em id="-wh6ww7_124">g</em>int</code> 中的 <span class="emphasis" id="-wh6ww7_120"><code class="code" id="-wh6ww7_125">g</code></span> 指的是 <code class="code" id="-wh6ww7_121">int</code> 或 <code class="code" id="-wh6ww7_122">uint</code>。 <code class="code" id="-wh6ww7_123">IMAGE_COORDS</code> 表示正在处理的图像的像素坐标。</p><ul class="list _bullet" id="-wh6ww7_112"><li class="list__item" id="-wh6ww7_126"><p id="-wh6ww7_131">原子赋值，由于它们会返回原值，所以也可用作交换： <br><code class="code" id="-wh6ww7_133">gint imageAtomicExchange(gimage image, IMAGE_COORDS, gint data)</code></p></li><li class="list__item" id="-wh6ww7_127"><p id="-wh6ww7_134">原子条件赋值，仅当图像目标值等于条件值时赋值： <br><code class="code" id="-wh6ww7_136">gint imageAtomicCompSwap(gimage image, IMAGE_COORDS, gint compare, gint data)</code></p></li><li class="list__item" id="-wh6ww7_128"><p id="-wh6ww7_137">原子算术，GLSL 仅提供加法，但是你可以在<span class="control" id="-wh6ww7_138">有符号整数运算</span>中为 <code class="code" id="-wh6ww7_139">data</code> 添加负号来进行减法运算： <br><code class="code" id="-wh6ww7_141">gint imageAtomicAdd(gimage image, IMAGE_COORDS, gint data)</code><br> 自 GLSL 4.30 起，你也可以在无符号整数中进行这种计算，只需要写作 <code class="code" id="-wh6ww7_143">imageAtomicAdd(..., uint(-data))</code> 。当然，你得保证最终的值不会为负而溢出。</p></li><li class="list__item" id="-wh6ww7_129"><p id="-wh6ww7_144">原子位运算，可以进行与、或和异或运算： <br><code class="code" id="-wh6ww7_146">gint imageAtomicAnd(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="-wh6ww7_148">gint imageAtomicOr(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="-wh6ww7_150">gint imageAtomicXor(gimage image, IMAGE_COORDS, gint data)</code></p></li><li class="list__item" id="-wh6ww7_130"><p id="-wh6ww7_151">原子大小值，可以取最大值和最小值： <br><code class="code" id="-wh6ww7_153">gint imageAtomicMin(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="-wh6ww7_155">gint imageAtomicMax(gimage image, IMAGE_COORDS, gint data)</code></p></li></ul><p id="-wh6ww7_113">你也可以使用 <code class="code" id="-wh6ww7_156">memoryBarrier()</code> 来手动设置内存屏障。</p><p id="-wh6ww7_114">资料来源： <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store" id="-wh6ww7_157" data-external="true" rel="noopener noreferrer" target="_blank">Image Load Store - OpenGL Wiki</a> ，此处仅作扩展阅读，留由读者自行研究。</p></aside></section></section><section class="chapter"><h2 id="-wh6ww7_7" data-toc="-wh6ww7_7">描边与原版实现</h2><p id="-wh6ww7_158">现在我们已经获得了发光实体的遮罩数据，如果单纯地想给覆盖区域外围加上一圈描边，我们只需要在延迟处理中简单地检查当前像素是否为非发光区域，然后搜索邻近的四个（或加上对角线共八个）像素即可。当搜索到任何一个邻近像素是发光区域时，就给当前像素上色，类似这样：</p><div class="code-block" data-lang="glsl">
[... Uniforms.glsl ...]
uniform isampler2D colortex4;
[... final - main ...]
bool isGlowing = bool(texture(colortex4, uv).r);
bool isGlowingEdge = false;
if(!isGlowing) {
    for(int i = -1; i &lt; 2; i+=2) {
        ivec2 sCoord = ivec2(gl_FragCoord.xy) + ivec2(i,0);
        isGlowingEdge = bool(texelFetch(colortex4, sCoord, 0).r);
        if(isGlowingEdge) break;
    }
    for(int i = -1; i &lt; 2 &amp;&amp; !isGlowingEdge; i+=2) {
        ivec2 sCoord = ivec2(gl_FragCoord.xy) + ivec2(0,i);
        isGlowingEdge = bool(texelFetch(colortex4, sCoord, 0).r);
        if(isGlowingEdge) break;
    }
}
if(isGlowingEdge) fragColor = vec4(1.0);
</div><p id="-wh6ww7_160">至此，我们就已经初步成功给发光实体描上边了，值得注意的是，上一章中，我们将发光实体暂时设定为了无光照类：</p><figure id="-wh6ww7_161"><img alt="发光实体描边" src="MGC_Docs/glowingEntities_glowingEdge.webp" title="发光实体描边" width="700" height="394"></figure><p id="-wh6ww7_162">当然，这个发光描边效果仍然很粗糙，只有 1 像素，分辨率高一些观感就会变得很差，所以让我们继续拆解原版的发光描边着色器。</p><p id="-wh6ww7_163">原版的描边使用了两个后处理 Pass 进行处理，第一个 Pass <code class="code" id="-wh6ww7_171">entity_outline_box_blur</code> 使用方框模糊处理了发光区域的数据并让 Alpha 值在模糊边缘断层，从而形成颜色过渡：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="false" data-synopsis="entity_outline_box_blur.fsh">
#version 150

uniform sampler2D InSampler;

in vec2 texCoord;
in vec2 sampleStep;

out vec4 fragColor;

void main() {
    vec4 blurred = vec4(0.0);
    float radius = 2.0;
    for (float a = -radius + 0.5; a &lt;= radius; a += 2.0) {
        blurred += texture(InSampler, texCoord + sampleStep * a);
    }
    blurred += texture(InSampler, texCoord + sampleStep * radius) / 2.0;
    fragColor = vec4((blurred / (radius + 0.5)).rgb, blurred.a);
}
</div><p id="-wh6ww7_165">这个着色器利用 <code class="code" id="-wh6ww7_172">texture()</code> 的插值性在纹理的四个像素交界处进行两次采样，然后再单独在采样方向上的最外侧进行一次采样，从而快速获得半径内的平均色，最后再除以采样半径 <span id="-wh6ww7_173"><sup class="superscript"><span class="control" id="-wh6ww7_174">1</span></sup></span>。</p><p id="-wh6ww7_166"><span class="control" id="-wh6ww7_175">[1]</span> 因为之前的采样都是两两像素的平均色，最后一次采样又手动减半，因此采样出来的颜色总和实际上只有一半，所以最后除数就不必为像素数量总和了。</p><p id="-wh6ww7_167">第二个 Pass <code class="code" id="-wh6ww7_176">entity_outline</code> <span id="-wh6ww7_177"><sup class="superscript"><span class="control" id="-wh6ww7_178">1</span></sup></span> 则用于再次混合周围的颜色并比较周围 Alpha 的总差异来确认颜色和混合比例：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="false" data-synopsis="entity_sobel.fsh">
#version 150

uniform sampler2D InSampler;

in vec2 texCoord;
in vec2 oneTexel;

out vec4 fragColor;

void main(){
    vec4 center = texture(InSampler, texCoord);
    vec4 left = texture(InSampler, texCoord - vec2(oneTexel.x, 0.0));
    vec4 right = texture(InSampler, texCoord + vec2(oneTexel.x, 0.0));
    vec4 up = texture(InSampler, texCoord - vec2(0.0, oneTexel.y));
    vec4 down = texture(InSampler, texCoord + vec2(0.0, oneTexel.y));
    float leftDiff  = abs(center.a - left.a);
    float rightDiff = abs(center.a - right.a);
    float upDiff    = abs(center.a - up.a);
    float downDiff  = abs(center.a - down.a);
    float total = clamp(leftDiff + rightDiff + upDiff + downDiff, 0.0, 1.0);
    vec3 outColor = center.rgb * center.a + left.rgb * left.a + right.rgb * right.a + up.rgb * up.a + down.rgb * down.a;
    fragColor = vec4(outColor * 0.2, total);
}
</div><p id="-wh6ww7_169"><span class="control" id="-wh6ww7_179">[1]</span> 原版允许使用 JSON 文件自定义使用的顶点着色器和片段着色器，因此会出现 Pass 名称和着色器名称对不上的情况。</p><p id="-wh6ww7_170">虽然原版中使用了整个全通道的缓冲区用来处理输出，但如果我们只使用纯色，则只需要单个通道（习题 2）。我们用来处理发光轮廓的代码也将以它们为蓝本。</p></section><section class="chapter"><h2 id="-wh6ww7_8" data-toc="-wh6ww7_8">多程序处理</h2><p id="-wh6ww7_180">之前的编程中，我们的延迟处理程序都集中在管线的最末端，即 <code class="code" id="-wh6ww7_196">final</code> 中。而描边着色器要求将场景完全模糊之后再来检查，也就是说，如果我们想在同一个着色器中完成这些事情，需要将四周邻近的像素都进行模糊处理然后再来比较。然而普通的片段着色器中，这些数据是无法共享的，也就是说周围的像素在它们各自的片段着色器中也会这样干，最终就会造成四倍的模糊开销，这是极其不划算的。自然而然的，我们就会做出像原版那样的事情：先在一个 Pass 中进行图像模糊，再在下一个 Pass 中处理描边。</p><p id="-wh6ww7_181">OptiFine 为我们提供了高度可自定义的延迟处理程序数量。回顾一下，我们可以用的延迟处理主要集中在两个阶段：固体几何缓冲之后的 Deferred 和余下几何缓冲之后的 Composite 。像发光描边这种类似 HUD 的特效，我们肯定是不希望被第二轮几何缓冲中的几何体给覆盖的，因此我们能选择的就只有 Composite 阶段了。</p><p id="-wh6ww7_182">原版的模糊着色器很奇怪，它只在某个方向（<code class="code" id="-wh6ww7_197">sampleStep</code> ）上处理了模糊（或许也运行了两次？）。为了更好的品质，我们会将模糊本身也分为两个 Pass，先将其进行水平模糊，再进行垂直模糊，这样处理的结果会更加柔和。因此我们的模糊就在 <code class="code" id="-wh6ww7_198">composite</code> 和 <code class="code" id="-wh6ww7_199">composite1</code> 中进行，而描边则接在 <code class="code" id="-wh6ww7_200">final</code> 中场景绘制完毕之后。</p><p id="-wh6ww7_183">没有特别的要求的话，所有延迟处理的顶点着色器都一样，因此你可以直接复制 <code class="code" id="-wh6ww7_201">final.vsh</code> 并更名。</p><p id="-wh6ww7_184">参考原版着色器，它使用了方框模糊（Box Blur）将周围的数据进行平均，我们也将仿照它的方法和技巧，进行 5x5 的模糊处理，并将半径设计为可调整。</p><p id="-wh6ww7_185">其他的常规声明与 Final 一样，在这个着色器中，我们只需要向发光数据中写入内容，因此渲染目标只有 4 号缓冲区：</p><div class="code-block" data-lang="glsl">
/* DRAWBUFFERS:4 */
layout(location = 0) out vec2 glowingBuffer;
</div><p id="-wh6ww7_187"><code class="code" id="-wh6ww7_202">main</code> 函数的内容和原版着色器很相似，只不过我们可以把模糊半径塞入 <code class="code" id="-wh6ww7_203">Settings.glsl</code> 中，以便间接控制发光描边宽度。水平模糊的着色器看起来就像这样：</p><div class="code-block" data-lang="glsl">
vec2 blurred = vec2(0.0);
for(float i = -GLOWING_BLUR_RADIUS + .5; i &lt;= GLOWING_BLUR_RADIUS; i += 2.0) {
    blurred += texture(colortex4, uv + vec2(pixelSize.x, 0.0) * i).rg;
}
blurred += texture(colortex4, uv + vec2(pixelSize.x, 0.0) * GLOWING_BLUR_RADIUS).r / 2.0;
glowingBuffer = vec2(blurred.x / (GLOWING_BLUR_RADIUS + .5), blurred.y);
</div><p id="-wh6ww7_189">而垂直模糊只需要将 <code class="code" id="-wh6ww7_204">vec2(pixelSize.x, 0.0)</code> 对调为 <code class="code" id="-wh6ww7_205">vec2(0.0, pixelSize.y)</code> 即可。</p><p id="-wh6ww7_190">最后，我们回到 Final 中，将原版的方法封装成函数原样搬入，只需要注意将 <code class="code" id="-wh6ww7_206">.rgb</code> 分量更改为 <code class="code" id="-wh6ww7_207">.r</code>， <code class="code" id="-wh6ww7_208">.a</code> 分量更改为 <code class="code" id="-wh6ww7_209">.g</code> ，然后将其他统一变量对齐即可：</p><div class="code-block" data-lang="glsl">
vec2 getGlowingEdge() {
    vec2 center = texture(colortex4, uv).rg;
    vec2 left = texture(colortex4, uv - vec2(pixelSize.x, 0.0)).rg;
    vec2 right = texture(colortex4, uv + vec2(pixelSize.x, 0.0)).rg;
    vec2 up = texture(colortex4, uv - vec2(0.0, pixelSize.y)).rg;
    vec2 down = texture(colortex4, uv + vec2(0.0, pixelSize.y)).rg;
    float leftDiff  = abs(center.g - left.g);
    float rightDiff = abs(center.g - right.g);
    float upDiff    = abs(center.g - up.g);
    float downDiff  = abs(center.g - down.g);
    float total = clamp(leftDiff + rightDiff + upDiff + downDiff, 0.0, 1.0);
    float outColor = center.r * center.g + left.r * left.g + right.r * right.g + up.r * up.g + down.r * down.g;
    return vec2(outColor / (GLOWING_BLUR_RADIUS * 2. + 1.), total);
}
</div><p id="-wh6ww7_192">这里为了更好地适应大半径下描边颜色的过渡，我们将返回值中 <code class="code" id="-wh6ww7_210">outColor</code> 的除数改写为了半径自适应。最后，将 Final 中之前的颜色与之相混合，就可以绘制出发光描边了：</p><div class="code-block" data-lang="glsl">
vec2 glowingEdge = getGlowingEdge();
fragColor.rgb = mix(fragColor.rgb, glowingEdge.rrr, glowingEdge.g);
</div><p id="-wh6ww7_194">当然，你也可以自定义发光描边的颜色。最后让我们欣赏欣赏将模糊半径改写为 10，并将混合颜色使用三角函数和 <code class="code" id="-wh6ww7_211">frameTimeCounter</code> 处理以呈现的动态彩虹发光描边！</p><figure data-theme="light" id="-wh6ww7_195" width="700"><img alt="彩虹描边" class="js-gif article__bordered-element" data-gif-src="MGC_Docs/glowingEntities_RAINBOW.gif" width="700" style="width: 700px;"></figure></section><section class="chapter"><h2 id="-wh6ww7_9" data-toc="-wh6ww7_9">习题</h2><ol class="list _decimal" id="-wh6ww7_212" type="1"><li class="list__item" id="-wh6ww7_213"><p id="-wh6ww7_215">（与习题 2 二选一）将 4 号缓冲区的内容合并入 3 号缓冲区中。之后，你可以先使用 <code class="code" id="-wh6ww7_216">imageLoad(colorimg3, COORD).r</code> 取出已经写入的几何 ID，然后手动进行深度测试来决定保留几何 ID 的源内容还是覆写新内容（当前片段深度小于深度图上已有的深度时，说明发光实体本身也在前景，因此要覆写几何 ID），最后使用 <code class="code" id="-wh6ww7_217">imageStore(colorimg3, COORD, vec4(float(geometryID), vec2(1.0), 0.0))</code> 覆写图像内容并确保 G、B 通道为 1.0 即可。</p></li><li class="list__item" id="-wh6ww7_214"><p id="-wh6ww7_218">（与习题 1 二选一）将 4 号缓冲区改为四通道，并在几何缓冲存入数据时写入纹理颜色，这样在后处理中就会产生根据实体本身的区别产生不同的描边光效。</p></li></ol></section><div class="last-modified">21 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="2-1-solidgeometries.html" class="navigation-links__prev">固体几何缓冲</a><a href="a01-uniformsandats.html" class="navigation-links__next">OptiFine 提供的数据</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
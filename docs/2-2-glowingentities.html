<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-18T10:02:37.182826956"><title>发光实体再处理 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"puq0wh_5","level":0,"title":"图像读写","anchor":"#puq0wh_5"},{"id":"puq0wh_14","level":1,"title":"声明扩展","anchor":"#puq0wh_14"},{"id":"puq0wh_15","level":1,"title":"使用图像类型","anchor":"#puq0wh_15"},{"id":"puq0wh_6","level":0,"title":"描边与原版实现","anchor":"#puq0wh_6"},{"id":"puq0wh_7","level":0,"title":"多程序处理","anchor":"#puq0wh_7"},{"id":"puq0wh_8","level":0,"title":"习题","anchor":"#puq0wh_8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="发光实体再处理 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/2-2-glowingentities.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="发光实体再处理 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/2-2-glowingentities.html#webpage",
    "url": "https://docs.minegraph.cn/md/2-2-glowingentities.html",
    "name": "发光实体再处理 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="2-2-glowingEntities" data-main-title="发光实体再处理" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="创作者文档///shaderTutorial.md|光影开发教程///第二章 我们需要再深入一些"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="2-2-glowingEntities" id="2-2-glowingEntities.md">发光实体再处理</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;puq0wh_9\&quot;\u003e在上一节中，我们将第一轮中所有的几何缓冲程序都进行了初步处理，它们现在都会在场景中正确绘制，除了来捣乱的隐身实体和这一节我们将会处理的发光实体。\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;puq0wh_10\&quot;\u003e这一节我们将会进一步处理发光实体的专用着色器，让它在屏幕上绘制出正确的轮廓，并且不会被遮挡。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="puq0wh_5" data-toc="puq0wh_5">图像读写</h2><p id="puq0wh_11">还记得原版的发光实体吗？在生存模式中，当实体被光灵箭命中就会附加上发光效果。此时在其他玩家眼中，只要实体在渲染距离之内， <span class="control" id="puq0wh_16">无论是否被其他物体遮挡</span> ，它们都会有一层厚厚的描边。</p><figure id="puq0wh_12"><img alt="原版发光实体" src="MGC_Docs/glowingEntities_vanilla.webp" title="原版发光实体" width="700" height="394"></figure><p id="puq0wh_13">在之前的片段着色器中，我们一直使用片段着色器常规的输出方式，在全局空间声明 <code class="code" id="puq0wh_17">out</code> 变量，然后绘制到每个像素。不幸的是，在 OptiFine 的设置中，这些片段着色器都会主动进行深度测试，一旦被其他物体遮挡，几何体就不会被绘制，而且这个功能无法取消。幸运的是，GL 还有一种读写方案，而这个方案最初由英伟达作为扩展添加，并在 GLSL 4.20 转正为内置特性。</p><section class="chapter"><h3 id="puq0wh_14" data-toc="puq0wh_14">声明扩展</h3><p id="puq0wh_18">由于我们所声明的 GLSL 版本较低，因此需要使用 <code class="code" id="puq0wh_27">#extension</code> 指令来调用扩展：</p><div class="code-block" data-lang="glsl">
#extension GL_ARB_shader_image_load_store : enable
</div><p id="puq0wh_20">宏命令 <code class="code" id="puq0wh_28">#extension</code> 我们都知道了，它紧接是扩展名。扩展名的命名规律为：</p><ol class="list _decimal" id="puq0wh_21" type="1"><li class="list__item" id="puq0wh_29"><p id="puq0wh_32">以现代规范要求的 <code class="code" id="puq0wh_33">GL</code> 前缀开头；</p></li><li class="list__item" id="puq0wh_30"><p id="puq0wh_34">扩展的 <a href="https://www.khronos.org/opengl/wiki/OpenGL_Extension#Extension_Types" id="puq0wh_35" data-external="true" rel="noopener noreferrer" target="_blank">类型</a>， <code class="code" id="puq0wh_36">ARB</code> 表示获得了 OpenGL ARB 协会批准的正式扩展，类似的还有 <code class="code" id="puq0wh_37">EXT</code> 表示泛用的扩展，但是可能部分硬件厂商未予以实现；</p></li><li class="list__item" id="puq0wh_31"><p id="puq0wh_38">扩展的具体名称。</p></li></ol><p id="puq0wh_22">如果扩展名使用 <code class="code" id="puq0wh_39">all</code> ，则会启用所有支持的扩展。</p><p id="puq0wh_23">声明了扩展之后，我们还需要指定扩展的行为，在扩展名称后接 <code class="code" id="puq0wh_40">:</code> 即可进行定义。扩展的行为可以为 <code class="code" id="puq0wh_41">require</code>、 <code class="code" id="puq0wh_42">enable</code>、 <code class="code" id="puq0wh_43">warn</code> 和 <code class="code" id="puq0wh_44">disable</code> ，它们的具体行为由下表决定：</p><div class="table-wrapper"><table class="wide" id="puq0wh_24" width="700"><thead><tr class="ijRowHead" id="puq0wh_45"><th id="puq0wh_50"><p>行为</p></th><th id="puq0wh_51"><p>声明扩展</p></th><th id="puq0wh_52"><p>硬件不支持且使用扩展语法时</p></th></tr></thead><tbody><tr id="puq0wh_46"><td id="puq0wh_53"><p><code class="code" id="puq0wh_55">require</code></p></td><td id="puq0wh_54" colspan="2"><p>强制启用，不支持即报错</p></td></tr><tr id="puq0wh_47"><td id="puq0wh_56"><p><code class="code" id="puq0wh_59">enable</code></p></td><td id="puq0wh_57"><p>通过编译</p></td><td id="puq0wh_58"><p>报错并中止（失败）</p></td></tr><tr id="puq0wh_48"><td id="puq0wh_60"><p><code class="code" id="puq0wh_63">warn</code></p></td><td id="puq0wh_61"><p>通过编译</p></td><td id="puq0wh_62"><p>警告并继续（通过 <sup class="superscript" id="puq0wh_64"><b id="puq0wh_65">1</b></sup>）</p></td></tr><tr id="puq0wh_49"><td id="puq0wh_66"><p><code class="code" id="puq0wh_68">disable</code></p></td><td id="puq0wh_67" colspan="2"><p>强制禁用，使用即报错</p></td></tr></tbody></table></div><p id="puq0wh_25">除了 <code class="code" id="puq0wh_69">require</code> ，如果着色器的实际代码中没有使用任何扩展的内容或语法，则不会报错。</p><p id="puq0wh_26"><span class="control" id="puq0wh_70">[1]</span> 如果在不支持的硬件上使用了 <code class="code" id="puq0wh_71">warn</code> 行为的扩展，就算通过了编译，最后的程序也会出现未定义行为。由于我们有插件进行报错，这个行为基本不会用到。</p></section><section class="chapter"><h3 id="puq0wh_15" data-toc="puq0wh_15">使用图像类型</h3><p id="puq0wh_72">和纹理类似，在着色器程序的全局空间使用 <code class="code" id="puq0wh_92">uniform</code> 关键字即可声明图像类型 <code class="code" id="puq0wh_93"><em id="puq0wh_99">g</em>image</code> ，我们可以在任何着色器中访问 0 ~ 5 号颜色缓冲区和两个阴影颜色缓冲区，只需要把它们的后缀从 <code class="code" id="puq0wh_94">tex</code> 改为 <code class="code" id="puq0wh_95">img</code> （<code class="code" id="puq0wh_96">shadowcolor</code> 同样加上 <code class="code" id="puq0wh_97">img</code> 后缀）。有一点不同的是，我们需要使用 <code class="code" id="puq0wh_98">layout()</code> 指定图像的格式。</p><p id="puq0wh_73">上一节，我们将几何 ID 保存在了单通道8位无符号整数的 3 号缓冲区中，并且已经为发光实体保存了独特的 ID，但是这个 ID 实际只能用于为显露的发光实体处理额外特效。由于发光实体的描边特效仅描边外轮廓，而几何 ID 则覆盖了几何的内部，当发光实体被其他几何遮挡而强行写入时，延迟处理中的几何 ID 就会产生误判。</p><p id="puq0wh_74">因此，我们将会启用 4 号缓冲区，用以保存发光实体需要绘制的轮廓依据。在原版中虽然在写入原始数据时只有 <code class="code" id="puq0wh_100">1</code> （发光区域） 和 <code class="code" id="puq0wh_101">0</code> （非发光区域），但是后续进行模糊扩散要求插值过渡，还要独立处理描边的不透明度，不过实际上也只需要一个数据。为此，我们将 4 号缓冲区设置为单通道 16 位浮点 <span id="puq0wh_102"><sup class="superscript"><span class="control" id="puq0wh_103">1</span></sup></span> 来避免过渡断层，并依照上文的方法调用：</p><div class="code-block" data-lang="glsl">
[... Settings ...]
/*
const int colortex4Format = R16F;
*/
[... gbuffers_entities_glowing ...]
layout(r16f) uniform image2D colorimg4;
</div><p id="puq0wh_76">当然，你也可以将 3 号缓冲区的格式改为双通道，并将发光数据存入其中，但同时也需要处理先前的整型几何 ID，将它们转换为浮点值（习题 1）。</p><aside class="prompt" data-type="tip" data-title="" id="puq0wh_77"><p id="puq0wh_104">由于只能将 0 ~ 5 号缓冲区以图像格式读取，而几何缓冲又无法按常规方法读取 0 ~ 3 号缓冲区，可以在任何阶段以任何方式读写的颜色缓冲区实际上只有 4 号和 5 号，计算着色器还会更加放大这个问题。</p><p id="puq0wh_105">因此在几何缓冲阶段，如果只是要使用之前的屏幕缓冲区数据，则推荐把这些数据存入 5 号之后的缓冲区；而延迟处理阶段中，也最好将 4、5 号缓冲区特意留出。</p><p id="puq0wh_106">而在 Iris 中，我们可以自定义至多 16 个额外的图像，不仅可以自定义其尺寸，还能在任何程序中访问。</p></aside><p id="puq0wh_78">我们可以使用函数 <code class="code" id="puq0wh_107">imageLoad(gimage image, ivec coord)</code> 来读取图像区域内任意坐标的内容，和 <code class="code" id="puq0wh_108">texelFetch()</code> 类似，它使用索引坐标，唯一的区别是图像不可以指定细节等级，此外，也可以使用 <code class="code" id="puq0wh_109">imageSize()</code> 函数来取到图像的尺寸，它直接返回整型值。</p><p id="puq0wh_79">同样的，使用 <code class="code" id="puq0wh_110">imageStore(gimage image, ivec coord, gvec4 data)</code> 来写入任意位置。无论几通道，第三项 <code class="code" id="puq0wh_111">data</code> 均为四元数，由 GLSL 自动裁切。</p><p id="puq0wh_80">在实际写入之前，还需要注意的是，它不会进行任何深度测试和 Alpha 测试（或者说自动深度测试已经是程序结束之后了），所以如果你想要描边完美贴合实体，应当在 Alpha 测试的 <code class="code" id="puq0wh_112">discard</code> 之后才调用写入函数。由于没有上下文级别的深度测试，在同一个着色器中对多个重叠三角的同二维位置片段写入会导致写入竞争，从而产生块状闪烁，但是我们这里写入的都是与位置无关的常量，因此就无所谓了。</p><p id="puq0wh_81"><code class="code" id="puq0wh_113">discard</code> 指令在图像写入与片段着色器的普通输出之间有些许差别。如果触发了 <code class="code" id="puq0wh_114">discard</code> 指令，像素着色器的普通输出会停止并丢弃当前像素的任何东西；而图像写入则只会在当前位置停下，而不影响先前写入的内容。</p><div class="code-comparer" id="puq0wh_82" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="向图像写入">
vec4 color = vec4(1.0);
bool cond = doSth();

imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // 正常写入
if(cond) discard;
color = vec4(0.0);
imageStore(colorimg1, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
</div><div class="code-block" data-lang="glsl" data-title="像素着色器输出">
vec4 color = vec4(1.0);
bool cond = doSth();

fragColor0 = color; // if()为假，写入；if()为真，无效
if(cond) discard;
color = vec4(0.0);
fragColor1 = color; // if()为假，写入；if()为真，无效
</div></div><p id="puq0wh_83">要想用普通输出达到图像写入的功能，可以使用反转条件：</p><div class="code-block" data-lang="glsl">
fragColor0 = color; // 正常写入
if(!cond) {
    color = vec4(0.0);
    fragColor1 = color; // if()为真，写入；if()为假，无效
}
</div><p id="puq0wh_85">要想用图像写入达到普通输出功能，可以延后图像写入到条件判定之后：</p><div class="code-block" data-lang="glsl">
if(cond) discard;
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
color = vec4(0.0);
imageStore(colorimg1, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
</div><p id="puq0wh_87">最后，我们的 <code class="code" id="puq0wh_117">gbuffers_entities_glowing.glsl</code> 就长这样了：</p><div class="code-block" data-lang="glsl">
[... 片段着色器部分 ...]
#extension GL_ARB_shader_image_load_store : enable
[...]
layout(r16f) uniform image2D colorimg4;
[... main ...]
[...]
if(fragColor.a &lt;= alphaTestRef) discard; // 先进行 Alpha 测试！
imageStore(colorimg4, ivec2(gl_FragCoord.xy), vec4(1.0));
[...]
</div><p id="puq0wh_89">如果直接读取发光实体缓冲，看起来就像这样：</p><figure id="puq0wh_90"><img alt="发光实体缓冲区" src="MGC_Docs/glowingEntities_glowingBuffer.webp" title="发光实体缓冲区" width="700" height="394"></figure><aside class="prompt" data-type="tip" data-title="" id="puq0wh_91"><p id="puq0wh_118">除此之外，图像类型还可以进行原子操作，即当不同着色器程序向同一张图像的同一个位置写入相同数据时，会严格按照程序的执行顺序进行处理，不会出现次序问题。</p><p id="puq0wh_119">可以用于原子操作的图像格式有严格的限制，只可以是 <code class="code" id="puq0wh_124">R32I/r32i</code> 或 <code class="code" id="puq0wh_125">R32UI/r32ui</code> ，但是通过格式转换是可以在其他格式上使用的，例如将一个 <code class="code" id="puq0wh_126">RGBA8I</code> （4x8=32位）声明为 <code class="code" id="puq0wh_127">R32I</code> （1x32=32位），不过这就需要手动进行移位来处理具体内容了。</p><p id="puq0wh_120">所有原子操作返回的值都是图像位置上的原始值，下列的 <code class="code" id="puq0wh_128"><em id="puq0wh_133">g</em>int</code> 中的 <span class="emphasis" id="puq0wh_129"><code class="code" id="puq0wh_134">g</code></span> 指的是 <code class="code" id="puq0wh_130">int</code> 或 <code class="code" id="puq0wh_131">uint</code>。 <code class="code" id="puq0wh_132">IMAGE_COORDS</code> 表示正在处理的图像的像素坐标。</p><ul class="list _bullet" id="puq0wh_121"><li class="list__item" id="puq0wh_135"><p id="puq0wh_140">原子赋值，由于它们会返回原值，所以也可用作交换： <br><code class="code" id="puq0wh_142">gint imageAtomicExchange(gimage image, IMAGE_COORDS, gint data)</code></p></li><li class="list__item" id="puq0wh_136"><p id="puq0wh_143">原子条件赋值，仅当图像目标值等于条件值时赋值： <br><code class="code" id="puq0wh_145">gint imageAtomicCompSwap(gimage image, IMAGE_COORDS, gint compare, gint data)</code></p></li><li class="list__item" id="puq0wh_137"><p id="puq0wh_146">原子算术，GLSL 仅提供加法，但是你可以在<span class="control" id="puq0wh_147">有符号整数运算</span>中为 <code class="code" id="puq0wh_148">data</code> 添加负号来进行减法运算： <br><code class="code" id="puq0wh_150">gint imageAtomicAdd(gimage image, IMAGE_COORDS, gint data)</code><br> 自 GLSL 4.30 起，你也可以在无符号整数中进行这种计算，只需要写作 <code class="code" id="puq0wh_152">imageAtomicAdd(..., uint(-data))</code> 。当然，你得保证最终的值不会为负而溢出。</p></li><li class="list__item" id="puq0wh_138"><p id="puq0wh_153">原子位运算，可以进行与、或和异或运算： <br><code class="code" id="puq0wh_155">gint imageAtomicAnd(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="puq0wh_157">gint imageAtomicOr(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="puq0wh_159">gint imageAtomicXor(gimage image, IMAGE_COORDS, gint data)</code></p></li><li class="list__item" id="puq0wh_139"><p id="puq0wh_160">原子大小值，可以取最大值和最小值： <br><code class="code" id="puq0wh_162">gint imageAtomicMin(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="puq0wh_164">gint imageAtomicMax(gimage image, IMAGE_COORDS, gint data)</code></p></li></ul><p id="puq0wh_122">你也可以使用 <code class="code" id="puq0wh_165">memoryBarrier()</code> 来手动设置内存屏障。</p><p id="puq0wh_123">资料来源： <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store" id="puq0wh_166" data-external="true" rel="noopener noreferrer" target="_blank">Image Load Store - OpenGL Wiki</a> ，此处仅作扩展阅读，留由读者自行研究。</p></aside></section></section><section class="chapter"><h2 id="puq0wh_6" data-toc="puq0wh_6">描边与原版实现</h2><p id="puq0wh_167">现在我们已经获得了发光实体的遮罩数据，如果单纯地想给覆盖区域外围加上一圈描边，我们只需要在延迟处理中简单地检查非发光像素邻近的四个（或加上对角线共八个）像素即可是否与之状态有别即可。当搜索到任何一个邻近像素是发光区域时，就给当前像素上色，类似这样：</p><div class="code-block" data-lang="glsl">
[... Uniforms ...]
uniform isampler2D colortex4;
[... final - main ...]
bool isGlowing = bool(texture(colortex4, uv).r);
bool isGlowingEdge = false;
if(!isGlowing) {
    for(int i = -1; i &lt; 2; i+=2) {
        ivec2 sCoord = ivec2(gl_FragCoord.xy) + ivec2(i,0);
        isGlowingEdge = bool(texelFetch(colortex4, sCoord, 0).r);
        if(isGlowingEdge) break;
    }
    for(int i = -1; i &lt; 2 &amp;&amp; !isGlowingEdge; i+=2) {
        ivec2 sCoord = ivec2(gl_FragCoord.xy) + ivec2(0,i);
        isGlowingEdge = bool(texelFetch(colortex4, sCoord, 0).r);
        if(isGlowingEdge) break;
    }
}
if(isGlowingEdge) fragColor = vec4(1.0);
</div><p id="puq0wh_169">至此，我们就已经初步成功给发光实体描上边了，值得注意的是，上一章中，我们将发光实体暂时设定为了无光照类：</p><figure id="puq0wh_170"><img alt="发光实体描边" src="MGC_Docs/glowingEntities_glowingEdge.webp" title="发光实体描边" width="700" height="394"></figure><p id="puq0wh_171">当然，这个发光描边效果仍然很粗糙，只有 1 像素，分辨率高一些就会变得极不明显，所以让我们来拆解原版的发光描边着色器。</p><p id="puq0wh_172">原版的描边使用了两个延迟处理 Pass，第一个 Pass <code class="code" id="puq0wh_179">entity_outline_box_blur</code> 使用方框模糊处理了发光区域的数据，并保留累积的 Alpha 值（不取采样均值）以在模糊边缘形成断层，从而形成渐变过渡，并间接确定了描边宽度：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="false" data-synopsis="entity_outline_box_blur.fsh">
#version 150

uniform sampler2D InSampler;

in vec2 texCoord;
in vec2 sampleStep;

out vec4 fragColor;

void main() {
    vec4 blurred = vec4(0.0);
    float radius = 2.0;
    for (float a = -radius + 0.5; a &lt;= radius; a += 2.0) {
        blurred += texture(InSampler, texCoord + sampleStep * a);
    }
    blurred += texture(InSampler, texCoord + sampleStep * radius) / 2.0;
    fragColor = vec4((blurred / (radius + 0.5)).rgb, blurred.a);
}
</div><p id="puq0wh_174">这个着色器利用 <code class="code" id="puq0wh_180">texture()</code> 的插值性在纹理的四个像素交界处进行两次采样，然后再单独在采样方向上的最外侧进行一次采样，从而快速获得半径内的平均色，最后再除以采样半径 <span id="puq0wh_181"><sup class="superscript"><span class="control" id="puq0wh_182">1</span></sup></span> 。由于原版的发光效果是纯白色，RGB 通道和 Alpha 通道的数据只有是否除以半径的区别。</p><p id="puq0wh_175">第二个 Pass <code class="code" id="puq0wh_183">entity_outline</code> <span id="puq0wh_184"><sup class="superscript"><span class="control" id="puq0wh_185">2</span></sup></span> 则用于再次混合邻近的四个像素并比较 Alpha 的总差异来确认颜色和混合比例：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="false" data-synopsis="entity_sobel.fsh">
#version 150

uniform sampler2D InSampler;

in vec2 texCoord;
in vec2 oneTexel;

out vec4 fragColor;

void main(){
    vec4 center = texture(InSampler, texCoord);
    vec4 left = texture(InSampler, texCoord - vec2(oneTexel.x, 0.0));
    vec4 right = texture(InSampler, texCoord + vec2(oneTexel.x, 0.0));
    vec4 up = texture(InSampler, texCoord - vec2(0.0, oneTexel.y));
    vec4 down = texture(InSampler, texCoord + vec2(0.0, oneTexel.y));
    float leftDiff  = abs(center.a - left.a);
    float rightDiff = abs(center.a - right.a);
    float upDiff    = abs(center.a - up.a);
    float downDiff  = abs(center.a - down.a);
    float total = clamp(leftDiff + rightDiff + upDiff + downDiff, 0.0, 1.0);
    vec3 outColor = center.rgb * center.a + left.rgb * left.a + right.rgb * right.a + up.rgb * up.a + down.rgb * down.a;
    fragColor = vec4(outColor * 0.2, total);
}
</div><p id="puq0wh_177">事实上，这个着色器中只有作为 Alpha 的 <code class="code" id="puq0wh_186">total</code> 会起作用， <code class="code" id="puq0wh_187">outColor</code> 虽然进行了写入，却并没有影响和修改最终的颜色。由于第一个 Pass 进行了数据模糊，所以发光和非发光相接的区域就会产生 Alpha 值过渡。当我们使用与邻近像素的 Alpha 差值和作为绘制依据时，远离交界区域的 Alpha 值始终为 0 或均匀累积值（数值上与模糊半径相等），Alpha 差值也就为 0，而交界区域与附近的 Alpha 值一直在变化，自然就会产生 Alpha 差值条带。</p><p id="puq0wh_178"><span class="control" id="puq0wh_188">[1]</span> 因为之前的采样都是两两像素的平均色，最后一次采样又手动减半，因此采样出来的颜色总和实际上只有一半，所以最后除数就不必为像素数量总和了。 <br><span class="control" id="puq0wh_190">[2]</span> 原版允许使用 JSON 文件自定义使用的顶点着色器和片段着色器，因此会出现 Pass 名称和着色器名称对不上的情况。比如描边模糊 Pass 的顶点着色器 <code class="code" id="puq0wh_191">blur.vsh</code> 也被用于了打开菜单后的背景模糊。</p></section><section class="chapter"><h2 id="puq0wh_7" data-toc="puq0wh_7">多程序处理</h2><p id="puq0wh_192">之前的编程中，我们的延迟处理程序都集中在管线的最末端，即 <code class="code" id="puq0wh_210">final</code> 中。而描边着色器要求将场景完全模糊之后再来检查，也就是说，如果我们想在同一个着色器中完成这些事情，需要将四周邻近的像素都进行模糊处理然后再来比较。然而普通的片段着色器中，这些数据是无法共享的，也就是说周围的像素在它们各自的片段着色器中也会这样干，最终就会造成四倍的模糊开销，这是极其不划算的。自然而然的，我们就会做出像原版那样的事情：先在一个 Pass 中进行图像模糊，再在下一个 Pass 中处理描边。</p><p id="puq0wh_193">OptiFine 为我们提供了高度可自定义的延迟处理程序数量。回顾一下，我们可以用的延迟处理主要集中在两个阶段：固体几何缓冲之后的 Deferred 和余下几何缓冲之后的 Composite 。由于模糊着色器只处理发光遮罩缓冲区，因此程序的选择没什么所谓，这里我们就选择更靠近 Final 的 Composite 了。</p><p id="puq0wh_194">原版的模糊着色器看起来会很奇怪，它似乎只在某个方向（<code class="code" id="puq0wh_211">sampleStep</code> ）上处理了模糊，当然，实际上是它在不同方向上运行了两次。为了平衡性能和质量，我们也会效仿原版，将模糊也分为两个 Pass，先将其进行水平模糊，再进行垂直模糊。最终，我们的模糊就在 <code class="code" id="puq0wh_212">composite</code> 和 <code class="code" id="puq0wh_213">composite1</code> 中进行，而描边则接在 <code class="code" id="puq0wh_214">final</code> 中场景绘制完毕之后。</p><p id="puq0wh_195">没有特别的要求的话，所有延迟处理的顶点着色器都一样，因此你可以直接复制 <code class="code" id="puq0wh_215">final.vsh</code> 并更名。</p><p id="puq0wh_196">参考原版着色器，它使用了方框模糊（Box Blur）将周围的数据进行平均，我们也将仿照它的方法和技巧，进行 5x5 的模糊处理，并将半径设计为可调整。</p><p id="puq0wh_197">其他的常规声明与 Final 一样，在这个着色器中，我们只需要向发光数据中写入内容，因此渲染目标只有 4 号缓冲区：</p><div class="code-block" data-lang="glsl">
/* DRAWBUFFERS:4 */
layout(location = 0) out float blurredGlowingBuffer;
</div><p id="puq0wh_199"><code class="code" id="puq0wh_216">main</code> 函数的内容和原版着色器很相似，只不过我们可以把模糊半径塞入 <code class="code" id="puq0wh_217">Settings.glsl</code> 中，以便间接控制发光描边宽度。水平模糊的着色器看起来就像这样：</p><div class="code-block" data-lang="glsl">
blurredGlowingBuffer = 0.0;
vec2 sampleDir = vec2(pixelSize.x, 0.0);
for(float i = -GLOWING_BLUR_RADIUS + .5; i &lt;= GLOWING_BLUR_RADIUS; i += 2.0) {
    blurredGlowingBuffer += texture(colortex4, uv + sampleDir * i).r;
}
blurredGlowingBuffer += texture(colortex4, uv + sampleDir * GLOWING_BLUR_RADIUS).r * .5;
</div><p id="puq0wh_201">竖直方向的模糊只需要将 <code class="code" id="puq0wh_218">sampleDir</code> 的 <code class="code" id="puq0wh_219">vec2(pixelSize.x, 0.0)</code> 替换为 <code class="code" id="puq0wh_220">vec2(0.0, pixelSize.y)</code> 即可。</p><p id="puq0wh_202">你可能注意到了，我们这里没有除以模糊半径，因为原版描边着色器中 Alpha 通道用得比较多。如果我们提早进行了除法，那么在描边着色器中需要使用 <code class="code" id="puq0wh_221">min(c * (GLOWING_BLUR_RADIUS + 0.5), 1.0)</code> 来进行手动复原和截断。由于涉及到原版 Alpha 通道的部分都会包含不可应用分配律的 <code class="code" id="puq0wh_222">min()</code> 函数，因此会有很多次 <code class="code" id="puq0wh_223">min(a * x,b)</code> ，那我们何不延后原版 RGB 通道的除法变成 <code class="code" id="puq0wh_224">min(x,b)</code> 减少乘法次数呢？</p><aside class="prompt" data-type="note" data-title="" id="puq0wh_203"><p id="puq0wh_225">这种描边本质上是轮廓两侧扩散，因为模糊时没有进行判定。如果你想要外侧描边，可以在模糊时仅模糊没有发光区域的部分。同样的，如果你想要内侧描边，可以仅模糊发光的区域。</p></aside><p id="puq0wh_204">回到 Final 中，将原版的方法封装成函数原样搬入，只是不再关心 RGB 的值，然后将其他统一变量对齐即可：</p><div class="code-block" data-lang="glsl">
float getGlowingEdge() {
    float center = texture(colortex4, uv).r;
    float left = texture(colortex4, uv - vec2(pixelSize.x, 0.0)).r;
    float right = texture(colortex4, uv + vec2(pixelSize.x, 0.0)).r;
    float up = texture(colortex4, uv - vec2(0.0, pixelSize.y)).r;
    float down = texture(colortex4, uv + vec2(0.0, pixelSize.y)).r;
    float leftDiff  = abs(center - left);
    float rightDiff = abs(center - right);
    float upDiff    = abs(center - up);
    float downDiff  = abs(center - down);
    float total = clamp(leftDiff + rightDiff + upDiff + downDiff, 0.0, 1.0);
    return total;
}
</div><p id="puq0wh_206">就像之前我们说的那样，原版的描边着色器仅用来判定描边边界，因此我们略去了所有与 RGB 相关的计算。最后，将 Final 中之前的颜色与之相混合，就可以绘制出发光描边了：</p><div class="code-block" data-lang="glsl">
const float div = (GLOWING_BLUR_RADIUS+.5)*(GLOWING_BLUR_RADIUS+.5);
float glowingEdge = getGlowingEdge();
float glowingColor = texture(colortex4, uv).r / div;
fragColor.rgb = mix(fragColor.rgb, vec3(glowingColor), glowingEdge);
</div><p id="puq0wh_208">当然，你也可以自定义发光描边的颜色。最后来看看大模糊半径下，将混合颜色使用三角函数和 <a href="a01-uniformsandats.html#uniforms" id="puq0wh_226" data-tooltip=""><code class="code" id="puq0wh_227">frameTimeCounter</code></a> 处理以呈现的动态彩虹发光描边！</p><figure data-theme="light" id="puq0wh_209" width="700"><img alt="彩虹描边" class="js-gif article__bordered-element" data-gif-src="MGC_Docs/glowingEntities_RAINBOW.gif" width="700" style="width: 700px;"></figure></section><section class="chapter"><h2 id="puq0wh_8" data-toc="puq0wh_8">习题</h2><ol class="list _decimal" id="puq0wh_228" type="1"><li class="list__item" id="puq0wh_229"><p id="puq0wh_235">（与习题 2 二选一）将 4 号缓冲区的内容合并入 3 号缓冲区中。之后，你可以先使用 <code class="code" id="puq0wh_236">imageLoad(colorimg3, COORD).r</code> 取出已经写入的几何 ID，然后手动进行深度测试来决定保留几何 ID 的源内容还是覆写新内容（当前片段深度小于深度图上已有的深度时，说明发光实体本身也在前景，因此要覆写几何 ID），最后使用 <code class="code" id="puq0wh_237">imageStore(colorimg3, COORD, vec4(geometryID, 1.0, vec2(0.0)))</code> 覆写图像内容并确保 G 通道为 1.0 即可。随后的模糊 Pass 只需要将 Red 通道中的内容原样输出即可。</p></li><li class="list__item" id="puq0wh_230"><p id="puq0wh_238">（与习题 1 二选一）将 4 号缓冲区改为四通道，并在几何缓冲存入数据时写入纹理颜色，这在一定程度上可以根据实体的纹理颜色产生描边颜色。虽然会因为写入竞争而产生块状闪烁，但是描边区域是基本上稳定的。你可以将写入的 Alpha 值固定为 1 来消除内部的闪烁。</p></li><li class="list__item" id="puq0wh_231"><p id="puq0wh_239">尝试编写一个本节末尾处的彩虹描边效果。可以直接定义一个三维向量，每个通道都利用三角函数将 <code class="code" id="puq0wh_240">glowingColor</code> 加上 <code class="code" id="puq0wh_241">frameTimeCounter</code> 作为参数来周期性地改变颜色；然后配置文件中按统一变量的方法定义常量 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.29ex" height="1ex" role="img" focusable="false" viewBox="0 -431 570 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g></svg></mjx-container> ，将其添加入 <code class="code" id="puq0wh_243">Uniforms.glsl</code> ，加入三角函数中用以给每个颜色分量不同的相位偏移（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="1.907ex" height="2.397ex" role="img" focusable="false" viewBox="0 -698.8 843.1 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g><g data-mml-node="mn" transform="translate(244.7,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><rect width="603.1" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>、 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="2.707ex" height="2.773ex" role="img" focusable="false" viewBox="0 -864.9 1196.6 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,394) scale(0.707)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g><g data-mml-node="mn" transform="translate(421.5,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><rect width="956.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container> ）。为了防止颜色溢出到负值，你可以将结果进行平方；如果你想要更加平缓的边缘，可以给颜色额外乘上 <code class="code" id="puq0wh_246">glowingColor</code> 或将其乘入混合参考。</p></li><li class="list__item" id="puq0wh_232"><p id="puq0wh_247">如果你同时完成了习题 2 和 3，可以把宏开关合并成 <code class="code" id="puq0wh_248">#define GLOWING_EFFECT 0 // [0 1 2]</code> ，每个数字代表一个描边上色模式。</p></li><li class="list__item" id="puq0wh_233"><p id="puq0wh_249">在混合比例中乘入 <code class="code" id="puq0wh_251">float(geoID != geoID_enum.glowing_entities)</code> 可以避免发光实体本身被描边遮挡，将其设置为宏开关是个不错的选择。</p><ul class="list _bullet" id="puq0wh_250"><li class="list__item" id="puq0wh_252"><p id="puq0wh_253">如果你觉得描边变得太淡，那是因为模糊总是从边框开始双向延伸，因此最终向外蔓延的值总是小于 0.5，因此你可以将描边颜色乘 2。</p></li></ul></li><li class="list__item" id="puq0wh_234"><p id="puq0wh_254">利用自定义统一变量，将 <a href="a03-shaderprop.html#cam_bool" id="puq0wh_257" data-tooltip="摄像机所在实体的状态，例如玩家本身或旁观模式附身的实体。">摄像机参数</a> <code class="code" id="puq0wh_258">is_glowing</code> 传入</p><div class="code-block" data-lang="properties">
uniform.bool.cam_isGlowing = is_glowing
</div><p id="puq0wh_256">然后在 <code class="code" id="puq0wh_259">gbuffers_hand.glsl</code> 中使用 <code class="code" id="puq0wh_260">if(cam_isGlowing)</code> 来向发光缓冲区进行图像写入，这样就可以在玩家发光时让手部和持有物也发光了。</p></li></ol></section><div class="last-modified">18 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="2-1-solidgeometries.html" class="navigation-links__prev">固体几何缓冲</a><a href="2-3-1-advancedlighting.html" class="navigation-links__next">进阶延迟处理：光照</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
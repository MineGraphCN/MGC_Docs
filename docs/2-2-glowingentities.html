<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-30T09:18:12.903945864"><title>发光实体再处理 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"-sd71oj_6","level":0,"title":"图像读写","anchor":"#-sd71oj_6"},{"id":"-sd71oj_15","level":1,"title":"声明扩展","anchor":"#-sd71oj_15"},{"id":"-sd71oj_16","level":1,"title":"使用图像类型","anchor":"#-sd71oj_16"},{"id":"-sd71oj_7","level":0,"title":"描边与原版实现","anchor":"#-sd71oj_7"},{"id":"-sd71oj_8","level":0,"title":"多程序处理","anchor":"#-sd71oj_8"},{"id":"-sd71oj_9","level":0,"title":"习题","anchor":"#-sd71oj_9"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="发光实体再处理 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/2-2-glowingentities.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="发光实体再处理 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/2-2-glowingentities.html#webpage",
    "url": "https://docs.minegraph.cn/md/2-2-glowingentities.html",
    "name": "发光实体再处理 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="2-2-glowingEntities" data-main-title="发光实体再处理" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="创作者文档///shaderTutorial.md|光影开发教程///我们需要再深入一些"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="2-2-glowingEntities" data-annotation-ids="wip" id="2-2-glowingEntities.md">发光实体再处理</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-sd71oj_10\&quot;\u003e在上一节中，我们将第一轮中所有的几何缓冲程序都进行了初步处理，它们现在都会在场景中正确绘制，除了来捣乱的隐身实体和这一节我们将会处理的发光实体。\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;-sd71oj_11\&quot;\u003e这一节我们将会进一步处理发光实体的专用着色器，让它在屏幕上绘制出正确的轮廓，并且不会被遮挡。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="-sd71oj_6" data-toc="-sd71oj_6">图像读写</h2><p id="-sd71oj_12">还记得原版的发光实体吗？在生存模式中，当实体被光灵箭命中就会附加上发光效果。此时在其他玩家眼中，只要实体在渲染距离之内， <span class="control" id="-sd71oj_17">无论是否被其他物体遮挡</span> ，它们都会有一层厚厚的描边。</p><figure id="-sd71oj_13"><img alt="原版发光实体" src="MGC_Docs/glowingEntities_vanilla.webp" title="原版发光实体" width="700" height="394"></figure><p id="-sd71oj_14">在之前的片段着色器中，我们一直使用片段着色器常规的输出方式，在全局空间声明 <code class="code" id="-sd71oj_18">out</code> 变量，然后绘制到每个像素。不幸的是，在 OptiFine 的设置中，这些片段着色器都会主动进行深度测试，一旦被其他物体遮挡，几何体就不会被绘制，而且这个功能无法取消。幸运的是，GL 还有一种写入缓冲区的方案，而这个方案最初由英伟达作为扩展添加，并在 GLSL 4.20 转正为内置特性。</p><section class="chapter"><h3 id="-sd71oj_15" data-toc="-sd71oj_15">声明扩展</h3><p id="-sd71oj_19">由于我们所声明的 GLSL 版本较低，因此需要使用 <code class="code" id="-sd71oj_28">#extension</code> 指令来调用扩展：</p><div class="code-block" data-lang="glsl">
#extension GL_ARB_shader_image_load_store : enable
</div><p id="-sd71oj_21">宏命令 <code class="code" id="-sd71oj_29">#extension</code> 我们都知道了，它紧接是扩展名。扩展名的命名规律为：</p><ol class="list _decimal" id="-sd71oj_22" type="1"><li class="list__item" id="-sd71oj_30"><p id="-sd71oj_33">以现代规范要求的 <code class="code" id="-sd71oj_34">GL</code> 前缀开头；</p></li><li class="list__item" id="-sd71oj_31"><p id="-sd71oj_35">扩展的 <a href="https://www.khronos.org/opengl/wiki/OpenGL_Extension#Extension_Types" id="-sd71oj_36" data-external="true" rel="noopener noreferrer" target="_blank">类型</a>， <code class="code" id="-sd71oj_37">ARB</code> 表示获得了 OpenGL ARB 协会批准的正式扩展，类似的还有 <code class="code" id="-sd71oj_38">EXT</code> 表示泛用的扩展，但是可能部分硬件厂商未予以实现；</p></li><li class="list__item" id="-sd71oj_32"><p id="-sd71oj_39">扩展的具体名称。</p></li></ol><p id="-sd71oj_23">如果扩展名使用 <code class="code" id="-sd71oj_40">all</code> ，则会启用所有支持的扩展。</p><p id="-sd71oj_24">声明了扩展之后，我们还需要指定扩展的行为，在扩展名称后接 <code class="code" id="-sd71oj_41">:</code> 即可进行定义。扩展的行为可以为 <code class="code" id="-sd71oj_42">require</code>、 <code class="code" id="-sd71oj_43">enable</code>、 <code class="code" id="-sd71oj_44">warn</code> 和 <code class="code" id="-sd71oj_45">disable</code> ，它们的具体行为由下表决定：</p><div class="table-wrapper"><table class="wide" id="-sd71oj_25" width="700"><thead><tr class="ijRowHead" id="-sd71oj_46"><th id="-sd71oj_51"><p>行为</p></th><th id="-sd71oj_52"><p>声明扩展</p></th><th id="-sd71oj_53"><p>硬件不支持且使用扩展语法时</p></th></tr></thead><tbody><tr id="-sd71oj_47"><td id="-sd71oj_54"><p><code class="code" id="-sd71oj_56">require</code></p></td><td id="-sd71oj_55" colspan="2"><p>强制启用，不支持即报错</p></td></tr><tr id="-sd71oj_48"><td id="-sd71oj_57"><p><code class="code" id="-sd71oj_60">enable</code></p></td><td id="-sd71oj_58"><p>通过编译</p></td><td id="-sd71oj_59"><p>报错并中止（失败）</p></td></tr><tr id="-sd71oj_49"><td id="-sd71oj_61"><p><code class="code" id="-sd71oj_64">warn</code></p></td><td id="-sd71oj_62"><p>通过编译</p></td><td id="-sd71oj_63"><p>警告并继续（通过 <sup class="superscript" id="-sd71oj_65"><b id="-sd71oj_66">1</b></sup>）</p></td></tr><tr id="-sd71oj_50"><td id="-sd71oj_67"><p><code class="code" id="-sd71oj_69">disable</code></p></td><td id="-sd71oj_68" colspan="2"><p>强制禁用，使用即报错</p></td></tr></tbody></table></div><p id="-sd71oj_26">除了 <code class="code" id="-sd71oj_70">require</code> ，如果着色器的实际代码中没有使用任何扩展的内容或语法，则不会报错。</p><p id="-sd71oj_27"><span class="control" id="-sd71oj_71">[1]</span> 如果在不支持的硬件上使用了 <code class="code" id="-sd71oj_72">warn</code> 行为的扩展，就算通过了编译，最后的程序也会出现未定义行为。由于我们有插件进行报错，这个行为基本不会用到。</p></section><section class="chapter"><h3 id="-sd71oj_16" data-toc="-sd71oj_16">使用图像类型</h3><p id="-sd71oj_73">和纹理类似，在着色器程序的全局空间使用 <code class="code" id="-sd71oj_93">uniform</code> 关键字即可声明图像类型 <code class="code" id="-sd71oj_94"><em id="-sd71oj_100">g</em>image</code> ，我们可以在任何着色器中访问 0 ~ 5 号颜色缓冲区和两个阴影颜色缓冲区，只需要把它们的后缀从 <code class="code" id="-sd71oj_95">tex</code> 改为 <code class="code" id="-sd71oj_96">img</code> （<code class="code" id="-sd71oj_97">shadowcolor</code> 同样加上 <code class="code" id="-sd71oj_98">img</code> 后缀）。有一点不同的是，我们需要在之前使用 <code class="code" id="-sd71oj_99">layout()</code> 指定图像的格式。</p><p id="-sd71oj_74">上一节，我们将几何 ID 保存在了单通道8位无符号整数的 3 号缓冲区中，并且已经为发光实体保存了独特的 ID，但是这个 ID 实际只能用于为显露的发光实体处理额外特效。由于发光实体的描边特效仅描边外轮廓，而几何 ID 则覆盖了几何的内部，当发光实体被其他几何遮挡而强行写入时，延迟处理中的几何 ID 就会产生误判。</p><p id="-sd71oj_75">因此，我们将会启用 4 号缓冲区，用以保存发光实体需要绘制的轮廓依据。在原版中虽然在写入原始数据时只有 <code class="code" id="-sd71oj_101">1</code> （发光区域） 和 <code class="code" id="-sd71oj_102">0</code> （非发光区域），但是后续进行模糊扩散处理要求插值过渡和独立处理描边的不透明度，不过实际上也只需要一个数据，之后你就会知道。为此，我们将 4 号缓冲区设置为单通道 16 位浮点来避免过渡断层，并依照上文的方法调用：</p><div class="code-block" data-lang="glsl">
[... Settings ...]
/*
const int colortex4Format = R16F;
*/
[... gbuffers_entities_glowing ...]
layout(r16f) uniform image2D colorimg4;
</div><p id="-sd71oj_77">当然，你也可以将 3 号缓冲区的格式改为三通道，并将发光数据存入其中，但同时也需要处理先前的整型几何 ID，将它们转换为浮点值（习题 1）。</p><aside class="prompt" data-type="tip" data-title="" id="-sd71oj_78"><p id="-sd71oj_103">由于只能将 0 ~ 5 号缓冲区以图像格式读取，而几何缓冲又无法按常规方法读取 0 ~ 3 号缓冲区，可以在任何阶段以任何方式读写的颜色缓冲区实际上只有 4 号和 5 号，计算着色器还会更加放大这个问题。</p><p id="-sd71oj_104">因此在几何缓冲阶段，如果只是要使用之前的屏幕缓冲区数据，则推荐把这些数据存入 5 号之后的缓冲区；而延迟处理阶段中，也最好将 4、5 号缓冲区特意留出。</p></aside><p id="-sd71oj_79">我们可以使用函数 <code class="code" id="-sd71oj_105">imageLoad(gimage image, ivec coord)</code> 来读取图像区域内任意坐标的内容，和 <code class="code" id="-sd71oj_106">texelFetch()</code> 类似，它使用索引坐标，唯一的区别是图像不可以指定细节等级，此外，也可以使用 <code class="code" id="-sd71oj_107">imageSize()</code> 函数来取到图像的尺寸，它直接返回整型值。</p><p id="-sd71oj_80">同样的，使用 <code class="code" id="-sd71oj_108">imageStore(gimage image, ivec coord, gvec4 data)</code> 来写入任意位置。无论几通道，第三项 <code class="code" id="-sd71oj_109">data</code> 均为四元数，由 GLSL 自动裁切。</p><p id="-sd71oj_81">在实际写入之前，还需要注意的是，它不会进行任何深度测试和 Alpha 测试（或者说自动深度测试已经是程序结束之后了），所以如果你想要描边完美贴合实体，应当在 Alpha 测试的 <code class="code" id="-sd71oj_110">discard</code> 之后才调用写入函数。</p><p id="-sd71oj_82"><code class="code" id="-sd71oj_111">discard</code> 指令在图像写入与片段着色器的普通输出之间有些许差别。如果触发了 <code class="code" id="-sd71oj_112">discard</code> 指令，像素着色器的普通输出会停止并丢弃当前像素的任何东西；而图像写入则只会在当前位置停下，而不影响先前写入的内容。</p><div class="code-comparer" id="-sd71oj_83" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="向图像写入">
vec4 color = vec4(1.0);
bool cond = doSth();

imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // 正常写入
if(cond) discard;
color = vec4(0.0);
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
</div><div class="code-block" data-lang="glsl" data-title="像素着色器输出">
vec4 color = vec4(1.0);
bool cond = doSth();

fragColor = color; // if()为假，写入；if()为真，无效
if(cond) discard;
color = vec4(0.0);
fragColor = color; // if()为假，写入；if()为真，无效
</div></div><p id="-sd71oj_84">要想用普通输出达到图像写入的功能，可以使用反转条件：</p><div class="code-block" data-lang="glsl">
fragColor = color; // 正常写入
if(!cond) {
    color = vec4(0.0);
    fragColor = color; // if()为真，写入；if()为假，无效
}
</div><p id="-sd71oj_86">要想用图像写入达到普通输出功能，可以延后图像写入到条件判定之后（虽然在我们这个例子中看起来有点神经&hellip;&hellip;）：</p><div class="code-block" data-lang="glsl">
if(cond) discard;
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
color = vec4(0.0);
imageStore(colorimg0, ivec2(gl_FragCoord.xy), color); // if()为假，写入；if()为真，无效
</div><p id="-sd71oj_88">最后，我们的 <code class="code" id="-sd71oj_115">gbuffers_entities_glowing.glsl</code> 就长这样了：</p><div class="code-block" data-lang="glsl">
[... 片段着色器部分 ...]
#extension GL_ARB_shader_image_load_store : enable
[...]
layout(r16f) uniform image2D colorimg4;
[... main ...]
[...]
if(fragColor.a &lt;= alphaTestRef) discard; // 先进行 Alpha 测试！
imageStore(colorimg4, ivec2(gl_FragCoord.xy), vec4(1.0));
[...]
</div><p id="-sd71oj_90">如果直接读取发光实体缓冲，看起来就像这样：</p><figure id="-sd71oj_91"><img alt="发光实体缓冲区" src="MGC_Docs/glowingEntities_glowingBuffer.webp" title="发光实体缓冲区" width="700" height="394"></figure><aside class="prompt" data-type="tip" data-title="" id="-sd71oj_92"><p id="-sd71oj_116">除此之外，图像类型还可以进行原子操作，即当不同着色器程序向同一张图像的同一个位置写入相同数据时，会严格按照程序的执行顺序进行处理，不会出现次序问题。</p><p id="-sd71oj_117">可以用于原子操作的图像格式有严格的限制，只可以是 <code class="code" id="-sd71oj_122">R32I/r32i</code> 或 <code class="code" id="-sd71oj_123">R32UI/r32ui</code> ，但是通过格式转换是可以在其他格式上使用的，例如将一个 <code class="code" id="-sd71oj_124">RGBA8I</code> （4x8=32位）声明为 <code class="code" id="-sd71oj_125">R32I</code> （1x32=32位），不过这就需要手动进行移位来处理具体内容了。</p><p id="-sd71oj_118">所有原子操作返回的值都是图像位置上的原始值，下列的 <code class="code" id="-sd71oj_126"><em id="-sd71oj_131">g</em>int</code> 中的 <span class="emphasis" id="-sd71oj_127"><code class="code" id="-sd71oj_132">g</code></span> 指的是 <code class="code" id="-sd71oj_128">int</code> 或 <code class="code" id="-sd71oj_129">uint</code>。 <code class="code" id="-sd71oj_130">IMAGE_COORDS</code> 表示正在处理的图像的像素坐标。</p><ul class="list _bullet" id="-sd71oj_119"><li class="list__item" id="-sd71oj_133"><p id="-sd71oj_138">原子赋值，由于它们会返回原值，所以也可用作交换： <br><code class="code" id="-sd71oj_140">gint imageAtomicExchange(gimage image, IMAGE_COORDS, gint data)</code></p></li><li class="list__item" id="-sd71oj_134"><p id="-sd71oj_141">原子条件赋值，仅当图像目标值等于条件值时赋值： <br><code class="code" id="-sd71oj_143">gint imageAtomicCompSwap(gimage image, IMAGE_COORDS, gint compare, gint data)</code></p></li><li class="list__item" id="-sd71oj_135"><p id="-sd71oj_144">原子算术，GLSL 仅提供加法，但是你可以在<span class="control" id="-sd71oj_145">有符号整数运算</span>中为 <code class="code" id="-sd71oj_146">data</code> 添加负号来进行减法运算： <br><code class="code" id="-sd71oj_148">gint imageAtomicAdd(gimage image, IMAGE_COORDS, gint data)</code><br> 自 GLSL 4.30 起，你也可以在无符号整数中进行这种计算，只需要写作 <code class="code" id="-sd71oj_150">imageAtomicAdd(..., uint(-data))</code> 。当然，你得保证最终的值不会为负而溢出。</p></li><li class="list__item" id="-sd71oj_136"><p id="-sd71oj_151">原子位运算，可以进行与、或和异或运算： <br><code class="code" id="-sd71oj_153">gint imageAtomicAnd(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="-sd71oj_155">gint imageAtomicOr(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="-sd71oj_157">gint imageAtomicXor(gimage image, IMAGE_COORDS, gint data)</code></p></li><li class="list__item" id="-sd71oj_137"><p id="-sd71oj_158">原子大小值，可以取最大值和最小值： <br><code class="code" id="-sd71oj_160">gint imageAtomicMin(gimage image, IMAGE_COORDS, gint data)</code><br><code class="code" id="-sd71oj_162">gint imageAtomicMax(gimage image, IMAGE_COORDS, gint data)</code></p></li></ul><p id="-sd71oj_120">你也可以使用 <code class="code" id="-sd71oj_163">memoryBarrier()</code> 来手动设置内存屏障。</p><p id="-sd71oj_121">资料来源： <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store" id="-sd71oj_164" data-external="true" rel="noopener noreferrer" target="_blank">Image Load Store - OpenGL Wiki</a> ，此处仅作扩展阅读，留由读者自行研究。</p></aside></section></section><section class="chapter"><h2 id="-sd71oj_7" data-toc="-sd71oj_7">描边与原版实现</h2><p id="-sd71oj_165">现在我们已经获得了发光实体的遮罩数据，如果单纯地想给覆盖区域外围加上一圈描边，我们只需要在延迟处理中简单地检查当前像素是否为非发光区域，然后搜索邻近的四个（或加上对角线共八个）像素即可。当搜索到任何一个邻近像素是发光区域时，就给当前像素上色，类似这样：</p><div class="code-block" data-lang="glsl">
[... Uniforms.glsl ...]
uniform isampler2D colortex4;
[... final - main ...]
bool isGlowing = bool(texture(colortex4, uv).r);
bool isGlowingEdge = false;
if(!isGlowing) {
    for(int i = -1; i &lt; 2; i+=2) {
        ivec2 sCoord = ivec2(gl_FragCoord.xy) + ivec2(i,0);
        isGlowingEdge = bool(texelFetch(colortex4, sCoord, 0).r);
        if(isGlowingEdge) break;
    }
    for(int i = -1; i &lt; 2 &amp;&amp; !isGlowingEdge; i+=2) {
        ivec2 sCoord = ivec2(gl_FragCoord.xy) + ivec2(0,i);
        isGlowingEdge = bool(texelFetch(colortex4, sCoord, 0).r);
        if(isGlowingEdge) break;
    }
}
if(isGlowingEdge) fragColor = vec4(1.0);
</div><p id="-sd71oj_167">至此，我们就已经初步成功给发光实体描上边了，值得注意的是，上一章中，我们将发光实体暂时设定为了无光照类：</p><figure id="-sd71oj_168"><img alt="发光实体描边" src="MGC_Docs/glowingEntities_glowingEdge.webp" title="发光实体描边" width="700" height="394"></figure><p id="-sd71oj_169">当然，这个发光描边效果仍然很粗糙，只有 1 像素，分辨率高一些观感就会变得很差，所以让我们继续拆解原版的发光描边着色器。</p><p id="-sd71oj_170">原版的描边使用了两个后处理 Pass 进行处理，第一个 Pass <code class="code" id="-sd71oj_178">entity_outline_box_blur</code> 使用方框模糊处理了发光区域的数据并让 Alpha 值在模糊边缘断层，从而形成渐变过渡，并间接确定了描边宽度：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="false" data-synopsis="entity_outline_box_blur.fsh">
#version 150

uniform sampler2D InSampler;

in vec2 texCoord;
in vec2 sampleStep;

out vec4 fragColor;

void main() {
    vec4 blurred = vec4(0.0);
    float radius = 2.0;
    for (float a = -radius + 0.5; a &lt;= radius; a += 2.0) {
        blurred += texture(InSampler, texCoord + sampleStep * a);
    }
    blurred += texture(InSampler, texCoord + sampleStep * radius) / 2.0;
    fragColor = vec4((blurred / (radius + 0.5)).rgb, blurred.a);
}
</div><p id="-sd71oj_172">这个着色器利用 <code class="code" id="-sd71oj_179">texture()</code> 的插值性在纹理的四个像素交界处进行两次采样，然后再单独在采样方向上的最外侧进行一次采样，从而快速获得半径内的平均色，最后再除以采样半径 <span id="-sd71oj_180"><sup class="superscript"><span class="control" id="-sd71oj_181">1</span></sup></span> 。由于原版的发光效果是纯白色，RGB 通道和 A 通道的数据事实上只有是否除以半径的区别，为了确保精度和原版一致性，我们将在描边着色器中统一进行除法。</p><p id="-sd71oj_173">第二个 Pass <code class="code" id="-sd71oj_182">entity_outline</code> <span id="-sd71oj_183"><sup class="superscript"><span class="control" id="-sd71oj_184">2</span></sup></span> 则用于再次混合邻近的四个像素并比较 Alpha 的总差异来确认颜色和混合比例：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="false" data-synopsis="entity_sobel.fsh">
#version 150

uniform sampler2D InSampler;

in vec2 texCoord;
in vec2 oneTexel;

out vec4 fragColor;

void main(){
    vec4 center = texture(InSampler, texCoord);
    vec4 left = texture(InSampler, texCoord - vec2(oneTexel.x, 0.0));
    vec4 right = texture(InSampler, texCoord + vec2(oneTexel.x, 0.0));
    vec4 up = texture(InSampler, texCoord - vec2(0.0, oneTexel.y));
    vec4 down = texture(InSampler, texCoord + vec2(0.0, oneTexel.y));
    float leftDiff  = abs(center.a - left.a);
    float rightDiff = abs(center.a - right.a);
    float upDiff    = abs(center.a - up.a);
    float downDiff  = abs(center.a - down.a);
    float total = clamp(leftDiff + rightDiff + upDiff + downDiff, 0.0, 1.0);
    vec3 outColor = center.rgb * center.a + left.rgb * left.a + right.rgb * right.a + up.rgb * up.a + down.rgb * down.a;
    fragColor = vec4(outColor * 0.2, total);
}
</div><p id="-sd71oj_175">由于第一个 Pass 进行了数据模糊，所以发光和非发光相接的区域就会产生 Alpha 值的平滑过渡。当我们使用与邻近像素的 Alpha 差值和作为绘制依据时，由于远离交界区域的 Alpha 值始终为 0 或 1，处理的像素和周围像素没有 Alpha 差值（始终为 0 或 1），交界区域就会自然产生描边条带。</p><p id="-sd71oj_176">虽然原版中使用了整个全通道的缓冲区用来处理输出，但如果我们只使用纯色，则只需要单个通道（习题 2）。我们用来处理发光轮廓的代码也将以它们为蓝本。</p><p id="-sd71oj_177"><span class="control" id="-sd71oj_185">[1]</span> 因为之前的采样都是两两像素的平均色，最后一次采样又手动减半，因此采样出来的颜色总和实际上只有一半，所以最后除数就不必为像素数量总和了。 <br><span class="control" id="-sd71oj_187">[2]</span> 原版允许使用 JSON 文件自定义使用的顶点着色器和片段着色器，因此会出现 Pass 名称和着色器名称对不上的情况。比如这个 Pass 的顶点着色器 <code class="code" id="-sd71oj_188">blur.vsh</code> 也被用于了打开菜单后的背景模糊。</p></section><section class="chapter"><h2 id="-sd71oj_8" data-toc="-sd71oj_8">多程序处理</h2><p id="-sd71oj_189">之前的编程中，我们的延迟处理程序都集中在管线的最末端，即 <code class="code" id="-sd71oj_207">final</code> 中。而描边着色器要求将场景完全模糊之后再来检查，也就是说，如果我们想在同一个着色器中完成这些事情，需要将四周邻近的像素都进行模糊处理然后再来比较。然而普通的片段着色器中，这些数据是无法共享的，也就是说周围的像素在它们各自的片段着色器中也会这样干，最终就会造成四倍的模糊开销，这是极其不划算的。自然而然的，我们就会做出像原版那样的事情：先在一个 Pass 中进行图像模糊，再在下一个 Pass 中处理描边。</p><p id="-sd71oj_190">OptiFine 为我们提供了高度可自定义的延迟处理程序数量。回顾一下，我们可以用的延迟处理主要集中在两个阶段：固体几何缓冲之后的 Deferred 和余下几何缓冲之后的 Composite 。像发光描边这种类似 HUD 的特效，我们肯定是不希望被第二轮几何缓冲中的几何体给覆盖的，因此我们能选择的就只有 Composite 阶段了。</p><p id="-sd71oj_191">原版的模糊着色器很奇怪，它只在某个方向（<code class="code" id="-sd71oj_208">sampleStep</code> ）上处理了模糊（或许运行了两次？）。为了平衡性能和质量，我们会将模糊本身也分为两个 Pass，先将其进行水平模糊，再进行垂直模糊，这样处理的结果会更加柔和。因此我们的模糊就在 <code class="code" id="-sd71oj_209">composite</code> 和 <code class="code" id="-sd71oj_210">composite1</code> 中进行，而描边则接在 <code class="code" id="-sd71oj_211">final</code> 中场景绘制完毕之后。</p><p id="-sd71oj_192">没有特别的要求的话，所有延迟处理的顶点着色器都一样，因此你可以直接复制 <code class="code" id="-sd71oj_212">final.vsh</code> 并更名。</p><p id="-sd71oj_193">参考原版着色器，它使用了方框模糊（Box Blur）将周围的数据进行平均，我们也将仿照它的方法和技巧，进行 5x5 的模糊处理，并将半径设计为可调整。</p><p id="-sd71oj_194">其他的常规声明与 Final 一样，在这个着色器中，我们只需要向发光数据中写入内容，因此渲染目标只有 4 号缓冲区：</p><div class="code-block" data-lang="glsl">
/* DRAWBUFFERS:4 */
layout(location = 0) out float blurredGlowingBuffer;
</div><p id="-sd71oj_196"><code class="code" id="-sd71oj_213">main</code> 函数的内容和原版着色器很相似，只不过我们可以把模糊半径塞入 <code class="code" id="-sd71oj_214">Settings.glsl</code> 中，以便间接控制发光描边宽度。水平模糊的着色器看起来就像这样：</p><div class="code-block" data-lang="glsl">
blurredGlowingBuffer = 0.0;
vec2 sampleDir = vec2(pixelSize.x, 0.0);
for(float i = -GLOWING_BLUR_RADIUS + .5; i &lt;= GLOWING_BLUR_RADIUS; i += 2.0) {
    blurredGlowingBuffer += texture(colortex4, uv + sampleDir * i).r;
}
blurredGlowingBuffer += texture(colortex4, uv + sampleDir * GLOWING_BLUR_RADIUS).r * .5;
</div><p id="-sd71oj_198">而垂直模糊只需要将 <code class="code" id="-sd71oj_215">sampleDir</code> 的 <code class="code" id="-sd71oj_216">vec2(pixelSize.x, 0.0)</code> 替换为 <code class="code" id="-sd71oj_217">vec2(0.0, pixelSize.y)</code> 即可。</p><aside class="prompt" data-type="note" data-title="" id="-sd71oj_199"><p id="-sd71oj_218">这种描边本质上是轮廓两侧扩散，因为模糊时没有进行判定。如果你想要外侧描边，可以在模糊时仅模糊没有发光区域的部分。同样的，如果你想要内侧描边，可以仅模糊发光的区域。</p></aside><p id="-sd71oj_200">最后，我们回到 Final 中，将原版的方法封装成函数原样搬入，只需要注意将 <code class="code" id="-sd71oj_219">.rgb</code> 分量更改为 <code class="code" id="-sd71oj_220">.r</code>， <code class="code" id="-sd71oj_221">.a</code> 分量更改为 <code class="code" id="-sd71oj_222">.g</code> ，然后将其他统一变量对齐即可：</p><div class="code-block" data-lang="glsl">
vec2 getGlowingEdge() {
    float center = texture(colortex4, uv).r;
    float left = texture(colortex4, uv - vec2(pixelSize.x, 0.0)).r;
    float right = texture(colortex4, uv + vec2(pixelSize.x, 0.0)).r;
    float up = texture(colortex4, uv - vec2(0.0, pixelSize.y)).r;
    float down = texture(colortex4, uv + vec2(0.0, pixelSize.y)).r;
    float leftDiff  = abs(center - left);
    float rightDiff = abs(center - right);
    float upDiff    = abs(center - up);
    float downDiff  = abs(center - down);
    float total = clamp((leftDiff + rightDiff + upDiff + downDiff), 0.0, 1.0);
    float outColor = center * center + left * left + right * right + up * up + down * down;
    float div = GLOWING_BLUR_RADIUS + .5;
    div *= div;
    div *= div;
    return vec2(outColor * .2 / div, total);
}
</div><p id="-sd71oj_202">这里有个很奇怪事情，我们只执行了两次模糊，统一进行除法时却需要除以四次方才能和原版着色器的描边过渡相似 <span id="-sd71oj_223"><sup class="superscript"><span class="control" id="-sd71oj_224">1</span></sup></span> 。最后，将 Final 中之前的颜色与之相混合，就可以绘制出发光描边了：</p><p id="-sd71oj_203"><span class="control" id="-sd71oj_225">[1]</span> 事实上就算在模糊着色器中进行除法，也需要给每个程序除以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="4.069ex" height="2.043ex" role="img" focusable="false" viewBox="0 -892 1798.6 903"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mtext"><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(556,0)"></path><path data-c="76" d="M338 431Q344 429 422 429Q479 429 503 431H508V385H497Q439 381 423 345Q421 341 356 172T288 -2Q283 -11 263 -11Q244 -11 239 -2Q99 359 98 364Q93 378 82 381T43 385H19V431H25L33 430Q41 430 53 430T79 430T104 429T122 428Q217 428 232 431H240V385H226Q187 384 184 370Q184 366 235 234L286 102L377 341V349Q377 363 367 372T349 383T335 385H331V431H338Z" transform="translate(834,0)"></path></g><g data-mml-node="mn" transform="translate(1395,421.1) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container> 才能接近原版着色器，不过我们这里就从简了。</p><div class="code-block" data-lang="glsl">
vec2 glowingEdge = getGlowingEdge();
fragColor.rgb = mix(fragColor.rgb, glowingEdge.xxx, glowingEdge.y);
</div><p id="-sd71oj_205">当然，你也可以自定义发光描边的颜色。最后让我们看看将模糊半径设置为 10，并将混合颜色使用三角函数和 <a href="a01-uniformsandats.html#uniforms" id="-sd71oj_227" data-tooltip=""><code class="code" id="-sd71oj_228">frameTimeCounter</code></a> 处理以呈现的动态彩虹发光描边！</p><figure data-theme="light" id="-sd71oj_206" width="700"><img alt="彩虹描边" class="js-gif article__bordered-element" data-gif-src="MGC_Docs/glowingEntities_RAINBOW.gif" width="700" style="width: 700px;"></figure></section><section class="chapter"><h2 id="-sd71oj_9" data-toc="-sd71oj_9">习题</h2><ol class="list _decimal" id="-sd71oj_229" type="1"><li class="list__item" id="-sd71oj_230"><p id="-sd71oj_233">（与习题 2 二选一）将 4 号缓冲区的内容合并入 3 号缓冲区中。之后，你可以先使用 <code class="code" id="-sd71oj_234">imageLoad(colorimg3, COORD).r</code> 取出已经写入的几何 ID，然后手动进行深度测试来决定保留几何 ID 的源内容还是覆写新内容（当前片段深度小于深度图上已有的深度时，说明发光实体本身也在前景，因此要覆写几何 ID），最后使用 <code class="code" id="-sd71oj_235">imageStore(colorimg3, COORD, vec4(float(geometryID), 1.0, vec2(0.0)))</code> 覆写图像内容并确保 G 通道为 1.0 即可。随后的模糊 Pass 只需要将 R 通道中的内容原样输出。</p></li><li class="list__item" id="-sd71oj_231"><p id="-sd71oj_236">（与习题 1 二选一）将 4 号缓冲区改为四通道，并在几何缓冲存入数据时写入纹理颜色，这样在后处理中就会产生根据实体本身的区别产生不同的描边光效。</p></li><li class="list__item" id="-sd71oj_232"><p id="-sd71oj_237">尝试编写一个本节末尾处的彩虹描边效果。</p><ul class="list _bullet" id="-sd71oj_238"><li class="list__item" id="-sd71oj_239"><p id="-sd71oj_241">如果你没有完成习题 2，可以直接定义一个三维向量，每个通道都利用三角函数将 <code class="code" id="-sd71oj_242">glowingEdge.x</code> 加上 <code class="code" id="-sd71oj_243">frameTimeCounter</code> 作为参数来周期性地改变颜色；然后配置文件中按统一变量的方法定义常量 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.29ex" height="1ex" role="img" focusable="false" viewBox="0 -431 570 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g></svg></mjx-container> ，将其添加入 <code class="code" id="-sd71oj_245">Uniforms.glsl</code> ，加入三角函数中用以给每个颜色分量不同的相位偏移（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="1.907ex" height="2.397ex" role="img" focusable="false" viewBox="0 -698.8 843.1 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g><g data-mml-node="mn" transform="translate(244.7,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><rect width="603.1" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>、 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="2.707ex" height="2.773ex" role="img" focusable="false" viewBox="0 -864.9 1196.6 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,394) scale(0.707)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g><g data-mml-node="mn" transform="translate(421.5,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><rect width="956.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container> ）。为了防止颜色溢出到负值，你可以将结果进行平方；如果你想要更加平缓的边缘，可以给颜色额外乘上 <code class="code" id="-sd71oj_248">glowingEdge.x</code> 或将其乘入混合参考。</p></li><li class="list__item" id="-sd71oj_240"><p id="-sd71oj_249">如果你完成了习题 2，可以直接使用 <code class="code" id="-sd71oj_250">glowingEdge.w</code> 除以四次方的 <code class="code" id="-sd71oj_251">GLOWING_BLUR_RADIUS + .5</code> 来当作三角函数的参数，然后按上述方法来绘制彩虹。</p></li></ul></li></ol></section><div class="last-modified">30 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="2-1-solidgeometries.html" class="navigation-links__prev">固体几何缓冲</a><a href="2-3-1-advancedlighting.html" class="navigation-links__next">进阶延迟处理：光照</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
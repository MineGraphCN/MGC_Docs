<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-11T11:02:07.186377906"><title>延迟渲染初体验 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"-qc1isd_5","level":0,"title":"第一个着色器","anchor":"#-qc1isd_5"},{"id":"-qc1isd_15","level":1,"title":"铺好画布","anchor":"#-qc1isd_15"},{"id":"-qc1isd_16","level":1,"title":"往上面泼一些颜色","anchor":"#-qc1isd_16"},{"id":"-qc1isd_6","level":0,"title":"采样纹理","anchor":"#-qc1isd_6"},{"id":"-qc1isd_44","level":1,"title":"缓冲区","anchor":"#-qc1isd_44"},{"id":"-qc1isd_45","level":1,"title":"坐标","anchor":"#-qc1isd_45"},{"id":"-qc1isd_46","level":1,"title":"把它们画出来","anchor":"#-qc1isd_46"},{"id":"-qc1isd_7","level":0,"title":"纹理边界","anchor":"#-qc1isd_7"},{"id":"-qc1isd_8","level":0,"title":"多次采样","anchor":"#-qc1isd_8"},{"id":"-qc1isd_9","level":0,"title":"宏命令","anchor":"#-qc1isd_9"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="延迟渲染初体验 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/1-1-deferred.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="延迟渲染初体验 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/1-1-deferred.html#webpage",
    "url": "https://docs.minegraph.cn/md/1-1-deferred.html",
    "name": "延迟渲染初体验 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="1-1-deferred" data-main-title="延迟渲染初体验" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Developer.md|创作者文档///shaderTutorial.md|光影开发教程///你好，光影"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="1-1-deferred" id="1-1-deferred.md">延迟渲染初体验</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-qc1isd_10\&quot;\u003e从本章节开始，我们就正式进入光影的编写了。我们将会从延迟处理开始，了解理论机制、认识几何缓冲，并最终实现一些简单的效果。\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;-qc1isd_11\&quot;\u003e在 \u003ca href\u003d\&quot;0-1-filepipeline.html\&quot; id\u003d\&quot;-qc1isd_12\&quot; data-tooltip\u003d\&quot;本章节将会为你介绍 OptiFine 的光影加载方法和处理管线，是创作光影必须的前置知识。\&quot;\u003e结构和管线\u003c/a\u003e 中我们有提到过，延迟处理在每一轮几何缓冲之后运行。当光影中着色器文件不存在时，OptiFine 会将它们回退到内置实现，这也给了我们从延迟处理开始底气\u0026mdash;\u0026mdash;原版的场景已经绘制好了，我们现在只需要在画布上画画即可。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="-qc1isd_5" data-toc="-qc1isd_5">第一个着色器</h2><p id="-qc1isd_13">还记得 OptiFine 管线输出的最末端是哪个程序吗？没错就是延迟处理程序 <code class="code" id="-qc1isd_17">final</code>。</p><p id="-qc1isd_14">它在管线的最末端，并且只有一个输出，从这里开始了解延迟处理阶段再合适不过了。那么现在让我们在工作区先新建 <code class="code" id="-qc1isd_18">final.vsh</code> 和 <code class="code" id="-qc1isd_19">final.fsh</code> 来上手试试吧。</p><section class="chapter"><h3 id="-qc1isd_15" data-toc="-qc1isd_15">铺好画布</h3><p id="-qc1isd_20">还记得我们在 <a href="shaderbasic.html#延迟渲染法" id="-qc1isd_25" data-tooltip="为了避免大量最终不可见的顶点在传入时就进行光照处理带来如此大的不必要开销，延迟渲染法（Deferred Shading）应运而生，它的思想是不再在传入几何体的阶段立即计算大多数效果，而是分为两个阶段：">延迟渲染</a> 提到的概念（如果你没看过最好去瞅两眼）吗？延迟处理传入的几何是一个<span class="control" id="-qc1isd_26">铺屏四边形</span> ，在 OptiFine 中它覆盖 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.029ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2222.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1333.7,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(1833.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.029ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2222.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1333.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1833.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 的矩形区域，而窗口的坐标范围是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.287ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2778.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2000.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2500.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> <sup class="superscript" id="-qc1isd_30"><span class="control" id="-qc1isd_31">1</span></sup> ，那么我们的顶点着色器就很简单了：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="true" data-synopsis="final.vsh">
#version 330 core

in vec3 vaPosition;

void main() {
    gl_Position = vec4(vaPosition.xy * 2.0 - 1.0, vec2(0.0));
}
</div><p id="-qc1isd_22">看起来很多，实际上真正重要的内容只有 <code class="code" id="-qc1isd_32">vaPosition.xy * 2.0 - 1.0</code> ，它将顶点从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 变换到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.287ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2778.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2000.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2500.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>。</p><p id="-qc1isd_23"><span class="control" id="-qc1isd_35">[1]</span> 在几何缓冲章节我们将详细介绍，在这里你只需要知道 OpenGL 期望所有的顶点坐标都落在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.287ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2778.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2000.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2500.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 区间内就行了。</p><p id="-qc1isd_24">现在，我们就可以在这张空白画布上大展拳脚了。</p></section><section class="chapter"><h3 id="-qc1isd_16" data-toc="-qc1isd_16">往上面泼一些颜色</h3><p id="-qc1isd_37">来到我们的片段着色器，随便来一些输出看看效果，比如一些颜色：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="true" data-synopsis="final.fsh">
#version 330 core

out vec4 fragColor;

void main() {
    fragColor = vec4(1.0, 0.0, 0.0, 1.0); // 画一些红色
}
</div><p id="-qc1isd_39">并按下 <kbd class="keystroke" id="-qc1isd_42" data-bypass="true"><span class="keystroke__value">F3</span></kbd><kbd class="keystroke" id="-qc1isd_43" data-bypass="true"><span class="keystroke__value">R</span></kbd> 重载光影。然后，你就已经可以在游戏窗口中看到光影的效果了：</p><figure id="-qc1isd_40"><img alt="deferred_drawRed.png" src="MGC_Docs/deferred_drawRed.png" title="deferred_drawRed.png" width="1282" height="752"></figure><p id="-qc1isd_41">哇哦！真的是好&hellip;&hellip;呃，红啊！当然，光靠这种纯色我们甚至无法画出场景，我们需要获取一些几何缓冲绘制好的数据。</p></section></section><section class="chapter"><h2 id="-qc1isd_6" data-toc="-qc1isd_6">采样纹理</h2><section class="chapter"><h3 id="-qc1isd_44" data-toc="-qc1isd_44">缓冲区</h3><p id="-qc1isd_47">在 GLSL 中，我们通过采样纹理来获取颜色数据。在延迟处理中，几何缓冲输出的缓冲区就充当了采样用的纹理。因此我们也可以知道，缓冲区是几何缓冲向延迟处理传递信息的媒介：</p><div><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="42.864ex" height="3.529ex" role="img" focusable="false" viewBox="0 -1359.7 18946 1559.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">几</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">何</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缓</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">冲</text></g><g data-mml-node="mover" transform="translate(4277.8,0)"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(2417.4,0)"></path><svg width="2517.4" height="865" x="0" y="-182" viewBox="629.4 -182 2517.4 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(4.854,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">原</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">始</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">据</text></g><g data-mml-node="mspace" transform="translate(4000,0)"></g></g></g></g><g data-mml-node="mi" transform="translate(7973,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缓</text></g><g data-mml-node="mi" transform="translate(8973,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">冲</text></g><g data-mml-node="mi" transform="translate(9973,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">区</text></g><g data-mml-node="mover" transform="translate(11250.8,0)"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(2417.4,0)"></path><svg width="2517.4" height="865" x="0" y="-182" viewBox="629.4 -182 2517.4 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(4.854,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缓</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">据</text></g><g data-mml-node="mspace" transform="translate(4000,0)"></g></g></g></g><g data-mml-node="mi" transform="translate(14946,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">延</text></g><g data-mml-node="mi" transform="translate(15946,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">迟</text></g><g data-mml-node="mi" transform="translate(16946,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">处</text></g><g data-mml-node="mi" transform="translate(17946,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">理</text></g></g></g></svg></mjx-container></div><p id="-qc1isd_49">OptiFine 提供了至多 16 个（通常我们只用一半）二维缓冲区供我们使用，由于我们没有自己编写几何缓冲，内置管线默认使用向前渲染法将所有场景输出到了 <span class="control" id="-qc1isd_53">0 号缓冲区</span> <code class="code" id="-qc1isd_54">colortex0</code>。</p><p id="-qc1isd_50">著名哲学家 <span class="emphasis" id="-qc1isd_55">维吉尔</span> 曾经说过：&ldquo; <span class="emphasis" id="-qc1isd_56">If you wanna it, then you have to take it.</span> &rdquo;，如果我们需要采样它，那我们就得先声明它。在 GLSL 中，我们使用<span class="control" id="-qc1isd_57">采样器</span> （sampler）类型来声明一个纹理。于是我们的第一行新代码便呼之欲出：</p><div class="code-block" data-lang="glsl">
uniform sampler2D colortex0;
</div><p id="-qc1isd_52">这行代码声明了从 GL 上下文传入的二维纹理 <code class="code" id="-qc1isd_58">colortex0</code> ，有了它，我们就能进行接下来的工作了。</p></section><section class="chapter"><h3 id="-qc1isd_45" data-toc="-qc1isd_45">坐标</h3><p id="-qc1isd_59">还记得片段着色器是如何执行的吗？它在每个图元覆盖的每个像素上运行一次，然后将处理结果写入指定缓冲区或屏幕的对应坐标。</p><p id="-qc1isd_60">那么，我们要怎样才能知道当前像素的坐标以采样正确的位置呢？</p><p id="-qc1isd_61">幸运的是，我们有办法，而且还不止一种。</p><p id="-qc1isd_62">第一种办法，我们直接利用 OptiFine 提供的顶点属性 <code class="code" id="-qc1isd_74">vaUV0</code> ，它提供了当前顶点对应的纹理坐标。</p><p id="-qc1isd_63">我们只需要在顶点着色器中传入这个变量，然后赋给传出到片段着色器的变量即可：</p><div class="code-block" data-lang="glsl">
[...]
in vec2 vaUV0;
out vec2 uv;

void main() {
    [...]
    uv = vaUV0;
}
</div><p id="-qc1isd_65">接着，我们在片段着色器中传入同名变量：</p><div class="code-block" data-lang="glsl">
in vec2 uv;
</div><p id="-qc1isd_67">这样，我们就获取到了采样纹理所需要的<span class="control" id="-qc1isd_75">归一化坐标</span>。</p><p id="-qc1isd_68">现在来回想一下，在延迟处理中，纹理坐标和屏幕坐标是相等的，因此这也引出了另一种办法，而且可以直接在片段着色器中完成。</p><p id="-qc1isd_69">首先我们需要 GLSL 的另一个内建变量 <code class="code" id="-qc1isd_76">gl_FragCoord</code> ，它指定了当前像素在窗口内的空间坐标。</p><p id="-qc1isd_70">由于我们只关注像素在屏幕上的二维位置，因此我们只关心它的 <code class="code" id="-qc1isd_77">xy</code> 分量。 <code class="code" id="-qc1isd_78">gl_FragCoord.xy</code> 表示了当前像素在横轴和纵轴上的序号（我们可以将其称之为整数坐标），因此它会随着分辨率的变化而变化。</p><p id="-qc1isd_71">那么我们应该如何求得其归一化坐标呢？这里我们需要 OptiFine 提供的两个统一变量： <code class="code" id="-qc1isd_79">viewWidth</code> 和 <code class="code" id="-qc1isd_80">viewHeight</code> ，它们以像素为单位表示了窗口的宽度和高度。</p><p id="-qc1isd_72">于是我们的归一化纹理坐标 <code class="code" id="-qc1isd_81">uv</code> 就可以求得了：</p><div class="code-block" data-lang="glsl">
vec2 uv = gl_FragCoord.xy / vec2(viewWidth, viewHeight);
</div></section><section class="chapter"><h3 id="-qc1isd_46" data-toc="-qc1isd_46">把它们画出来</h3><p id="-qc1isd_82">有了采样器和采样坐标，我们就可以很方便地在 GLSL 中采样纹理了，隆重介绍我们的劳模函数： <code class="code" id="-qc1isd_100">texture()</code>。</p><p id="-qc1isd_83"><code class="code" id="-qc1isd_101">texture()</code> 接受两个参数：采样器和与采样器同维的归一化坐标，它会返回纹理对应坐标上的颜色值。</p><p id="-qc1isd_84">现在，让我们修改片段着色器，试着向屏幕上输出场景：</p><div class="code-collapse" data-lang="glsl" data-is-expanded="true" data-synopsis="final.fsh">
#version 330 core

uniform sampler2D colortex0;
uniform float viewWidth;
uniform float viewHeight;

out vec4 fragColor;

vec2 uv = gl_FragCoord.xy / vec2(viewWidth, viewHeight);

void main() {
    fragColor = texture(colortex0, uv); // 采样纹理
}
</div><figure id="-qc1isd_86"><img alt="deferred_firstSampling.png" src="MGC_Docs/deferred_firstSampling.png" title="deferred_firstSampling.png" width="1282" height="752"></figure><p id="-qc1isd_87">What Amazing！我们成功向屏幕输出了 0 号缓冲区的内容！</p><aside class="prompt" data-type="tip" data-title="" id="-qc1isd_88"><p id="-qc1isd_102">事实上默认输出到屏幕上的就是 0 号缓冲区，只不过我们在之前的 <code class="code" id="-qc1isd_103">final.fsh</code> 中把内容覆写成了纯色。</p></aside><p id="-qc1isd_89">然而，我们其实不止有一种采样函数。如果你在之前我们用整数坐标求归一化坐标时也想过：有没有更简单的办法，直接用整数坐标进行采样呢？</p><p id="-qc1isd_90">那么这里就将向你介绍另一个采样函数： <code class="code" id="-qc1isd_104">texelFetch()</code>。</p><p id="-qc1isd_91"><code class="code" id="-qc1isd_105">texelFetch()</code> 和 <code class="code" id="-qc1isd_106">texture()</code> 很相似（更准确地说是和它的兄弟 <code class="code" id="-qc1isd_107">textureLod()</code> 更相似），前者接受三个参数：采样器、同维采样<span class="control" id="-qc1isd_108">整数坐标</span> ，以及一项额外的 Mipmap 等级。</p><p id="-qc1isd_92">第三个参数我们在这里不过多展开，你只需要知道它接受一个 <code class="code" id="-qc1isd_109">int</code> 值用于指定纹理细节等级，从 0 开始，每加 1 纹理的精度就会减半。</p><p id="-qc1isd_93">值得注意的是， <code class="code" id="-qc1isd_110">texelFetch()</code> 的第二个参数要求传入<span class="control" id="-qc1isd_111">整数向量</span>类型（<code class="code" id="-qc1isd_112">ivec</code> ），而 <code class="code" id="-qc1isd_113">gl_FragCoord</code> 实际上是<span class="control" id="-qc1isd_114">浮点向量</span>类型（<code class="code" id="-qc1isd_115">vec4</code> ，和它的 <code class="code" id="-qc1isd_116">w</code> 分量有关，具体见 <a href="a02-corebuiltinvars.html" id="-qc1isd_117" data-tooltip="">核心配置中可用的内建变量</a> ），因此在使用时我们需要进行转换：</p><div class="code-block" data-lang="glsl">
fragColor = texelFetch(colortex0, ivec2(gl_FragCoord.xy), 0);
</div><p id="-qc1isd_95">和 <code class="code" id="-qc1isd_118">texture()</code> 不同的是，使用 <code class="code" id="-qc1isd_119">texture()</code> 进行采样时，由于其使用浮点坐标，如果它的采样坐标在纹理的像素之间就会自动进行插值；而 <code class="code" id="-qc1isd_120">texelFetch()</code> 由于使用了整型坐标，它的采样点不会产生偏移，也就不会自动插值了。</p><p id="-qc1isd_96">你可以将它们的坐标参数同时除以一个数（相当于放大纹理）来验证具体区别：</p><dl id="-qc1isd_97" data-style="title-top"><dt id="-qc1isd_121" data-expandable="false"><code class="code" id="-qc1isd_126">texture()</code></dt><dd><div class="code-block" data-lang="glsl">
fragColor = texture(colortex0, uv / 8.0);
</div><figure id="-qc1isd_125"><img alt="八倍放大的归一化坐标" src="MGC_Docs/deferred_texture8x.png" title="八倍放大的归一化坐标" width="1282" height="752"></figure></dd><dt id="-qc1isd_122" data-expandable="false"><code class="code" id="-qc1isd_130">texelFetch()</code></dt><dd><div class="code-block" data-lang="glsl">
fragColor = texelFetch(colortex0, ivec2(gl_FragCoord.xy) / 8, 0);
</div><figure id="-qc1isd_129"><img alt="八倍放大的整数坐标" src="MGC_Docs/deferred_texelFetch8x.png" title="八倍放大的整数坐标" width="1282" height="752"></figure></dd></dl><p id="-qc1isd_98">可以很明显地看到， <code class="code" id="-qc1isd_131">texture()</code> 采样出来的画面比较模糊，而 <code class="code" id="-qc1isd_132">texelFetch()</code> 则棱角分明 <span id="-qc1isd_133"><span class="text-line-through">，像素颗颗饱满</span></span>。</p><p id="-qc1isd_99">在本教程中，如无必要，我们都将使用 <code class="code" id="-qc1isd_134">texture()</code>。</p></section></section><section class="chapter"><h2 id="-qc1isd_7" data-toc="-qc1isd_7">纹理边界</h2><p id="-qc1isd_135">既然我们能采样纹理，你们会肯定很好奇：要是采样坐标不在像素中央会怎么样呢？</p><p id="-qc1isd_136">其实很好想象，因为所有像素的偏移坐标都一样，整个画面都会往一个方向移动&hellip;&hellip;等会？那本来就在纹理边缘的像素会怎样呢？</p><p id="-qc1isd_137"><code class="code" id="-qc1isd_151">texture()</code> 期望接受归一化的纹理坐标，因为纹理的尺寸是已知的，总是可以用 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 表示每个像素的坐标。然而如果坐标超出了这个范围，情况就不可知了。</p><p id="-qc1isd_138">因此，OpenGL 为纹理提供了多种边界的处理方式：</p><dl id="-qc1isd_139" data-style="title-top"><dt id="-qc1isd_153" data-expandable="false"><code class="code" id="-qc1isd_159">GL_Repeat</code> （GL 默认行为）</dt><dd><p id="-qc1isd_158">重复纹理内容</p></dd><dt id="-qc1isd_154" data-expandable="false"><code class="code" id="-qc1isd_162">GL_MIRRORED_REPEAT</code></dt><dd><p id="-qc1isd_161">重复纹理内容，但是每次都会在对应轴上镜像</p></dd><dt id="-qc1isd_155" data-expandable="false"><code class="code" id="-qc1isd_165">GL_CLAMP_TO_EDGE</code></dt><dd><p id="-qc1isd_164">纹理坐标被约束在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 之间，超出范围的坐标会重复边缘像素</p></dd><dt id="-qc1isd_156" data-expandable="false"><code class="code" id="-qc1isd_169">GL_CLAMP_TO_BORDER</code></dt><dd><p id="-qc1isd_168">纹理坐标被约束在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 之间，超出范围的坐标会设置为用户指定的颜色</p></dd></dl><p id="-qc1isd_140">缓冲区的默认行为是 <code class="code" id="-qc1isd_171">GL_CLAMP_TO_EDGE</code> 。然而，在 OptiFine 管线中，我们无法控制每个纹理的边缘行为，因此约束坐标就显得很重要了。</p><p id="-qc1isd_141">我们可以手动实现上述的四种边缘行为，同时附上将画面缩小到纵横各 1/4 的结果：</p><dl id="-qc1isd_142" data-style="title-top"><dt id="-qc1isd_172" data-expandable="false"><code class="code" id="-qc1isd_180">GL_Repeat</code></dt><dd><p id="-qc1isd_177">将纹理坐标约束在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 上重复即可：</p><div class="code-block" data-lang="glsl">
uv = mod(uv, 1.0);
</div><p id="-qc1isd_179"><code class="code" id="-qc1isd_182">mod()</code> 函数用于取第一个参数除以第二个参数的余数，相比 <code class="code" id="-qc1isd_183">%</code> ，它支持取浮点余数。 <figure id="-qc1isd_184"><img alt="deferred_repeat.png" src="MGC_Docs/deferred_repeat.png" title="deferred_repeat.png" width="1282" height="752"></figure></p></dd><dt id="-qc1isd_173" data-expandable="false"><code class="code" id="-qc1isd_189">GL_MIRRORED_REPEAT</code></dt><dd><p id="-qc1isd_186">根据重复次数翻转坐标：</p><div class="code-block" data-lang="glsl">
ivec2 times = ivec2(abs(floor(uv))); // 取得对应坐标上的循环次数
ivec2 isFlip = times % 2; // 当重复次数为奇数 = 1，偶数 = 0
ivec2 flipMul = 1 - 2 * isFlip; // 用来避免使用 if 的奇怪乘数，isFlip = 1 时翻转 uv 值
uv = vec2(isFlip) + mod(uv, 1.0) * vec2(flipMul);
</div><p id="-qc1isd_188"><code class="code" id="-qc1isd_190">abs()</code> 函数用于取绝对值， <code class="code" id="-qc1isd_191">floor()</code> 用于取整数部分。 <figure id="-qc1isd_192"><img alt="deferred_repeatMirror.png" src="MGC_Docs/deferred_repeatMirror.png" title="deferred_repeatMirror.png" width="1282" height="752"></figure></p></dd><dt id="-qc1isd_174" data-expandable="false"><code class="code" id="-qc1isd_197">GL_CLAMP_TO_EDGE</code> （OptiFine 缓冲区默认行为）</dt><dd><p id="-qc1isd_194">将坐标直接约束在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>：</p><div class="code-block" data-lang="glsl">
uv = clamp(uv, 0.0, 1.0);
</div><p id="-qc1isd_196"><code class="code" id="-qc1isd_199">clamp()</code> 的用法为 <code class="code" id="-qc1isd_200">clamp(变量, 下限, 上限)</code>。 <figure id="-qc1isd_201"><img alt="deferred_clampToEdge.png" src="MGC_Docs/deferred_clampToEdge.png" title="deferred_clampToEdge.png" width="1282" height="752"></figure></p></dd><dt id="-qc1isd_175" data-expandable="false"><code class="code" id="-qc1isd_206">GL_CLAMP_TO_BORDER</code></dt><dd><p id="-qc1isd_203">将大于 1 的坐标替换为常量颜色</p><div class="code-block" data-lang="glsl">
const vec4 bgColor = vec4(0.5, 0.5, 0.8, 1.0);
float isOutBound = min(abs(floor(max(uv.s, uv.t))), 1.0); // 取坐标中的大值作为混合比例，在纹理范围内取得的整数部分永远是 0，其他的取到后约束最大值到 1。
fragColor = texture(colortex0, uv);
fragColor = mix(fragColor, bgColor, isOutBound);
</div><p id="-qc1isd_205"><code class="code" id="-qc1isd_207">mix()</code> 的用法为 <code class="code" id="-qc1isd_208">mix(值1, 值2, 混合比例)</code> 。其内部实现为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="32.859ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14523.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="4D" d="M132 622Q125 629 121 631T105 634T62 637H29V683H135Q221 683 232 682T249 675Q250 674 354 398L458 124L562 398Q666 674 668 675Q671 681 683 682T781 683H887V637H854Q814 636 803 634T785 622V61Q791 51 802 49T854 46H887V0H876Q855 3 736 3Q605 3 596 0H585V46H618Q660 47 669 49T688 61V347Q688 424 688 461T688 546T688 613L687 632Q454 14 450 7Q446 1 430 1T410 7Q409 9 292 316L176 624V606Q175 588 175 543T175 463T175 356L176 86Q187 50 261 46H278V0H269Q254 3 154 3Q52 3 37 0H29V46H46Q78 48 98 56T122 69T132 86V622Z"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(917,0)"></path><path data-c="78" d="M201 0Q189 3 102 3Q26 3 17 0H11V46H25Q48 47 67 52T96 61T121 78T139 96T160 122T180 150L226 210L168 288Q159 301 149 315T133 336T122 351T113 363T107 370T100 376T94 379T88 381T80 383Q74 383 44 385H16V431H23Q59 429 126 429Q219 429 229 431H237V385Q201 381 201 369Q201 367 211 353T239 315T268 274L272 270L297 304Q329 345 329 358Q329 364 327 369T322 376T317 380T310 384L307 385H302V431H309Q324 428 408 428Q487 428 493 431H499V385H492Q443 385 411 368Q394 360 377 341T312 257L296 236L358 151Q424 61 429 57T446 50Q464 46 499 46H516V0H510H502Q494 1 482 1T457 2T432 2T414 3Q403 3 377 3T327 1L304 0H295V46H298Q309 46 320 51T331 63Q331 65 291 120L250 175Q249 174 219 133T185 88Q181 83 181 74Q181 63 188 55T206 46Q208 46 208 23V0H201Z" transform="translate(1195,0)"></path></g><g data-mml-node="mo" transform="translate(1723,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2112,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2641,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3085.7,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(3514.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3959.3,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(4531.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5198.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(6253.9,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(7005.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mo" transform="translate(8005.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(8394.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(9116.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(10116.8,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(10688.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(11300,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(12300.2,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(12951.4,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(13951.7,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container> ，因此混合比例需要约束在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 之间。 <figure id="-qc1isd_211"><img alt="deferred_clampToColor.png" src="MGC_Docs/deferred_clampToColor.png" title="deferred_clampToColor.png" width="1282" height="752"></figure></p></dd></dl><p id="-qc1isd_143">最后，我们可以将它们封装成函数，以供我们随时调用。</p><div class="code-block" data-lang="glsl">
vec2 uv_repeat(vec2 uv) {
    return mod(uv, 1.0);
}

vec2 uv_mirroredRepeat(vec2 uv) {
    ivec2 isFlip = ivec2(abs(floor(uv))) % 2;
    ivec2 flipMul = 1 - 2 * isFlip;
    return vec2(isFlip) + mod(uv, 1.0) * vec2(flipMul);
}

vec2 uv_clampToEdge(vec2 uv) {
    return clamp(uv, 0.0, 1.0);
}

vec2 uv_clampToColor(vec2 uv, out float isOutBound) {
    isOutBound = min(abs(floor(max(uv.s, uv.t))), 1.0);
    return clamp(uv, 0.0, 1.0);
}
</div><p id="-qc1isd_145">你可能注意到了，在 <code class="code" id="-qc1isd_212">uv_clampToColor()</code> 中我们在声明函数参数时使用了 <code class="code" id="-qc1isd_213">out</code> 关键字，GLSL 允许我们这样做。当函参声明 <code class="code" id="-qc1isd_214">out</code> 时，表示函数中更改的值会原路返还给用作这个参数的变量。</p><p id="-qc1isd_146">我们可以利用这个特性来进行多个值的初始化：</p><div class="code-block" data-lang="glsl">
void MultiInit(out float a, out float b, float c) {
    a = 1.0; // 正常返回
    b = 2.0; // 正常返回
    c = 3.0; // 不会返回
}

void main() {
    float a, b, c;
    MultiInit(a, b, c);
}
</div><p id="-qc1isd_148">结果为：</p><div class="code-block" data-lang="none">
a = 1.0
b = 2.0
c 未初始化
</div><p id="-qc1isd_150">同样的，我们还可以使用 <code class="code" id="-qc1isd_215">in out</code> 或者 <code class="code" id="-qc1isd_216">inout</code> 来指定既要带数据来，又会被更改值的参数。</p></section><section class="chapter"><h2 id="-qc1isd_8" data-toc="-qc1isd_8">多次采样</h2><p id="-qc1isd_217">另一个你可能会思考的问题是，我们能否采样同一个纹理多次，每次偏移一小段距离，从而绘制出更多效果？</p><p id="-qc1isd_218">如果你这样想了，那么恭喜你，你已经悟出了着色器中非常重要，也是很多现代特效极其依赖的采样手法：多次采样。</p><p id="-qc1isd_219">关于多次取样，我们最容易想到的就是<span class="control" id="-qc1isd_240">模糊</span> ，因为它的核心思想就是将周围的像素颜色<span class="control" id="-qc1isd_241">扩散</span>过来。</p><p id="-qc1isd_220">要想进行模糊，我们最先要做的就是获取周围像素的信息。回想一下坐标，我们不能通过简单的加减整数来获取临近像素的归一化坐标，那么我们要怎样精确地取到它们呢？</p><p id="-qc1isd_221">答案就藏在之前的统一变量中：我们知道屏幕的尺寸！于是我们变相知道了要步进一个像素，需要在归一化坐标上移动的距离：屏幕尺寸的倒数，即是像素尺寸。</p><div class="code-block" data-lang="glsl">
vec2 screenSize = vec2(viewWidth, viewHeight);
vec2 pixelSize = 1.0 / screenSize;
</div><p id="-qc1isd_223">接下来就很简单了，GLSL 支持 <code class="code" id="-qc1isd_242">for</code> 循环，我们只需要设定最大偏移量就可以采样到周围的信息：</p><div class="code-block" data-lang="glsl">
vec4 result;
for(int i = -2; i &lt;= 2; ++i) {
    for(int j = -2; j &lt;= 2; ++j) {
        vec2 uv_displaced = uv + vec2(i, j) * pixelSize;
        result = texture(colortex0, uv_displaced);
    }
}
</div><p id="-qc1isd_225">但是值得注意的是，我们这里每次循环采样都把结果给替换了，这样我们永远只能获取到最后一次采样的值，显然违背了初衷。</p><p id="-qc1isd_226">一个简单的方法是把所有的值累加起来，然后在循环外除以循环次数，这样就求到了平均颜色：</p><div class="code-block" data-lang="glsl">
vec4 result;
for(int i = -2; i &lt;= 2; ++i) {
    for(int j = -2; j &lt;= 2; ++j) {
        vec2 uv_displaced = uv + vec2(i, j) * pixelSize;
        result += texture(colortex0, uv_displaced);
    }
}
result /= 25.0; // 5*5 次采样
</div><p id="-qc1isd_228">现在让把这个值赋给我们的颜色试试：</p><figure id="-qc1isd_229"><img alt="deferred_blur.png" src="MGC_Docs/deferred_blur.png" title="deferred_blur.png" width="1282" height="752"></figure><p id="-qc1isd_230">和预期一样，画面被轻微模糊了！</p><p id="-qc1isd_231">还有一个值得注意的点是，边缘的像素偏移采样时由于超出了纹理边界，我们更期望它直接终止循环而不是继续采样。因此我们可以进行一些优化，当纹理坐标在范围外时直接跳过当前循环：</p><div class="code-block" data-lang="glsl">
if(max(uv_displaced.s, uv_displaced.t) &gt; 1.0 || min(uv_displaced.s, uv_displaced.t) &lt; 0.0) { continue; }
</div><p id="-qc1isd_233">这种边界检测我们会经常使用，因此我们也可以将它封装成函数：</p><div class="code-block" data-lang="glsl">
bool uv_OutBound(vec2 uv) {
    return (max(uv.s, uv.t) &gt; 1.0 || min(uv.s, uv.t) &lt; 0.0);
}
bool uv_OutBound(vec3 uv) {
    return (max(uv.s, max(uv.t, uv.p)) &gt; 1.0 || min(uv.s, min(uv.t, uv.p)) &lt; 0.0);
}
</div><p id="-qc1isd_235">你可能注意到我们这里重载了一个同名函数，这是因为 GL 支持三维纹理。由于 OptiFine 没有一维纹理，我们这里就不额外重载了。</p><p id="-qc1isd_236">由于采样数量不一，我们得动态地求平均值，因此还需要增加一个用于计数的变量，于是采样循环就变成了：</p><div class="code-block" data-lang="glsl">
vec4 result;
int count = 0;
for(int i = -2; i &lt;= 2; ++i) {
    for(int j = -2; j &lt;= 2; ++j) {
        vec2 uv_displaced = uv + vec2(i, j) * pixelSize;
        if(uv_OutBound(uv_displaced)) { continue; }
        result += texture(colortex0, uv_displaced);
        ++count;
    }
}
result /= float(count);
</div><p id="-qc1isd_238">最终效果应该是没什么差异的，但是节约了很多无效采样。</p><aside class="prompt" data-type="tip" data-title="" id="-qc1isd_239"><p id="-qc1isd_243">我们在这里使用的是矩形采样并平均求值，当半径扩大之后效果会很难看（你会在下一小节看到），更常见的做法是使用一个在采样时就保证最终的总权重和为 1 的权重函数，例如高斯（正态）分布函数。这种情况下由于权重固定，我们就应当将边界视为 <code class="code" id="-qc1isd_244">GL_CLAMP_TO_EDGE</code> 并进行界外采样，不可提前退出。</p></aside></section><section class="chapter"><h2 id="-qc1isd_9" data-toc="-qc1isd_9">宏命令</h2><p id="-qc1isd_245">不知道你有没有发现一个很烦人的事。假如由于模糊效果太轻微，我们现在试图扩大采样数，我们需要怎么做？</p><p id="-qc1isd_246">比如把每个方向从 5 次采样改成 7 次，我们需要把这两行改！四！次！</p><div class="code-comparer" id="-qc1isd_247" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="5 次采样">
for(int i = -2; i &lt;= 2; ++i) {
for(int j = -2; j &lt;= 2; ++j) {
</div><div class="code-block" data-lang="glsl" data-title="7 次采样">
for(int i = -3; i &lt;= 3; ++i) {
for(int j = -3; j &lt;= 3; ++j) {
</div></div><p id="-qc1isd_248">万一一不留神改漏一个，效果出现差错，这种合法的编程疏忽可没有编译器给你报错。</p><p id="-qc1isd_249">你应该已经注意到了，这几个值其实是相同的，那么我们有没有什么办法把它们一起修改呢？</p><p id="-qc1isd_250">答案就是<span class="control" id="-qc1isd_269">宏命令</span> 。和 C 一样，GLSL 也支持很多宏命令，其中用得最多、和 OptiFine 设置页面密切相关的就是 <code class="code" id="-qc1isd_270">#define</code>。</p><p id="-qc1isd_251">我们只需要在文件开头的版本宏下再添加一行</p><div class="code-block" data-lang="glsl">
#define BLUR_SAMPLES 2
</div><p id="-qc1isd_253">然后将采样循环中的相关量全部替换</p><div class="code-block" data-lang="glsl">
for(int i = -BLUR_SAMPLES; i &lt;= BLUR_SAMPLES; ++i) {
for(int j = -BLUR_SAMPLES; j &lt;= BLUR_SAMPLES; ++j) {
</div><p id="-qc1isd_255">就可以轻松更改采样数了。</p><p id="-qc1isd_256">现在让我们取每个方向 5 次模糊的较极端的值试试：</p><div class="code-block" data-lang="glsl">
#define BLUR_SAMPLES 5
</div><figure id="-qc1isd_258"><img alt="deferred_blur_large.png" src="MGC_Docs/deferred_blur_large.png" title="deferred_blur_large.png" width="1282" height="752"></figure><p id="-qc1isd_259">和预期一样，模糊的半径更大了！</p><p id="-qc1isd_260">除了 <code class="code" id="-qc1isd_271">#define</code> 和之前介绍过的 <code class="code" id="-qc1isd_272">#version</code> 外，GLSL 还支持下列 C 中的常见宏</p><div class="code-block" data-lang="glsl">
#undef &lt;macro&gt;          // 取消某个宏
#ifdef &lt;macro&gt;          // 如果定义了某个宏
#ifndef &lt;macro&gt;         // 如果没有定义某个宏
#if &lt;int&gt;               // 可以使用整型值（布尔值本质也是整型）进行判定是否包含直到 #else 类或 #endif 的内容
#if defined &lt;macro&gt;     // 如果定义了某个宏，当整个程序都使用 #if defined 而不使用 #ifdef 时不会写入光影设置
#if !defined &lt;macro&gt;    // 如果没有定义某个宏
#elif &lt;int&gt;             // 同条件判定 else if
#elif defined &lt;macro&gt;
#elif !defined &lt;macro&gt;
#else
#endif                  // #if 语句的结尾
</div><p id="-qc1isd_262">以及用以装载 GL 扩展的 <code class="code" id="-qc1isd_273">#extension</code> 和包含文件的 <code class="code" id="-qc1isd_274">#include</code>。</p><p id="-qc1isd_263">宏定义可以进行嵌套，可用在 <code class="code" id="-qc1isd_275">#if</code> 中使用逻辑运算符。</p><aside class="prompt" data-type="tip" data-title="" id="-qc1isd_264"><p id="-qc1isd_276"><code class="code" id="-qc1isd_277">#define</code> 除了可以替换值以外，还可以仅定义宏而不赋值，用作开关。</p></aside><p id="-qc1isd_266">好了，在这一章中，你已经学会了延迟处理最重要的纹理采样操作，并且封装了几个好用的函数，还认识了一下宏定义。那么在下一章，迎接几何缓冲之前，我们将会把工作区打扫干净，将文件结构整理得井井有条。</p></section><div class="last-modified">Last modified: 11 March 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="0-3-helloglsl.html" class="navigation-links__prev">初识 GLSL</a><a href="1-2-clearworkspace.html" class="navigation-links__next">整理工作区</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-21T09:02:39.248924861"><title>着色器 基本概念和轶事 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"here_sAnSimpleQuestion_whatIsShader","level":0,"title":"何谓着色器？","anchor":"#here_sAnSimpleQuestion_whatIsShader"},{"id":"haso9q_10","level":0,"title":"渲染模组／引擎如何帮助光影和游戏交流","anchor":"#haso9q_10"},{"id":"whatWasYourMissionInShader","level":0,"title":"场景在着色器中发生了什么？","anchor":"#whatWasYourMissionInShader"},{"id":"optifine","level":0,"title":"OptiFine 的发家史","anchor":"#optifine"},{"id":"haso9q_75","level":0,"title":"渲染龙和它光影朋友们的爱恨纠葛","anchor":"#haso9q_75"},{"id":"haso9q_115","level":0,"title":"附录：光影加载器圣经","anchor":"#haso9q_115"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="着色器 基本概念和轶事 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/测试版/shaderbasic.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="着色器 基本概念和轶事 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/测试版/shaderbasic.html#webpage",
    "url": "https://docs.minegraph.cn/md/测试版/shaderbasic.html",
    "name": "着色器 基本概念和轶事 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="shaderBasic" data-main-title="着色器 基本概念和轶事" data-article-props="{&quot;seeAlso&quot;:[{&quot;title&quot;:&quot;相关文档&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;terms.html#渲染模组和引擎&quot;,&quot;text&quot;:&quot;术语表 - 渲染模组和引擎&quot;,&quot;tooltip&quot;:&quot;总结了大多常用的渲染模组和引擎&quot;,&quot;description&quot;:&quot;总结了大多常用的渲染模组和引擎&quot;}]},{&quot;title&quot;:&quot;扩展阅读&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;shadertech.html&quot;,&quot;text&quot;:&quot;着色器 技术科普&quot;,&quot;tooltip&quot;:&quot;对着色器的具体技术的科普&quot;,&quot;description&quot;:&quot;对着色器的具体技术的科普&quot;}]}],&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Library.md|知识库///PopOfScience.md|科普文档"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs 测试版 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="shaderBasic" id="shaderBasic.md">着色器 基本概念和轶事</h1><aside class="prompt" data-type="warning" data-title="施工中" id="haso9q_2"><p id="haso9q_3">这篇文档正在添加新内容，可能无法流畅阅读。</p></aside><section class="chapter"><h2 id="here_sAnSimpleQuestion_whatIsShader" data-toc="here_sAnSimpleQuestion_whatIsShader">何谓着色器？</h2><p id="haso9q_4">对于一个完整的现代图形应用程序（基于如 OpenGL、Vulkan、DirectX 等图形库）来说，着色器是它渲染场景的手段。 <br> 我们知道图形应用程序的目的是读取模型文件或硬编码几何体，并在屏幕上绘制。着色器就描述了我们传入的几何体在屏幕上的<span class="control" id="haso9q_6">何种位置</span>以<span class="control" id="haso9q_7">何种方式</span>绘制。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_8"><p id="haso9q_9">光影是着色器的集合。</p></aside></section><section class="chapter"><h2 id="haso9q_10" data-toc="haso9q_10">渲染模组／引擎如何帮助光影和游戏交流</h2><p id="haso9q_11">渲染模组／引擎（下简称渲染模组）充当了游戏和光影的桥梁。由于原版所提供的信息极其有限（许多效果必须的变量没有直接提供），如果想仅利用原版资源包的着色器来编写光影，无异于自讨苦吃。 <br> 渲染模组利用模组加载器提供的 <a href="terms.html#应用程序接口" id="haso9q_13" data-tooltip="应用程序接口提供特定的方法，让第三方代码通过它们修改程序。">接口</a> 或直接对 Minecraft 源代码进行逆向工程并注入，接管了 Minecraft 的原版渲染管线，并提供了大量信息和更多 <a href="terms.html#缓冲区" id="haso9q_14" data-tooltip="存储图像的区域。">缓冲区</a> ，为光影开发提供便利。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_15"><p id="haso9q_16">一些渲染模组还修改了原本所使用的图形库，将 OpenGL 替换为了 Vulkan，如 <span class="control" id="haso9q_17">Vulkanite</span>。</p></aside></section><section class="chapter"><h2 id="whatWasYourMissionInShader" data-toc="whatWasYourMissionInShader">场景在着色器中发生了什么？</h2><section class="chapter"><h3 id="haso9q_18" data-toc="haso9q_18">着色器类型</h3><p id="haso9q_19">光影通常以多个着色器组成，着色器接收渲染模组提供的各种变量，以及先前乃至上一帧计算好的存入缓冲区的信息，按照程序进行计算后输出到指定的缓冲区。 <br> 不同渲染模组的工作原理不尽相同，所对应的光影包规格也有所区别。</p><p id="haso9q_21">一个着色器中又可以细分为多个阶段，也就是我们常说的顶点着色器、像素着色器等，这里按照通常管线的顺序，简单列举一下每种着色器计算的对象：</p><dl id="haso9q_22" data-style="title-top"><dt id="vs" data-expandable="false">顶点着色器</dt><dd><p id="haso9q_23"><span class="control" id="haso9q_24">Vertex Shader</span> ，它的主要职责是变换坐标，包括顶点坐标、纹理坐标等，也可以处理顶点的颜色，计算对象为每个顶点（逐顶点操作）。</p></dd><dt id="gs" data-expandable="false">几何着色器</dt><dd><p id="haso9q_25"><span class="control" id="haso9q_26">Geometry Shader</span> ，这个阶段是<span class="control" id="haso9q_27">可选的</span> ，它的主要职责是生成新的顶点，计算对象是每个图元，可以通过特定的索引值确定需要处理的顶点。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_28"><p id="haso9q_29">图元通常为点（一个顶点）、线条（两个顶点）或三角形（三个顶点）</p></aside></dd><dt id="fs" data-expandable="false">片段着色器</dt><dd><p id="haso9q_30"><span class="control" id="haso9q_31">Fragment Shader</span> ，它的主要职责是处理像素的颜色，也是大多数效果程序所处的位置，计算对象是每个像素。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_32"><p id="haso9q_33">根据它所计算的对象，我们也将其称为<span class="control" id="haso9q_34">像素着色器</span> （Pixel Shader）。</p></aside></dd><dt id="cs" data-expandable="false">计算着色器</dt><dd><p id="haso9q_35"><span class="control" id="haso9q_36">Compute Shader</span> ，这个阶段是<span class="control" id="haso9q_37">可选的</span> ，它负责进行抽象计算。可以任意存取 <a href="terms.html#缓冲区" id="haso9q_38" data-tooltip="存储图像的区域">缓冲区</a> ，但是不能传入自定义变量，也没有默认输出。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_39"><p id="haso9q_40">计算着色器使 GPU 可以像 CPU 一样做通用计算的工作。计算着色器使开发者可以更随性地写东西，例如基于计算着色器的光线追踪程序。</p></aside></dd></dl><p id="haso9q_41">当仅考虑顶点着色器和像素着色器时，在 <a href="#here_sAnSimpleQuestion_whatIsShader" id="haso9q_42" data-tooltip="何谓着色器">上文</a> 中我们所提到的所谓&ldquo; <span class="emphasis" id="haso9q_43">何种位置</span> &rdquo;大多数时候就在顶点着色器中进行处理，而以&ldquo; <span class="emphasis" id="haso9q_44">何种方式</span> &rdquo;则是顶点着色器和像素着色器的共同作用。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_45"><p id="haso9q_46">2018 年英伟达提出了 <a href="https://developer.nvidia.com/zh-cn/blog/introduction-turing-mesh-shaders/" id="haso9q_47" data-external="true" rel="noopener noreferrer">网格着色器（Mesh shader）</a> ，这让几何处理管线不再拘泥于传统的顶点着色器，拥有更强的可编程性和性能，这使得所有几何处理工作均可在 GPU 端完成，无需和 CPU 进行高延迟通信。它的本质是计算着色器。</p></aside></section><section class="chapter"><h3 id="renderingMethod" data-toc="renderingMethod">渲染方法的发展</h3><p id="haso9q_48">在计算机最早起步的阶段，还没有各种图形库和接口供开发者使用，那时候通常是通过准备特殊的图块字符映射表，然后将场景通过各种特殊的字符打印在屏幕上。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_49"><p id="haso9q_50">如果你曾经玩过任天堂 Famicom 游戏机，并且尝试过在游戏途中热拔出卡带，那么你一定见过这种场景：</p><figure id="haso9q_51"><img alt="热插拔游戏卡带" src="MGC_Docs/famicom_glitch.png" class="article__bordered-element--rounded" title="热插拔游戏卡带" width="1204" height="896"></figure><p id="haso9q_52">这种情况就是数据出错导致的图块映射错误。</p></aside><p id="haso9q_53">随着计算机和 GPU 发展，各种图形库开始发展起来，OpenGL 就是其中之一。最早的图形库使用<span class="control" id="haso9q_54">固定渲染管线</span> （例如顶点光照、阴影等），开发者只可以配置渲染参数，没法精细控制每个几何体的效果，也没法自定义如何处理每个像素。</p><p id="haso9q_55">由于固定管线只能提供固定的效果，希望能更自由地开发的呼声越来越高， <span class="control" id="haso9q_56">可编程管线</span>应运而生。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_57"><p id="haso9q_58">如果将固定管线比作客观题（选择、填空），那么可编程管线就是主观题（简答、作文）。</p></aside><p id="向前渲染法">在可编程管线刚刚发展起来的早期图形程序中，渲染思想是将一类几何体全部准备好并传入特定着色器，然后立即在传入的几何体上计算诸如阴影和反射等效果，再输出到屏幕上。这就是我们现在所说的<b id="haso9q_59">向前渲染法</b>。</p><p id="haso9q_60">这在早期是没什么问题的，那时候 3D 程序处于早期阶段。然而随着场景几何体增多、几何体之间相对于视角的遮挡越来越频繁，这种做法开始产生越来越多不必要的开销。因为每个着色器都会将所有传入的几何体计算一遍，即使在之前或之后的着色器中这个几何体会被更靠前的几何体遮挡。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_61"><p id="haso9q_62">在现代 GPU 中，有一种名为<span class="control" id="haso9q_63">提前深度测试</span> （Early Depth Testing）的功能，可以在 GPU 上预先判断场景的几何遮挡情况，在着色器开始处理之前先丢弃将会或已经被遮挡的像素。</p></aside><p id="延迟渲染法">出于上述原因， <b id="haso9q_64">延迟渲染法</b>应运而生，它的思想是不再在传入几何体的阶段立即计算大多数效果，而是分为两个阶段：</p><ol class="list _decimal" id="haso9q_65" type="1"><li class="list__item" id="haso9q_66"><p><a href="terms.html#几何缓冲" id="haso9q_67" data-tooltip="着色器传入的顶点数据是场景中实际的几何体，接受所有原始纹理的传入，并将其映射到几何体上。">几何缓冲阶段</a> ：通过着色器将纯色场景和诸如法线贴图和反射贴图等<span class="control" id="haso9q_68">全部作为纹理</span>映射到几何体上，再分别写入多个缓冲区，并通过 <a href="terms.html#颜色附件" id="haso9q_69" data-tooltip="负责着色器间传递数据的对象">颜色附件</a> 在着色器之间进行传递，这就是所谓的；</p></li><li class="list__item" id="haso9q_70"><p><a href="terms.html#延迟处理" id="haso9q_71" data-tooltip="着色器从缓冲区中读取信息，并将计算结果绘制到铺屏四边形上。">延迟处理阶段</a> ：之后的着色器读取对应缓冲区的这些信息，在<span class="control" id="haso9q_72">铺屏四边形</span>上统一计算光照、反射等其他效果。</p></li></ol></section></section><section class="chapter"><h2 id="optifine" data-toc="optifine">OptiFine 的发家史</h2><p id="haso9q_73"><span class="emphasis" id="haso9q_74">TODO</span></p></section><section class="chapter"><h2 id="haso9q_75" data-toc="haso9q_75">渲染龙和它光影朋友们的爱恨纠葛</h2><p id="haso9q_76">最早的基岩版光影基于 OpenGL ES 的 GLSL 或 DirectX 的 HLSL <sup class="superscript" id="haso9q_77">Windows／XBox</sup> 。由于接口限制，基岩版光影可以实现的效果非常少（甚至比 <span class="control" id="haso9q_78">JE 1.16</span> 之后的原版资源包着色器还少），并且为 <a href="terms.html#向前渲染法" id="haso9q_79" data-tooltip="在每个着色器中，立即在传入的几何体上计算诸如阴影和反射等效果。">向前渲染管线</a> ，但仍可以通过一系列奇技淫巧实现基于物理的渲染。</p><p id="haso9q_80">然而在渲染龙实装后很长一段时间里，光影作者们都面临着各种问题：</p><ul class="list _bullet" id="haso9q_81"><li class="list__item" id="haso9q_82"><p id="haso9q_83">渲染龙已覆盖到了各种 PC、移动设备及主机的基岩版上，替代了原本的渲染方案，而基于原始方案的第三方着色器也受到了牵连，直接导致了第三方光影集体灭绝。</p><ul class="list _bullet" id="haso9q_84"><li class="list__item" id="haso9q_85"><p><span class="control" id="haso9q_86">理想情况下</span> ，Windows 版本能够通过其调用 <span class="control" id="haso9q_87">RTX 2000</span> <sup class="superscript" id="haso9q_88">Nvidia</sup>／ <span class="control" id="haso9q_89">RX 6000</span> <sup class="superscript" id="haso9q_90">AMD</sup>　／ <span class="control" id="haso9q_91">Arc</span> <sup class="superscript" id="haso9q_92">Intel</sup> 系列及以上显卡的光线追踪加速单元以提升光线追踪的效率，而其他平台上其则能够起到优化作用。</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="haso9q_93"><p id="haso9q_94">意外的是，渲染龙一开始是给 Java 版设计的，而目前只在基岩版中起到了负优化作用。XBox 版本在渲染龙推出之初就已经有带有光线追踪的预览版，而在这之后也被移除了。</p></aside></li><li class="list__item" id="haso9q_95"><p id="haso9q_96">渲染龙的算法加密破坏了很多东西，除了光影还有例如区块显示、红石能量显示、亮度显示、夜视、透视、小地图这些原本都能由第三方光影实现的功能。而它们的消失给一些玩家带来了不少困扰。</p></li><li class="list__item" id="haso9q_97"><p id="haso9q_98">官方光追虽然在准确性上力压 Java 版一头，但其主要得益于 <span class="control" id="haso9q_99">DirectX RayTracing</span> ，在代码质量和细节调校上做的并不尽如人意，也对主打写实风格的地图与纹理创作者造成了很大困扰。</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="haso9q_100"><p id="haso9q_101">官方光追很大一部分是<a href="https://b23.tv/BV1614y1b7cp?t=706.6" id="haso9q_102" data-tooltip="Bilibili《渲染龙被破解了，于是我们深挖了它的前世今生……》11:47" data-external="true" rel="noopener noreferrer">实习生面向论坛编程的产物，其代码质量极其低下</a>。 <br> 五星社区创作家<span class="emphasis" id="haso9q_104">茶匙</span>对此评价到：英伟达这样写着色器代码，怕是脸都不要了。</p></aside><p id="haso9q_105">这些也是渲染龙在开发者群体内风评不佳的原因。</p><p id="haso9q_106">在此之后，渲染龙虽被成功破解，但由于破解团队收到微软的 DMCA 致函，以及新的光影编写方法过于麻烦，基岩版光影仍然沉寂。</p><ul class="list _bullet" id="haso9q_107"><li class="list__item" id="haso9q_108"><p>当时编写光影需反编译游戏后进行编辑，再将特定文件回编译并放到固定文件夹替换相关文件，然后重启游戏。</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="haso9q_109"><p id="haso9q_110">DMCA 致函是一种版权警告，当时团队将代码上传到了 Github，被致函删库。</p></aside><p id="haso9q_111">不过事情在 2023 年迎来了转机。基岩版在这年 7 月发布了 <a href="terms.html#延迟渲染法" id="haso9q_112" data-tooltip="将场景的各种信息存储起来，再在之后的着色器中统一计算。">延迟渲染</a> 更新，提供了各种接口和信息。久旱逢甘霖，基岩版光影自此开始进入了新的时代。</p><aside class="prompt" data-type="tip" data-title="" id="haso9q_113"><p id="haso9q_114">网易的延迟处理接口来得要比渲染龙更早，自由度也相对当时的渲染龙更高，在很长一段时间里，网易版的光影繁荣程度一度超过了国际版。</p></aside></section><section class="chapter"><h2 id="haso9q_115" data-toc="haso9q_115">附录：光影加载器圣经</h2><p id="haso9q_116">关于光影加载器我有四不用。</p><ul class="list _bullet" id="haso9q_117"><li class="list__item" id="haso9q_118"><p>第一，不用 Oculus，因为它善。别人都是要么给模组开发者史吃，要么给光影材质开发者史吃，它干脆大发慈悲让所有人都雨露均沾。</p></li><li class="list__item" id="haso9q_119"><p>第二，不用 Iris，因为它孝。从三年前号称接管 OptiFine 所有光影，到现在这嫌代码侵权那嫌光影太旧，推出自己的独占接口吸引 OptiFine 的开发者过来，最后发现吖到了一大口史。</p></li><li class="list__item" id="haso9q_120"><p>第三，不用 Canvas，因为它贞。Canvas 的初心是给模组提供渲染 API，在上面开发光影 = NTR，要被浸猪笼后烧死。</p></li><li class="list__item" id="haso9q_121"><p>第四，不用 OptiFine，因为它忠。一直以来，高清修复对内都为光影材质提供了一个稳定的开发环境，对外从来不在乎模组兼容性，对自己人不可谓不忠诚。</p></li></ul></section><div class="last-modified">Last modified: 21 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="resourcepackbasic.html" class="navigation-links__prev">资源包 基本概念</a><a href="shadertech.html" class="navigation-links__next">着色器 技术科普</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
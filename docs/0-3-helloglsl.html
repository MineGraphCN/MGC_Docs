<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-26T07:17:16.395576333"><title>初识 GLSL | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"z7xu5yj_5","level":0,"title":"从一个程序开始","anchor":"#z7xu5yj_5"},{"id":"glsl-opengl","level":0,"title":"GLSL 和 OpenGL 的版本对应关系","anchor":"#glsl-opengl"},{"id":"core-compatibility","level":0,"title":"core 还是 compatibility ？","anchor":"#core-compatibility"},{"id":"z7xu5yj_8","level":0,"title":"语法糖","anchor":"#z7xu5yj_8"},{"id":"z7xu5yj_196","level":1,"title":"简化构造向量和矩阵","anchor":"#z7xu5yj_196"},{"id":"z7xu5yj_197","level":1,"title":"操作分量","anchor":"#z7xu5yj_197"},{"id":"z7xu5yj_198","level":1,"title":"向量和矩阵乘法","anchor":"#z7xu5yj_198"},{"id":"z7xu5yj_199","level":1,"title":"类型转换函数","anchor":"#z7xu5yj_199"},{"id":"z7xu5yj_200","level":1,"title":"数组和结构体初始化函数","anchor":"#z7xu5yj_200"},{"id":"z7xu5yj_201","level":1,"title":"编译时计算常量","anchor":"#z7xu5yj_201"},{"id":"z7xu5yj_202","level":1,"title":"内建函数","anchor":"#z7xu5yj_202"},{"id":"z7xu5yj_203","level":1,"title":"函数重载","anchor":"#z7xu5yj_203"},{"id":"z7xu5yj_204","level":1,"title":"类型","anchor":"#z7xu5yj_204"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="初识 GLSL | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/0-3-helloglsl.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="初识 GLSL | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/0-3-helloglsl.html#webpage",
    "url": "https://docs.minegraph.cn/md/0-3-helloglsl.html",
    "name": "初识 GLSL | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="0-3-helloGlsl" data-main-title="初识 GLSL" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Developer.md|创作者文档///shaderTutorial.md|光影开发教程///创作之前"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="0-3-helloGlsl" id="0-3-helloGlsl.md">初识 GLSL</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;z7xu5yj_9\&quot;\u003e本节介绍 GLSL 的基础语法和版本配置。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="z7xu5yj_5" data-toc="z7xu5yj_5">从一个程序开始</h2><p id="z7xu5yj_10">在进入正式的创作之前，我们先来简单了解一下 GLSL 的相关语法。</p><p id="z7xu5yj_11">GLSL 使用类似 C 的语法，但是它也包含了一些其他特性。现在，让我们从一个包含了顶点和片段部分的简单着色器开始来认识一下它们。</p><p id="z7xu5yj_12">先从顶点部分开始：</p><div class="code-block" data-lang="glsl">
#version 330 core

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 vaPosition;
in vec3 vaColor;

out vec3 vColor;

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(vaPosition, 1.0);
    vColor = vaColor;
}
</div><p id="z7xu5yj_14">文件开头一行的</p><div class="code-block" data-lang="glsl">
#version 330 core
</div><p id="z7xu5yj_16">指定了着色器所使用的 GLSL 版本和配置。 <code class="code" id="z7xu5yj_45">#version</code> 就是所谓的<span class="control" id="z7xu5yj_46">宏命令</span> ，我们将在之后的章节具体介绍。其中 <code class="code" id="z7xu5yj_47">330</code> 表示使用 3.30 的 GLSL，对应 OpenGL 3.3.0；而 <code class="code" id="z7xu5yj_48">core</code> 则表示我们使用核心配置。在本教程中，若无必要，我们都将使用这个版本，它包含大多数现代特性，不会过于老旧，还能在一些有点年头的设备上运行。</p><aside class="prompt" data-type="note" data-title="" id="z7xu5yj_17"><p id="z7xu5yj_49">当没有声明版本时，一些平台会指定以硬件最高 GL 版本运行，而另一些则会以最低版本，这本质上是一个未定义行为，不要这样做。</p></aside><p id="z7xu5yj_18">接着的两行以 <code class="code" id="z7xu5yj_50">uniform</code> 开头的语句</p><div class="code-block" data-lang="glsl">
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
</div><p id="z7xu5yj_20">声明了从 OpenGL 上下文传入 GLSL 着色器的统一变量， <span class="control" id="z7xu5yj_51">不可以在着色器内被修改</span> 。在这里，它们传入的变量类型是 <code class="code" id="z7xu5yj_52">mat4</code> ，表示这是一个 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="5.028ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 2222.4 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(1722.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container> 的矩阵 <span id="z7xu5yj_54"><sup class="superscript"><span class="control" id="z7xu5yj_55"><a href="#note1-1" id="z7xu5yj_56" data-tooltip="有关这些矩阵和坐标的相关内容，我们将在几何缓冲章节详细介绍。">1</a></span></sup></span>。</p><aside class="prompt" data-type="tip" data-title="" id="z7xu5yj_21"><p id="z7xu5yj_57">OpenGL 上下文（Context）即 OpenGL 程序，我们编写的&ldquo;着色器&rdquo;是其运行时所调用的用以指导绘制场景的程序，在 OptiFine 管线中我们无法访问。</p></aside><aside class="prompt" data-type="warning" data-title="注意" id="z7xu5yj_22"><p id="z7xu5yj_58"><code class="code" id="z7xu5yj_60">uniform</code> 不可以使用逗号进行连续声明，这可能导致变量不进行初始化！</p><div class="code-block" data-lang="glsl">
uniform mat4 modelViewMatrix, projectionMatrix; // 不要这样做！
</div></aside><p id="z7xu5yj_23">紧跟着的 <code class="code" id="z7xu5yj_61">in</code> 和 <code class="code" id="z7xu5yj_62">out</code> 开头的语句</p><div class="code-block" data-lang="glsl">
in vec3 vaPosition;
in vec3 vaColor;

out vec3 vColor;
</div><p id="z7xu5yj_25">定义了传入变量和传出变量。对于顶点着色器来说， <code class="code" id="z7xu5yj_63">in</code> 类型的变量是<span class="control" id="z7xu5yj_64">顶点属性</span>， <code class="code" id="z7xu5yj_65">out</code> 的变量可以被几何着色器或片段着色器接受。 <code class="code" id="z7xu5yj_66">in</code> 的变量不可更改，在传出时对应的变量会在每个顶点之间进行<span class="control" id="z7xu5yj_67">插值</span>使其平滑过渡。其中， <code class="code" id="z7xu5yj_68">vaPosition</code> 是顶点的<span class="control" id="z7xu5yj_69">局部坐标</span> <span id="z7xu5yj_70"><sup class="superscript"><span class="control" id="z7xu5yj_73"><a href="#note1-1" id="z7xu5yj_74" data-tooltip="有关这些矩阵和坐标的相关内容，我们将在几何缓冲章节详细介绍。">1</a></span></sup></span>， <code class="code" id="z7xu5yj_71">vaColor</code> 是顶点的<span class="control" id="z7xu5yj_72">颜色</span>。</p><aside class="prompt" data-type="tip" data-title="" id="z7xu5yj_26"><p id="z7xu5yj_75">若想禁用插值，我们只需要在 <code class="code" id="z7xu5yj_76">in</code> 和 <code class="code" id="z7xu5yj_77">out</code> 前加上 <code class="code" id="z7xu5yj_78">flat</code>。</p></aside><aside class="prompt" data-type="tip" data-title="" id="z7xu5yj_27"><p id="z7xu5yj_79">有关统一变量和顶点属性的区别：统一变量在当前着色器中不会随着顶点和像素的位置不同而变化，而顶点属性则是每个顶点特有的信息。</p></aside><p id="z7xu5yj_28">和 C 一样，GLSL 执行时从 <code class="code" id="z7xu5yj_80">main</code> 函数开始，但是它必须是 <code class="code" id="z7xu5yj_81">void</code> 类型，也不接受任何输入。</p><p id="z7xu5yj_29">代码中以 <code class="code" id="z7xu5yj_82">gl_</code> 开头的变量都是 GLSL 的<span class="control" id="z7xu5yj_83">内建变量</span>， <code class="code" id="z7xu5yj_84">gl_Position</code> 表示顶点的最终位置。主函数的第一行</p><div class="code-block" data-lang="glsl">
gl_Position = projectionMatrix * modelViewMatrix * vec4(vaPosition, 1.0);
</div><p id="z7xu5yj_31">将传入的 <code class="code" id="z7xu5yj_85">vaPosition</code> 转换为四维向量，并将多出来的第四分量赋上 <code class="code" id="z7xu5yj_86">1.0</code> ，然后和传入的两个矩阵相乘，并赋值给了 <code class="code" id="z7xu5yj_87">gl_Position</code> ，OpenGL 期望这个值落在坐标区间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.287ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2778.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2000.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2500.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 的投影空间 <span id="z7xu5yj_89"><sup class="superscript"><span class="control" id="z7xu5yj_90"><a href="#note1-1" id="z7xu5yj_91" data-tooltip="有关这些矩阵和坐标的相关内容，我们将在几何缓冲章节详细介绍。">1</a></span></sup></span> 里，以便进行裁切。</p><p id="z7xu5yj_32">GLSL 要求在顶点着色器中必须对 <code class="code" id="z7xu5yj_92">gl_Position</code> 进行操作。</p><p id="z7xu5yj_33">最后，我们将顶点的颜色属性 <code class="code" id="z7xu5yj_93">vaColor</code> 赋值给传出变量 <code class="code" id="z7xu5yj_94">vColor</code> ，这样做的原因是 <code class="code" id="z7xu5yj_95">in</code> 的变量无法直接 <code class="code" id="z7xu5yj_96">out</code>。</p><p id="note1-1"></p><p id="z7xu5yj_35"><span class="control" id="z7xu5yj_97">[1]</span> 有关这些矩阵和坐标的相关内容，我们将在几何缓冲章节详细介绍。</p><p id="z7xu5yj_36">顶点着色器程序会在每个顶点上都运行一次。</p><p id="z7xu5yj_37">接着是片段着色器：</p><div class="code-block" data-lang="glsl">
#version 330 core

in vec3 vColor;

out vec4 fragColor;

void main() {
    fragColor = vec4(vColor, 1.0);
}
</div><p id="z7xu5yj_39">和顶点着色器一样，片段着色器也需要声明 GLSL 版本。然后我们将顶点着色器传出的变量 <code class="code" id="z7xu5yj_98">vColor</code> 传入，注意保证类型和变量名的一致。</p><p id="z7xu5yj_40">接着我们定义了一个 <code class="code" id="z7xu5yj_99">out</code> ，在片段着色器中， <code class="code" id="z7xu5yj_100">out</code> 的变量直接输出当前像素的颜色到缓冲区上。</p><aside class="prompt" data-type="tip" data-title="" id="z7xu5yj_41"><p id="z7xu5yj_101">如果你想在 <code class="code" id="z7xu5yj_102">compatibility</code> 配置下直接输出，可以使用 <code class="code" id="z7xu5yj_103">gl_FragColor</code> 或者 <code class="code" id="z7xu5yj_104">gl_FragData[]</code> （多个缓冲区）。</p></aside><p id="z7xu5yj_42">最后，在主函数中，我们给输出变量赋上了顶点颜色。GL 默认会期望我们输出的颜色值在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.526ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 上（不考虑 HDR）并约束最大值，最后在输出到屏幕上时自动将其转换为 8 位的像素颜色（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.789ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3000.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(2722.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>）</p><p id="z7xu5yj_43">片段着色器会在每个图元覆盖的每个像素上都执行一次。</p><p id="z7xu5yj_44">这样，整个着色器流程就大致结束了。</p></section><section class="chapter"><h2 id="glsl-opengl" data-toc="glsl-opengl">GLSL 和 OpenGL 的版本对应关系</h2><p id="z7xu5yj_107">GLSL 版本与 OpenGL 密切相关，如果平台支持的 OpenGL 版本过低，则无法使用高版本的 GLSL 和它们的新特性。</p><div class="table-wrapper"><table class="wide" id="z7xu5yj_108" width="800"><thead><tr class="ijRowHead" id="z7xu5yj_109"><th id="z7xu5yj_122"><p>GLSL</p></th><th id="z7xu5yj_123"><p>GL</p></th><th id="z7xu5yj_124"><p>变动</p></th></tr></thead><tbody><tr id="z7xu5yj_110"><td id="z7xu5yj_125"><p>110</p></td><td id="z7xu5yj_126"><p>2.0</p></td><td id="z7xu5yj_127"><p>基本功能，支持顶点和片段着色器。</p></td></tr><tr id="z7xu5yj_111"><td id="z7xu5yj_128"><p>120</p></td><td id="z7xu5yj_129"><p>2.1</p></td><td id="z7xu5yj_130"><p>引入 <code class="code" id="z7xu5yj_131">gl_FragColor</code> 和 <code class="code" id="z7xu5yj_132">gl_FragData[]</code>。</p></td></tr><tr id="z7xu5yj_112"><td id="z7xu5yj_133"><p>130</p></td><td id="z7xu5yj_134"><p>3.0</p></td><td id="z7xu5yj_135"><p>移除 <code class="code" id="z7xu5yj_136">attribute</code> 和 <code class="code" id="z7xu5yj_137">varying</code> ，引入 <code class="code" id="z7xu5yj_138">in</code> 和 <code class="code" id="z7xu5yj_139">out</code>。</p></td></tr><tr id="z7xu5yj_113"><td id="z7xu5yj_140"><p>140</p></td><td id="z7xu5yj_141"><p>3.1</p></td><td id="z7xu5yj_142"><p>支持整数和位运算。</p></td></tr><tr id="z7xu5yj_114"><td id="z7xu5yj_143"><p>150</p></td><td id="z7xu5yj_144"><p>3.2</p></td><td id="z7xu5yj_145"><p>引入几何着色器（Geometry Shader）。</p></td></tr><tr id="z7xu5yj_115"><td id="z7xu5yj_146"><p>330</p></td><td id="z7xu5yj_147"><p>3.3</p></td><td id="z7xu5yj_148"><p>引入核心模式，移除固定功能管线。</p></td></tr><tr id="z7xu5yj_116"><td id="z7xu5yj_149"><p>400</p></td><td id="z7xu5yj_150"><p>4.0</p></td><td id="z7xu5yj_151"><p>引入细分着色器（Tessellation Shader）。</p></td></tr><tr id="z7xu5yj_117"><td id="z7xu5yj_152"><p>410</p></td><td id="z7xu5yj_153"><p>4.1</p></td><td id="z7xu5yj_154"><p>支持显式顶点属性位置（<code class="code" id="z7xu5yj_155">layout(location = ...)</code>）。</p></td></tr><tr id="z7xu5yj_118"><td id="z7xu5yj_156"><p>420</p></td><td id="z7xu5yj_157"><p>4.2</p></td><td id="z7xu5yj_158"><p>支持图像加载/存储（Image Load/Store），可以对非向量进行 Swizzle 操作。</p></td></tr><tr id="z7xu5yj_119"><td id="z7xu5yj_159"><p>430</p></td><td id="z7xu5yj_160"><p>4.3</p></td><td id="z7xu5yj_161"><p>引入计算着色器（Compute Shader）。</p></td></tr><tr id="z7xu5yj_120"><td id="z7xu5yj_162"><p>440</p></td><td id="z7xu5yj_163"><p>4.4</p></td><td id="z7xu5yj_164"><p>支持显式绑定点（Explicit Binding Points）。</p></td></tr><tr id="z7xu5yj_121"><td id="z7xu5yj_165"><p>450</p></td><td id="z7xu5yj_166"><p>4.5</p></td><td id="z7xu5yj_167"><p>支持直接状态访问（Direct State Access）。</p></td></tr></tbody></table></div></section><section class="chapter"><h2 id="core-compatibility" data-toc="core-compatibility"><code class="code" id="z7xu5yj_178">core</code> 还是 <code class="code" id="z7xu5yj_179">compatibility</code>？</h2><p id="z7xu5yj_169">在定义 <code class="code" id="z7xu5yj_180">#version</code> 时，我们可以在版本号后选择 <code class="code" id="z7xu5yj_181">core</code> 和 <code class="code" id="z7xu5yj_182">compatibility</code>。</p><p id="z7xu5yj_170">使用 <code class="code" id="z7xu5yj_183">core</code> 会完全禁用固定管线，同时大多数变量都需要用户在 OpenGL 上下文中显式提供，像我们之前的顶点着色器程序中的</p><div class="code-block" data-lang="glsl">
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
</div><p id="z7xu5yj_172">就在干这个事情。同时，大多数 <code class="code" id="z7xu5yj_184">gl_</code> 开头的内建变量都将被禁用，因为它们都来自固定管线。有关内建变量，参阅 <a href="a02-corebuiltinvars.html" id="z7xu5yj_185" data-tooltip="在 core 配置中，大多数以 gl_ 为前缀的内置变量（如 gl_ModelViewMatrix、gl_Vertex 等）已被移除，因为它们与固定功能管线紧密相关。">核心配置中可用的内建变量</a></p><p id="z7xu5yj_173">若你选择了 <code class="code" id="z7xu5yj_186">compatibility</code> 配置，可以直接使用 <code class="code" id="z7xu5yj_187">gl_ModelViewMatrix</code> 和 <code class="code" id="z7xu5yj_188">gl_ProjectionMartix</code> ，甚至 <code class="code" id="z7xu5yj_189">vec4(vaPosition, 1.0)</code> 也可以直接用 <code class="code" id="z7xu5yj_190">gl_Vertex</code> 代替：</p><div class="code-block" data-lang="glsl">
gl_Position = gl_ProjectionMartix * gl_ModelViewMatrix * gl_Vertex;
</div><p id="z7xu5yj_175">你甚至直接使用 <code class="code" id="z7xu5yj_191">ftransform()</code> 函数直接替换这一串乘法。</p><p id="z7xu5yj_176">但是由于这些内容都在固定管线中进行，我们对其的掌控能力较弱，而且会造成一些不必要的开销。OptiFine 给我们提供了完整的信息，所以我们最好是使用 <code class="code" id="z7xu5yj_192">core</code> 配置，不过这需要 <span class="control" id="z7xu5yj_193">JE 1.17</span> 及之后的 OptiFine 版本。</p><p id="z7xu5yj_177">除了上述两个配置以外，我们还可以选择 <code class="code" id="z7xu5yj_194">es</code> ，这是嵌入式和移动平台的 OpenGL ES 兼容配置，它精简了大量特性以换取高能效，但是对桌面平台用处不大，在此我们不做讨论。</p></section><section class="chapter"><h2 id="z7xu5yj_8" data-toc="z7xu5yj_8">语法糖</h2><p id="z7xu5yj_195">GLSL 支持一些 C 中不可用的便利语法，可以帮助我们更快捷地编程。</p><section class="chapter"><h3 id="z7xu5yj_196" data-toc="z7xu5yj_196">简化构造向量和矩阵</h3><p id="z7xu5yj_205">GLSL 允许在构造向量和矩阵时使用标量直接构造，或者在构造时混合使用标量、矢量和矩阵。</p><div class="code-comparer" id="z7xu5yj_206" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="构造向量">
vec3(1.0);
vec4(vec3(0.5), 1.0);
</div><div class="code-block" data-lang="glsl" data-title="等效向量">
vec3(1.0, 1.0, 1.0);
vec4(0.5, 0.5, 0.5, 1.0);
</div></div><div class="code-comparer" id="z7xu5yj_207" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="构造矩阵">
mat3(1.0);


mat2(vec2(1.0), vec2(2.0));
</div><div class="code-block" data-lang="glsl" data-title="等效矩阵">
mat3(1.0, 1.0, 1.0
     1.0, 1.0, 1.0
     1.0, 1.0, 1.0);
mat2(1.0, 1.0,
     2.0, 2.0);
</div></div><p id="z7xu5yj_208">同时，GLSL 还允许简化构造对角矩阵。</p><div class="code-comparer" id="z7xu5yj_209" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="构造矩阵">
mat3(1.2, 0.6, 0.3);
</div><div class="code-block" data-lang="glsl" data-title="等效矩阵">
mat3(1.2, 0.0, 0.0,
     0.0, 0.6, 0.0, 
     0.0, 0.0, 0.3);
</div></div><p id="z7xu5yj_210">以及将高维向量的额外维度丢弃并转化为低维向量。</p><div class="code-comparer" id="z7xu5yj_211" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="构造向量">
vec2(vec3(1.0, 2.0, 3.0));
</div><div class="code-block" data-lang="glsl" data-title="等效向量">
vec2(1.0, 2.0);
</div></div></section><section class="chapter"><h3 id="z7xu5yj_197" data-toc="z7xu5yj_197">操作分量</h3><p id="z7xu5yj_220">GLSL 允许 Swizzle 式和数组式提取分量。</p><div class="code-comparer" id="z7xu5yj_221" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="变量">
vec3 V = vec4(1.0, 2.0, 3.0);

mat3 M = mat3(1.0, 2.0, 3.0);


float N = 2.5;
</div><div class="code-block" data-lang="glsl" data-title="取值">
V.x  -&gt; 1.0
V.bgb -&gt; vec3(3.0, 2.0, 3.0)
M[0] -&gt; vec3(1.0, 0.0, 0.0)
M[1].y -&gt; 2.0
M[2][2] -&gt; 3.0
N.sss -&gt; vec3(2.5) == vec3(N) // 需要 #version 420 及以上
</div></div><p id="z7xu5yj_222">可以使用 <code class="code" id="z7xu5yj_227">xyzw</code>、 <code class="code" id="z7xu5yj_228">rgba</code> 和 <code class="code" id="z7xu5yj_229">stpq</code> 中的任意一组进行 Swizzle 操作，但是不能在同一个操作中混用。它们的语义通常分别表示<span class="control" id="z7xu5yj_230">空间坐标</span>、 <span class="control" id="z7xu5yj_231">颜色</span>和<span class="control" id="z7xu5yj_232">纹理坐标</span> ，正确地选择后缀组可以降低代码的阅读和维护门槛。</p><aside class="prompt" data-type="warning" data-title="" id="z7xu5yj_223"><p id="z7xu5yj_233">GL 不允许在构造函数时混用 Swizzle 和其他方法</p><div class="code-block" data-lang="glsl">
float a = 1.0;
vec4 b = vec4(a.xxx, 0.0); // 不可以这样做
</div></aside><aside class="prompt" data-type="tip" data-title="" id="z7xu5yj_224"><p id="z7xu5yj_235">Swizzle 原意鸡尾酒<span id="z7xu5yj_236"><span class="text-line-through">谁家狂乱鸡尾酒</span></span> ，在这里意为重新排列（就像调酒那样），因此 <span class="emphasis" id="z7xu5yj_237">Swizzle 操作</span> 也可称为 <span class="emphasis" id="z7xu5yj_238">重排操作</span>。</p></aside></section><section class="chapter"><h3 id="z7xu5yj_198" data-toc="z7xu5yj_198">向量和矩阵乘法</h3><p id="z7xu5yj_239">向量与矩阵、矩阵与矩阵之间的乘法可以直接使用 <code class="code" id="z7xu5yj_243">*</code> 进行运算，但是向量与向量、向量与标量之间使用 <code class="code" id="z7xu5yj_244">*</code> 时默认进行四则运算。</p><div class="code-block" data-lang="glsl">
vec4 &lt;- mat4 * vec4
mat4 &lt;- mat4 * mat4
vec4 &lt;- vec4 * float == float * vec4
vec4 &lt;- vec4 * vec4
</div><p id="z7xu5yj_241">若想进行向量间的点乘或叉乘，可以使用 <code class="code" id="z7xu5yj_245">dot()</code> 和 <code class="code" id="z7xu5yj_246">cross()</code></p><div class="code-block" data-lang="glsl">
float &lt;- dot(vec4, vec4)
vec4  &lt;- cross(vec4, vec4)
</div></section><section class="chapter"><h3 id="z7xu5yj_199" data-toc="z7xu5yj_199">类型转换函数</h3><p id="z7xu5yj_247">GLSL <span class="control" id="z7xu5yj_251">不支持</span> C 式类型转换，转而使用类型函数进行转换。</p><div class="code-comparer" id="z7xu5yj_248" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="GLSL">
int a = 0;
float b = float(a);
</div><div class="code-block" data-lang="c" data-title="C">
int a = 0;
float b = (float)a;
</div></div><p id="z7xu5yj_249">也可以将标量直接转换到向量：</p><div class="code-block" data-lang="glsl">
float f = 1.0;
vec4 v = vec4(f);
</div></section><section class="chapter"><h3 id="z7xu5yj_200" data-toc="z7xu5yj_200">数组和结构体初始化函数</h3><p id="z7xu5yj_254">GLSL 支持直接使用结构体名和数组类型函数进行初始化。</p><div class="code-block" data-lang="glsl">
float arr[3] = float[3](1.0, 2.0, 3.0);

struct Light {
    vec3 position;
    vec3 color;
};
Light light = Light(vec3(0.0), vec3(1.0));
</div></section><section class="chapter"><h3 id="z7xu5yj_201" data-toc="z7xu5yj_201">编译时计算常量</h3><p id="z7xu5yj_256">GLSL 支持在编译时计算常量表达式和函数以节省运行时性能。</p><div class="code-comparer" id="z7xu5yj_257" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="运行时计算">
const float f(float x);

float Pi = 3.14159265;
float HalfPi = Pi * 0.5;
float t = f(HalfPi);
</div><div class="code-block" data-lang="glsl" data-title="编译时计算">
const float f(float x);

const float Pi = 3.14159265;
const float HalfPi = Pi * 0.5;
const float t = f(HalfPi);
</div></div><p id="z7xu5yj_258">若向常量函数传入变量，该函数会自动降级为运行时计算；若函数的参数显式声明了常量，传入变量将会报错。</p><p id="z7xu5yj_259">将下列函数和变量两两组合时：</p><div class="code-block" data-lang="glsl">
const float f(float x);
float g(const float x);
const float h(const float x);

const float c;
float v;
</div><p id="z7xu5yj_261">对应函数调用的返回结果为：</p><div class="code-comparer" id="z7xu5yj_262" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="调用">
f(c)
f(v)
g(c)
g(v)
h(c)
h(v)
</div><div class="code-block" data-lang="none" data-title="函数返回类型">
常量
变量
变量
&lt;编译错误&gt;
常量
&lt;编译错误&gt;
</div></div></section><section class="chapter"><h3 id="z7xu5yj_202" data-toc="z7xu5yj_202">内建函数</h3><p id="z7xu5yj_267">除了上述特性，GLSL 还内置了许多方便的函数，你可以在 <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/index.php" id="z7xu5yj_269" data-external="true" rel="noopener noreferrer">这里</a> 查阅。</p><p id="z7xu5yj_268">其中也包含了大多数在 C 中属于 math 库的函数。</p></section><section class="chapter"><h3 id="z7xu5yj_203" data-toc="z7xu5yj_203">函数重载</h3><p id="z7xu5yj_270">GLSL 支持函数重载，即定义多个同名但不同参的函数，在调用时将会根据传参类型选择对应函数。</p><div class="code-block" data-lang="glsl">
float f(float x, int y);
float f(int x, int y);
float f(int y, float x);
</div></section><section class="chapter"><h3 id="z7xu5yj_204" data-toc="z7xu5yj_204">类型</h3><p id="z7xu5yj_272">GLSL 内置了布尔类型（<code class="code" id="z7xu5yj_276">bool</code> ），同时支持整型向量和布尔向量（<code class="code" id="z7xu5yj_277">ivec</code>、 <code class="code" id="z7xu5yj_278">bvec</code>）。</p><p id="z7xu5yj_273">GLSL 不支持 <code class="code" id="z7xu5yj_279">static</code> 关键字和 <code class="code" id="z7xu5yj_280">char</code> 类型。</p><p id="z7xu5yj_275">至此，有关 GLSL 的入门知识就差不多介绍完毕了。同时这也是本章的末尾，你应该已经对 OptiFine 和 GLSL 有一个大致的了解了。从下一章开始，我们将进入工作区并开始我们的光影创作之旅。</p></section></section><div class="last-modified">Last modified: 26 March 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="0-2-filepipeline.html" class="navigation-links__prev">结构和管线</a><a href="1-1-hellodeferred.html" class="navigation-links__next">延迟渲染初体验</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
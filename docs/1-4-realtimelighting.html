<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-18T04:06:24.756959862"><title>动态光照与阴影 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"-l8gz1_5","level":0,"title":"动态光照","anchor":"#-l8gz1_5"},{"id":"-l8gz1_6","level":0,"title":"实时阴影","anchor":"#-l8gz1_6"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="动态光照与阴影 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/1-4-realtimelighting.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="动态光照与阴影 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/1-4-realtimelighting.html#webpage",
    "url": "https://docs.minegraph.cn/md/1-4-realtimelighting.html",
    "name": "动态光照与阴影 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="1-4-realtimeLighting" data-main-title="动态光照与阴影" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Developer.md|创作者文档///shaderTutorial.md|光影开发教程///你好，光影"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="1-4-realtimeLighting" data-annotation-ids="wip" id="1-4-realtimeLighting.md">动态光照与阴影</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-l8gz1_7\&quot;\u003e在上一节中，我们初步认识了几何缓冲的相关知识，在延迟渲染中实现了场景光照。本章我们将会更进一步，将光照方向变更为实时计算，并为场景投影。\u003c/p\u003e&quot;]}"></div><section class="chapter"><h2 id="-l8gz1_5" data-toc="-l8gz1_5">动态光照</h2><p id="-l8gz1_8">回顾一下上一节的内容，我们成功在延迟处理实现了基本的光照，但是光照方向是固定的，而且如果你尝试过将时间切换至夜晚或者放置几个光源方块就会发现，场景并不会随着光照的变化而变化。</p><section class="chapter"><h3 id="-l8gz1_9" data-toc="-l8gz1_9">基本光照</h3><p id="-l8gz1_11">在原版中，我们的天空光照除了在日出和日落时会进行视觉变化，光照的方向实际上是固定的，也就是说明暗关系始终不变。光是还原原版渲染肯定不能满足我们，因此我们将利用 OptiFine 提供的其他数据来编写一个随光源位置而动态响应的光照。</p><p id="-l8gz1_12">你应该知道，Minecraft 的太阳和月亮实际上不会随着日落和日出而被替换，而是始终存在于世界中，只不过白天时月亮位于地平线以下，夜晚则反之。OptiFine 提供了它们的位置，并且为了和它的阴影（下一节我们就将实现它）联动，还给出了目前用于投影的光源位置：</p><div class="code-block" data-lang="glsl">
uniform vec3 sunPosition;         //视口空间的太阳位置
uniform vec3 moonPosition;        //视口空间的月亮位置
uniform vec3 shadowLightPosition; //视口空间的投影光源 (日或月) 位置
</div><p id="-l8gz1_14">上一节我们使用了原版的光照函数，它接受两个光照方向、法线和反照率，并返回运算之后的场景颜色。现在忘了它吧，我们将自己手动一步步实现光照函数，并进行手动混合。</p><p id="-l8gz1_15">光照的核心是<span class="control" id="-l8gz1_29">点乘</span> ，它们可以描述两个向量的同向程度，希望你还记得，我们只要将向量转化到单位向量，就能将其结果限制在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.287ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2778.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2000.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2500.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>。</p><p id="-l8gz1_16">所谓的光照方向就是指向光源位置的单位向量，我们使用 <code class="code" id="-l8gz1_31">normalize()</code> 函数就可以将向量转换为单位向量。于是我们只需要将表面法线与光照方向做点乘，就能求到光照强度了。但是当法线与光照的夹角大于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="3.394ex" height="1.667ex" role="img" focusable="false" viewBox="0 -715 1500 737"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" class=" MathML-Unit" transform="translate(1000,0)"><path data-c="B0" d="M147 628Q147 669 179 692T244 715Q298 715 325 689T352 629Q352 592 323 567T249 542Q202 542 175 567T147 628ZM313 628Q313 660 300 669T259 678H253Q248 678 242 678T234 679Q217 679 207 674T192 659T188 644T187 629Q187 600 198 590Q210 579 250 579H265Q279 579 288 581T305 595T313 628Z"></path></g></g></g></svg></mjx-container> 时，就会产生负值，而背光面本身就不会被照亮，因此我们还需要钳制一下最小值：</p><div class="code-block" data-lang="glsl">
vec3 lightDir = normalize(shadowLightPosition);
float lit = max(dot(lightDir, normal), 0.0);
</div><p id="-l8gz1_18">这样，我们就拿到了场景的光照数据了，我们将它和反照率（所谓反射光的概&ldquo; <span class="emphasis" id="-l8gz1_33">率</span> &rdquo;或者占比）相乘，就能得到应用了光照之后的场景颜色了：</p><div class="code-block" data-lang="glsl">
fragColor = albedo * lit;
</div><figure id="-l8gz1_20"><img alt="Shadows realtime lighting" src="MGC_Docs/shadows_realtimeLighting.webp" title="Shadows realtime lighting" width="1282" height="752"></figure><p id="-l8gz1_21">不过你会看到，场景没有被光照射到的区域一片纯黑，这可不是我们期望的。为此，我们可以添加一个<span class="control" id="-l8gz1_34">环境光</span>亮度，基本上就是手动给计算好的光照加一个小值：</p><div class="code-block" data-lang="glsl">
fragColor = albedo * (lit + 0.3);
</div><p id="-l8gz1_23">然后，你就能看到随着更改时间而变化的场景光照了：</p><figure id="-l8gz1_24"><img alt="Shadows different time" src="MGC_Docs/shadows_differentTime.webp" title="Shadows different time" width="1282" height="752"></figure><p id="-l8gz1_25">如果你还没忘记怪可怜的原版 AO，可以将它乘入环境光照明，让它发挥本来的作用：模拟环境光的遮挡。</p><div class="code-block" data-lang="glsl">
fragColor = albedo * (lit + 0.3 * albedo.a);
</div><p id="-l8gz1_27">如果你觉得背光面太暗了，或者想要随时调节环境光照，也可以将它们写入光影设置。</p><aside class="prompt" data-type="tip" data-title="你知道吗" id="-l8gz1_28"><p id="-l8gz1_35">Photoshop 中的&ldquo;正片叠底&rdquo;模式的英文名称就是 Multiply，即相乘。由于普通图像的分量最大值只能是 <code class="code" id="-l8gz1_36">1.0</code> ，因此将图层混合模式选为正片叠底之后实际上是将其当作了阴影。</p></aside></section><section class="chapter"><h3 id="-l8gz1_10" data-toc="-l8gz1_10">光照贴图</h3></section></section><section class="chapter"><h2 id="-l8gz1_6" data-toc="-l8gz1_6">实时阴影</h2><section class="chapter"><h3 id="-l8gz1_37" data-toc="-l8gz1_37">阴影几何缓冲</h3></section><section class="chapter"><h3 id="-l8gz1_38" data-toc="-l8gz1_38">延迟渲染坐标变换</h3></section><section class="chapter"><h3 id="-l8gz1_39" data-toc="-l8gz1_39">绘制阴影</h3></section></section><div class="last-modified">Last modified: 18 March 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="1-3-deferredlighting.html" class="navigation-links__prev">延迟处理光照</a><a href="2-1-advancedlighting.html" class="navigation-links__next">高级光照</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
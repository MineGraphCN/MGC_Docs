<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-11T11:02:05.903621143"><title>光影 技术科普 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"gi","level":0,"title":"全局光照","anchor":"#gi"},{"id":"rsm","level":1,"title":"反射阴影贴图","anchor":"#rsm"},{"id":"lpv","level":1,"title":"辐照传播体积","anchor":"#lpv"},{"id":"pt","level":1,"title":"路径（光线）追踪全局光照","anchor":"#pt"},{"id":"AO","level":0,"title":"环境光遮蔽","anchor":"#AO"},{"id":"ssao","level":1,"title":"屏幕空间环境光遮蔽","anchor":"#ssao"},{"id":"rtao","level":1,"title":"路径（光线）追踪环境光遮蔽","anchor":"#rtao"},{"id":"AA","level":0,"title":"抗锯齿／升采样","anchor":"#AA"},{"id":"xgc8kf_225","level":1,"title":"走样现象","anchor":"#xgc8kf_225"},{"id":"xgc8kf_226","level":1,"title":"空间抗锯齿","anchor":"#xgc8kf_226"},{"id":"fxaa","level":2,"title":"快速近似抗锯齿","anchor":"#fxaa"},{"id":"msaa","level":2,"title":"多重采样抗锯齿","anchor":"#msaa"},{"id":"smaa","level":2,"title":"子像素增强抗锯齿","anchor":"#smaa"},{"id":"taa","level":1,"title":"时域抗锯齿","anchor":"#taa"},{"id":"xgc8kf_228","level":1,"title":"升采样","anchor":"#xgc8kf_228"},{"id":"dlss","level":2,"title":"DLSS","anchor":"#dlss"},{"id":"fsr","level":2,"title":"FSR","anchor":"#fsr"},{"id":"xess","level":2,"title":"XeSS","anchor":"#xess"},{"id":"xgc8kf_18","level":0,"title":"光线追踪在渲染技术中的应用","anchor":"#xgc8kf_18"},{"id":"xgc8kf_19","level":0,"title":"技术发展与理解误区","anchor":"#xgc8kf_19"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="光影 技术科普 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/shadertech.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="光影 技术科普 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/shadertech.html#webpage",
    "url": "https://docs.minegraph.cn/md/shadertech.html",
    "name": "光影 技术科普 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="shaderTech" data-main-title="光影 技术科普" data-article-props="{&quot;seeAlso&quot;:[{&quot;title&quot;:&quot;相关文档&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;shaderbasic.html&quot;,&quot;text&quot;:&quot;着色器 基本概念和轶事&quot;,&quot;tooltip&quot;:&quot;着色器的基本概念和它们与 Minecraft 的历史&quot;,&quot;description&quot;:&quot;着色器的基本概念和它们与 Minecraft 的历史&quot;},{&quot;url&quot;:&quot;terms.html#渲染技术相关&quot;,&quot;text&quot;:&quot;术语表 - 渲染技术相关&quot;,&quot;tooltip&quot;:&quot;总结了一些常用渲染技术大方向的术语&quot;,&quot;description&quot;:&quot;总结了一些常用渲染技术大方向的术语&quot;}]}],&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Library.md|知识库///PopOfScience.md|科普文档"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="shaderTech" data-label-id="adv" data-annotation-ids="latest,shader,rt" id="shaderTech.md">光影 技术科普</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;xgc8kf_23\&quot;\u003e这里罗列了在着色器中使用的各种技术的原理。\u003c/p\u003e&quot;,&quot;\u003caside class\u003d\&quot;prompt\&quot; data-type\u003d\&quot;note\&quot; data-title\u003d\&quot;\&quot; id\u003d\&quot;xgc8kf_24\&quot;\u003e\u003cp id\u003d\&quot;xgc8kf_25\&quot;\u003e本文不涉及算法层面的解释。\u003c/p\u003e\u003c/aside\u003e&quot;]}"></div><aside class="prompt" data-type="note" data-title="阅读建议" id="xgc8kf_22"><p id="xgc8kf_26">这是着色器应用技术的解释，如果不了解其基本概念，可以阅读 <a href="shaderbasic.html" id="xgc8kf_27" data-tooltip="">光影 基本概念</a>。</p></aside><section class="chapter"><h2 id="gi" data-toc="gi">全局光照</h2><p id="xgc8kf_28"><span class="control" id="xgc8kf_45"><span class="tooltip" id="xgc8kf_46" title="Global Illumination">GI</span></span> ，表现了直接光照和间接光照的综合效果，但在渲染中，全局光照通常仅包括间接光照。它有多种实现方法，例如辐照度、光线追踪、光子贴图、光照探针等。</p><p id="xgc8kf_29">当光从光源被发射出来后，碰到障碍物就反射和折射，经过无数次的反射和折射，物体表面和角落都会有光感，就产生真实的光照效果。</p><p id="xgc8kf_30">全局光照的开销通常很大。渲染带有光线追踪全局光照效果的图片，耗时会较长（取决于场景复杂度）。渲染静态图片可以接受这较长的耗时，但渲染视频或者应用到游戏时，要求的渲染时间就要严格很多，于是便有了各种光栅拟合算法。</p><dl id="xgc8kf_31" data-style="title-top"><dt id="rsm" data-expandable="false">反射阴影贴图</dt><dd><p id="xgc8kf_48"><span class="control" id="xgc8kf_50"><span class="tooltip" id="xgc8kf_54" title="Reflective Shadow Maps">RSM</span></span> ，原理为根据 <a href="terms.html#着色目标" id="xgc8kf_51" data-tooltip="">着色点</a> 的表面法线在<span class="control" id="xgc8kf_52">颜色阴影纹理</span> （从光源视角记录的带表面颜色的纹理）上反弹 <a href="terms.html#采样目标" id="xgc8kf_53" data-tooltip="">采样点</a> ，并将采样到的位置视为一个光源并照亮着色点。</p><p id="xgc8kf_49">RSM 的缺陷也很明显，它不会考虑遮挡，一旦它在阴影纹理上找到了对应的&ldquo;光源&rdquo;，那么该位置就会被照亮，即使它在狭小的空间中，因此 RSM 通常会配合 <a href="#AO" id="xgc8kf_55" data-tooltip="">环境光遮蔽</a> 使用。</p></dd></dl><div class="tabs" id="xgc8kf_32" data-anchors="[xgc8kf_56,xgc8kf_57,xgc8kf_58]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_56" data-title="无"><figure id="xgc8kf_59"><img alt="无 GI" src="MGC_Docs/GI_NONE.png" title="无GI" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_57" data-title="RSM"><figure id="xgc8kf_60"><img alt="RSM" src="MGC_Docs/GI_RSM.png" title="RSM" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_58" data-title="条文对比"><ul class="list _bullet" id="xgc8kf_61"><li class="list__item" id="xgc8kf_62"><p id="xgc8kf_64">无全局光照，没有被阳光照射的地方漆黑一片。</p><figure id="xgc8kf_65"><a href="MGC_Docs/GI_NONE.png" class="lightbox"><img alt="无 GI" src="MGC_Docs/GI_NONE.png" title="无GI" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_63"><p id="xgc8kf_66">RSM 全局光照，矿洞被打在墙壁上的光线照亮了。</p><figure id="xgc8kf_67"><a href="MGC_Docs/GI_RSM.png" class="lightbox"><img alt="RSM" src="MGC_Docs/GI_RSM.png" title="RSM" width="1920" height="1080"></a></figure></li></ul></div></div><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_33"><p id="xgc8kf_68">自 iterationT 0.16.1（2.0.0 之后不久的开发版）开始，它的 RSM 算法一直都有问题 <sup class="superscript" id="xgc8kf_72"><b id="xgc8kf_73">1</b></sup> ，直到 iterationT Beta 3.1.07 才修复。</p><p id="xgc8kf_69"><span class="control" id="xgc8kf_74">[1]</span> 在错误的 <a href="terms.html#坐标系" id="xgc8kf_75" data-tooltip="在着色器中基于不同坐标系即称为不同空间，通过矩阵可以在不同坐标系之间转换。">空间</a> 中计算，而其算法基于 Continuum，这也意味着 Continuum 的 RSM 全局光照在那时也有问题，如今也已修复。</p><div class="tabs" id="xgc8kf_70" data-group="rsmfix" data-anchors="[xgc8kf_76,xgc8kf_77]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_76" data-sync-tabs="before" data-title="修复前"><figure id="xgc8kf_78"><a href="MGC_Docs/itt_RSM_before.png" class="lightbox"><img alt="修复前的 RSM 在仅 GI 光照下的样子" src="MGC_Docs/itt_RSM_before.png" title="修复前的RSM在仅GI光照下的样子" width="1920" height="1080"></a></figure><figure id="xgc8kf_79"><a href="MGC_Docs/itt_RSM_before_2.png" class="lightbox"><img alt="修复前的 RSM 在实际游戏中的样子" src="MGC_Docs/itt_RSM_before_2.png" title="修复前的RSM在实际游戏中的样子" width="1920" height="1080"></a></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_77" data-sync-tabs="after" data-title="修复后"><figure id="xgc8kf_80"><a href="MGC_Docs/itt_RSM_after.png" class="lightbox"><img alt="修复后的 RSM 在仅 GI 光照下的样子" src="MGC_Docs/itt_RSM_after.png" title="修复后的RSM在仅GI光照下的样子" width="1920" height="1080"></a></figure><figure id="xgc8kf_81"><a href="MGC_Docs/itt_RSM_after_2.png" class="lightbox"><img alt="修复后的 RSM 在实际游戏中的样子" src="MGC_Docs/itt_RSM_after_2.png" title="修复后的RSM在实际游戏中的样子" width="1920" height="1080"></a></figure></div></div><div class="tabs" id="xgc8kf_71" data-group="rsmfix" data-anchors="[xgc8kf_82,xgc8kf_83]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_82" data-sync-tabs="before" data-title="修复前"></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_83" data-sync-tabs="after" data-title="修复后"></div></div></aside><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_34"><p id="xgc8kf_84">参考资料： <a href="https://zhuanlan.zhihu.com/p/357259069" id="xgc8kf_85" data-external="true" rel="noopener noreferrer">【论文复现】Reflective Shadow Maps</a></p></aside><dl id="xgc8kf_35" data-style="title-top"><dt id="lpv" data-expandable="false">辐照传播体积</dt><dd><p id="xgc8kf_87"><span class="control" id="xgc8kf_90"><span class="tooltip" id="xgc8kf_91" title="Light Propagation Volumes">LPV</span></span> ，是 CryEngine 3 提出的一种实时的、无需任何预计算的全局光照技术，其创造性地提出了使用体素来存储、传播间接光照的方法。</p><p id="xgc8kf_88">LPV 首先将整个场景划分为体素，将整个场景离散开来（对 Minecraft 来说可以说是天然优势），每一个格子的光照就是其他格子光照乘以贡献的总和，最终形成一个庞大的<span class="control" id="xgc8kf_92">多项式</span>。 <br> 直接求解每个格子内的光照是不现实的，解决方法是让光照像墨滴一样在这些格子中弥散、传播，从而在时域上求解间接光照。</p><p id="xgc8kf_89">你可以将它视为一种<span class="control" id="xgc8kf_94">以体素为精度的光线追踪</span>。</p></dd></dl><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_36"><p id="xgc8kf_95"><span class="emphasis" id="xgc8kf_98">Cody Darr</span> 曾经发布过一个 SEUS 的测试版 <a href="https://www.patreon.com/posts/seus-lpvgi-e1-20122720" id="xgc8kf_99" data-tooltip="Patreon，可能需要代理" data-external="true" rel="noopener noreferrer">SEUS LPVGI</a> ，但是我们发现如今这个光影已经无法在新驱动上运行； <br> 在 <span class="emphasis" id="xgc8kf_101">GeForceLegend</span> 检查代码之后，发现其中使用了很多的 <code class="code" id="xgc8kf_102">mod(float, int)</code> ，这在自帕斯卡架构开始的显卡上会出现异常。</p><p id="xgc8kf_96">要想修复这个问题，我们只需要在传入 <code class="code" id="xgc8kf_103">mod()</code> 时将其第二个参数 <code class="code" id="xgc8kf_104">B</code> 显式转换为 <code class="code" id="xgc8kf_105">float</code> 类型即可： <br><br></p><div class="code-comparer" id="xgc8kf_97" data-comparing="vertically"><div class="code-block" data-lang="glsl" data-title="Before">
float A;
int B;
[...];
mod(A, B);
</div><div class="code-block" data-lang="glsl" data-title="After">
float A;
int B;
[...];
mod(A, float(B));
       ^^^^^^ ^
</div></div></aside><div class="tabs" id="xgc8kf_37" data-anchors="[xgc8kf_110,xgc8kf_111,xgc8kf_112,xgc8kf_113]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_110" data-title="无"><figure id="xgc8kf_114"><img alt="无 GI" src="MGC_Docs/GI_NONE_2.png" title="无GI" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_111" data-title="RSM + SSAO"><figure id="xgc8kf_115"><img alt="RSM" src="MGC_Docs/GI_RSM_2.png" title="RSM" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_112" data-title="LPV"><figure id="xgc8kf_116"><img alt="LPV" src="MGC_Docs/GI_LPV.png" title="LPV" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_113" data-title="条文对比"><ul class="list _bullet" id="xgc8kf_117"><li class="list__item" id="xgc8kf_118"><p id="xgc8kf_121">无全局光照，周围的环境只有天空颜色。</p><figure id="xgc8kf_122"><a href="MGC_Docs/GI_NONE_2.png" class="lightbox"><img alt="无 GI" src="MGC_Docs/GI_NONE_2.png" title="无GI" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_119"><p id="xgc8kf_123">RSM 全局光照 + SSAO，环境染上了品红色混凝土的颜色，但右侧近处的石头上有明显的伪影，左侧靠得更近的石头颜色反而不明显。</p><figure id="xgc8kf_124"><a href="MGC_Docs/GI_RSM_2.png" class="lightbox"><img alt="RSM" src="MGC_Docs/GI_RSM_2.png" title="RSM" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_120"><p id="xgc8kf_125">LPV 全局光照，环境更加准确地染上了颜色。</p><figure id="xgc8kf_126"><a href="MGC_Docs/GI_LPV.png" class="lightbox"><img alt="LPV" src="MGC_Docs/GI_LPV.png" title="LPV" width="1920" height="1080"></a></figure></li></ul></div></div><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_38"><p id="xgc8kf_127">参考资料： <a href="https://zhuanlan.zhihu.com/p/412287249" id="xgc8kf_128" data-external="true" rel="noopener noreferrer">Light Propagation Volumes</a></p></aside><dl id="xgc8kf_39" data-style="title-top"><dt id="pt" data-expandable="false">路径（光线）追踪全局光照</dt><dd><p id="xgc8kf_130"><span class="control" id="xgc8kf_131"><span class="tooltip" id="xgc8kf_132" title="Path Tracing">PT</span>GI</span> ，使用路径追踪算法进行光照计算，在 Minecraft（包括基岩版光线追踪）中，常辅以 LPV。相比单独的 LPV 拥有更好的效果。</p></dd></dl><aside class="prompt" data-type="note" data-title="" id="xgc8kf_40"><p id="xgc8kf_133">室内场景为了突出场景暗部，已进行了加强曝光处理。</p></aside><div class="tabs" id="xgc8kf_41" data-group="VX" data-anchors="[xgc8kf_134,xgc8kf_135,xgc8kf_136,xgc8kf_137]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_134" data-sync-tabs="RSM" data-title="RSM + SSAO"><figure id="xgc8kf_138"><img alt="RSM" src="MGC_Docs/GI_RSM_4.png" title="RSM" data-dark-src="MGC_Docs/GI_RSM_4_dark.png" width="1920" height="1080"></figure><figure id="xgc8kf_139"><img alt="RSM" src="MGC_Docs/GI_RSM_3.png" title="RSM" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_135" data-sync-tabs="LPV" data-title="LPV"><figure id="xgc8kf_140"><img alt="LPV" src="MGC_Docs/GI_LPV_2.png" title="LPV" data-dark-src="MGC_Docs/GI_LPV_2_dark.png" width="1920" height="1080"></figure><aside class="prompt" data-type="note" data-title="" id="xgc8kf_141"><p id="xgc8kf_142">由于 LPVGI 在高版本无法正常运行，这里只列出一张图片。</p></aside></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_136" data-sync-tabs="VX" data-title="体素光追"><figure id="xgc8kf_143"><img alt="体素光追" src="MGC_Docs/GI_VXGI_2.png" title="体素光追" data-dark-src="MGC_Docs/GI_VXGI_2_dark.png" width="1920" height="1080"></figure><figure id="xgc8kf_144"><img alt="体素光追" src="MGC_Docs/GI_VXGI.png" title="体素光追" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_137" data-sync-tabs="Compare" data-title="条文对比"><ul class="list _bullet" id="xgc8kf_145"><li class="list__item" id="xgc8kf_146"><p id="xgc8kf_149">RSM 全局光照 + <span class="tooltip" id="xgc8kf_151" title="Screen-Space Ambient Occlusion">SSAO</span>：</p><ul class="list _bullet" id="xgc8kf_150"><li class="list__item" id="xgc8kf_152"><p id="xgc8kf_154">受原版光照和伪影影响，这个场景显得非常脏。</p><figure id="xgc8kf_155"><a href="MGC_Docs/GI_RSM_4.png" class="lightbox" data-dark-href="MGC_Docs/GI_RSM_4_dark.png"><img alt="RSM" src="MGC_Docs/GI_RSM_4.png" title="RSM" data-dark-src="MGC_Docs/GI_RSM_4_dark.png" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_153"><p id="xgc8kf_156">被遮挡的场景也一股脑全亮了。</p><figure id="xgc8kf_157"><a href="MGC_Docs/GI_RSM_3.png" class="lightbox"><img alt="RSM 全局光照" src="MGC_Docs/GI_RSM_3.png" title="RSM全局光照" width="1920" height="1080"></a></figure></li></ul></li><li class="list__item" id="xgc8kf_147"><p id="xgc8kf_158">LPV 全局光照，受辐照体积限制，顶部露天区域的两侧看起来像是漏光了。</p><figure id="xgc8kf_159"><a href="MGC_Docs/GI_LPV_2.png" class="lightbox" data-dark-href="MGC_Docs/GI_LPV_2_dark.png"><img alt="LPV" src="MGC_Docs/GI_LPV_2.png" title="LPV" data-dark-src="MGC_Docs/GI_LPV_2_dark.png" width="1920" height="1080"></a></figure><aside class="prompt" data-type="note" data-title="" id="xgc8kf_160"><p id="xgc8kf_161">这张图片中没有使用任何 <span class="tooltip" id="xgc8kf_162" title="Ambient Occlusion">AO</span> ，墙角产生的阴影全都来源于 LPV 的特性。</p></aside></li><li class="list__item" id="xgc8kf_148"><p id="xgc8kf_163">基于体素的光线追踪全局光照：</p><ul class="list _bullet" id="xgc8kf_164"><li class="list__item" id="xgc8kf_165"><p id="xgc8kf_167">产生了更加干净准确的照明。</p><figure id="xgc8kf_168"><a href="MGC_Docs/GI_VXGI_2.png" class="lightbox" data-dark-href="MGC_Docs/GI_VXGI_2_dark.png"><img alt="体素光追" src="MGC_Docs/GI_VXGI_2.png" title="体素光追" data-dark-src="MGC_Docs/GI_VXGI_2_dark.png" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_166"><p id="xgc8kf_169">可以注意到地毯和楼梯在床上投下了相对窗户这个间接光源位置的准确阴影。</p><figure id="xgc8kf_170"><a href="MGC_Docs/GI_VXGI.png" class="lightbox"><img alt="体素光追全局光照" src="MGC_Docs/GI_VXGI.png" title="体素光追全局光照" width="1920" height="1080"></a></figure></li></ul></li></ul></div></div><div class="tabs" id="xgc8kf_42" data-group="VX" data-anchors="[xgc8kf_171,xgc8kf_172,xgc8kf_173]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_171" data-sync-tabs="RSM" data-title="RSM + SSAO"></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_172" data-sync-tabs="VX" data-title="体素光追"></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_173" data-sync-tabs="Compare" data-title="条文对比"></div></div><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_43"><ul class="list _bullet" id="xgc8kf_174"><li class="list__item" id="xgc8kf_175"><p>受限于 OptiFine 架构，如今的 Java 版光线追踪光影均需要手动存储场景信息，并混合使用 LPV 和 PT。</p></li><li class="list__item" id="xgc8kf_176"><p>使用体素不代表我们只能按方块追踪所有物体，我们可以定义每个体素的形状，从而产生符合形状的阴影。</p></li></ul></aside><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_44"><p id="xgc8kf_177">参考资料： <a href="https://zhuanlan.zhihu.com/p/414691569" id="xgc8kf_178" data-external="true" rel="noopener noreferrer">Voxel Global Illumination 体素全局光照（一）</a></p></aside></section><section class="chapter"><h2 id="AO" data-toc="AO">环境光遮蔽</h2><p id="xgc8kf_179"><span class="control" id="xgc8kf_188"><span class="tooltip" id="xgc8kf_189" title="Ambient Occlusion">AO</span></span> ，是一种广泛用于现代游戏渲染的图形技术，其算力消耗相对较少的同时能带来非常大的画面观感改进，其模拟了现实世界中光线在物体的凹角和接缝中产生阴影的现象。</p><p id="xgc8kf_180">在现实中，当光线到达物体的凹角和接缝时，由于空间被物体阻挡，光线无法充分照射到一些区域，导致这些区域相对较暗，形成阴影。</p><p id="xgc8kf_181">在没有环境光遮蔽的情况下，画面看起来像是被均匀的强光照亮，没有阴影和深度。详情可以参考在 Minecraft 中关闭 <code class="code" id="xgc8kf_190">平滑光照</code> 效果后的一些表现，很多手游也缺失此效果，导致画面显得非常扁平。</p><p id="xgc8kf_182">目前在 Java 版的光影中主要使用 SSAO，也是游戏界使用最多的环境光遮蔽技术。</p><dl id="xgc8kf_183" data-style="title-top"><dt id="ssao" data-expandable="false">屏幕空间环境光遮蔽</dt><dd><p id="xgc8kf_192"><span class="control" id="xgc8kf_194"><span class="tooltip" id="xgc8kf_195" title="Screen-Space Ambient Occlusion">SSAO</span></span> ，是目前业界内应用最广泛的环境光遮蔽技术。SSAO 通过分析场景中各个像素点周围的几何信息来计算该像素点处的遮蔽程度。其计算效率最高，但相对不够精确。</p><p id="xgc8kf_193">目前常用的除了 SSAO，还有 <span class="tooltip" id="xgc8kf_196" title="Horizon-Based Ambient Occlusion">HBAO（或 HBAO+）</span> （水平基准环境光遮蔽）和 <span class="tooltip" id="xgc8kf_197" title="Ground Truth Ambient Occlusion">GTAO</span> （基准真值环境光遮蔽）。SSAO、HBAO、GTAO 逐级基于前者改进，能产生更加准确的遮蔽阴影。</p></dd></dl><p id="xgc8kf_184">图片来自 <span class="emphasis" id="xgc8kf_198">Tahnass</span>。</p><div class="tabs" id="xgc8kf_185" data-anchors="[xgc8kf_199,xgc8kf_200,xgc8kf_201,xgc8kf_202]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_199" data-title="无"><figure id="xgc8kf_203"><img alt="无 AO" src="MGC_Docs/AO_NONE.png" title="无AO" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_200" data-title="SSAO"><figure id="xgc8kf_204"><img alt="SSAO" src="MGC_Docs/AO_SSAO.png" title="SSAO" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_201" data-title="GTAO"><figure id="xgc8kf_205"><img alt="GTAO" src="MGC_Docs/AO_GTAO.png" title="GTAO" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_202" data-title="条文对比"><ul class="list _bullet" id="xgc8kf_206"><li class="list__item" id="xgc8kf_207"><p id="xgc8kf_210"><span class="control" id="xgc8kf_212">没有 AO</span> ，场景的纵深感弱，近处栅栏看起来像悬空的。图中的明暗关系由原版天空光照和全局光照共同产生。</p><figure id="xgc8kf_211"><a href="MGC_Docs/AO_NONE.png" class="lightbox"><img alt="无 AO" src="MGC_Docs/AO_NONE.png" title="无AO" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_208"><p id="xgc8kf_213"><span class="control" id="xgc8kf_215">SSAO</span> ，注意房屋窗户的栅栏和村民周围，室内的光线更加昏暗，近处的栅栏也产生了阴影，产生了纵深感。</p><figure id="xgc8kf_214"><a href="MGC_Docs/AO_SSAO.png" class="lightbox"><img alt="SSAO" src="MGC_Docs/AO_SSAO.png" title="SSAO" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_209"><p id="xgc8kf_216"><span class="control" id="xgc8kf_218">GTAO</span> ，注意村民周围阴影与 SSAO 的区别，暗角的过渡更加均匀，近处的栅栏产生的阴影不再紧贴着横杆，其他狭缝中的阴影也更加浓厚。</p><figure id="xgc8kf_217"><a href="MGC_Docs/AO_GTAO.png" class="lightbox"><img alt="GTAO" src="MGC_Docs/AO_GTAO.png" title="GTAO" width="1920" height="1080"></a></figure></li></ul></div></div><dl id="xgc8kf_186" data-style="title-top"><dt id="rtao" data-expandable="false">路径（光线）追踪环境光遮蔽</dt><dd><p id="xgc8kf_221"><span class="control" id="xgc8kf_222"><span class="tooltip" id="xgc8kf_223" title="Ray Tracing Ambient Occlusion">RTAO</span></span> ，通过光线追踪仅计算 AO，效果最好的同时性能消耗要比光线追踪全局光照低（但在 AO 中开销仍是最高）。</p></dd></dl><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_187"><p id="xgc8kf_224">在光线追踪间接光照效果相对完整的一些光影或游戏中，其通常不会单独列出，而是作为流程中的一种自然产物。</p></aside></section><section class="chapter"><h2 id="AA" data-toc="AA">抗锯齿／升采样</h2><section class="chapter"><h3 id="xgc8kf_225" data-toc="xgc8kf_225">走样现象</h3><p id="xgc8kf_229"><span class="control" id="xgc8kf_232">Aliasing</span> ，是由于渲染过程中<span class="control" id="xgc8kf_233">采样不足</span>而引起的，也被称为<span class="control" id="xgc8kf_234">走样</span> 。在游戏渲染中，主要会遇到两种类型的走样，分别是几何走样和着色走样。</p><ul class="list _bullet" id="xgc8kf_230"><li class="list__item" id="xgc8kf_235"><p>几何走样（Geometric Aliasing）是由于光栅化过程中对<span class="control" id="xgc8kf_237">几何图形边缘</span>的采样不足而导致的，也就是我们通常所说的<span class="control" id="xgc8kf_238">锯齿</span> 。现代屏幕由像素组成，像素的本质是一个个离散的小方格，因此当尝试表示连续的斜线或曲线时，就会出现锯齿状的走样，使得图形边缘看起来不平滑。</p></li><li class="list__item" id="xgc8kf_236"><p>着色走样（Shading Aliasing）是由于渲染过程中的<span class="control" id="xgc8kf_239">采样数不足</span>而引起的。例如在体积渲染中，如果采样数较低，就会导致体积雾和体积云等效果出现<span class="control" id="xgc8kf_240">闪烁和噪点</span> ，一些光线追踪光影也会在处理光照时出现这些现象。</p></li></ul><p id="xgc8kf_231">由于抗锯齿技术在现代也身负减少着色走样的使命，相较于&ldquo;抗锯齿&rdquo;，Anti-Aliasing 更准确的翻译应该叫 <span class="emphasis" id="xgc8kf_241">抗走样</span> 或 <span class="emphasis" id="xgc8kf_242">反走样</span>。</p></section><section class="chapter"><h3 id="xgc8kf_226" data-toc="xgc8kf_226">空间抗锯齿</h3><p id="xgc8kf_243">空间抗锯齿技术是针对几何走样问题的传统解决方案。由于其实现方式，通常会造成不可忽视的性能损耗，同时<span class="control" id="xgc8kf_247">对于着色走样问题几乎无效</span> ，因此在目前的游戏中，单独的空间抗锯齿技术已不多见。</p><p id="xgc8kf_244">比较主流的空间抗锯齿技术有 FXAA、MSAA、SMAA 等，在 Java 版中，OptiFine 内置实现了兼容光影的 FXAA 和不兼容光影的 MSAA。</p><aside class="prompt" data-type="note" data-title="" id="xgc8kf_245"><p id="xgc8kf_248">以下效果评判仅针对几何走样问题。</p></aside><dl id="xgc8kf_246" data-style="title-top"><dt id="fxaa" data-expandable="false">快速近似抗锯齿</dt><dd><p id="xgc8kf_252"><span class="control" id="xgc8kf_255"><span class="tooltip" id="xgc8kf_256" title="Fast Approximate Anti-Aliasing">FXAA</span></span> ，通过简单的卷积混合颜色来减少锯齿。</p><p id="xgc8kf_253">其优势在于性能消耗极低，效果在大多数时候都可以接受，但其建立在对画面所有图形边缘进行无差别柔化处理的基础上，导致观感模糊。</p><p id="xgc8kf_254">FXAA 是一种后处理抗锯齿。</p></dd><dt id="msaa" data-expandable="false">多重采样抗锯齿</dt><dd><p id="xgc8kf_257"><span class="control" id="xgc8kf_262"><span class="tooltip" id="xgc8kf_264" title="Multisampling Anti-Aliasing">MSAA</span></span> ，属于 <span class="control" id="xgc8kf_263"><span class="tooltip" id="xgc8kf_265" title="Super-Sampling Anti-Aliasing">SSAA</span></span> （超级采样抗锯齿）的性能改进版。SSAA 直接将整个画面以更高分辨率渲染再降采样到画面，而 MSAA 则仅对图形边缘进行处理。</p><p id="xgc8kf_258">MSAA 由硬件执行，性能消耗最高（取决于采样倍率），效果也最好（非常鲁莽的实现，仅针对几何走样）。</p><p id="xgc8kf_259">其最大的问题是，原生的 MSAA <a href="shaderbasic.html#延迟渲染法" id="xgc8kf_266" data-tooltip="">与延迟渲染不兼容</a> ，因此很多游戏无法使用。</p><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_260"><p id="xgc8kf_267">在《未转变者》的老版本中，MSAA 可以在画面设置为向前渲染时启用； <br> 在《反恐精英2》中，由于后处理管线没有使用几何信息，因此也可以启用 MSAA。</p></aside><p id="xgc8kf_261">MSAA 是一种 <a href="shaderbasic.html#向前渲染法" id="xgc8kf_269" data-tooltip="">向前渲染</a> 抗锯齿。</p></dd><dt id="smaa" data-expandable="false">子像素增强抗锯齿</dt><dd><p id="xgc8kf_270"><span class="control" id="xgc8kf_275"><span class="tooltip" id="xgc8kf_277" title="Subpixel Morphological Anti-Aliasing">SMAA</span></span> ，是 <span class="control" id="xgc8kf_276"><span class="tooltip" id="xgc8kf_278" title="Morphological Anti-Aliasing">MLAA</span></span> （形态学抗锯齿）的改进版。MLAA 通过分析图形边缘然后进行平滑处理，SMAA 则在此之上进一步发展，使得图像更清晰。</p><p id="xgc8kf_271">其性能消耗比 MSAA 低得多，接近 FXAA 的水平，而效果却比 FXAA 更好。</p><p id="xgc8kf_272">由于其算法特性，当物体移动时可能会产生闪烁。</p><p id="xgc8kf_273">SMAA 是一种后处理抗锯齿。</p><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_274"><p id="xgc8kf_279">类似 MLAA 的算法还有 <span class="tooltip" id="xgc8kf_280" title="Conservative Morphological Anti-Aliasing">CMAA</span> （保守形态抗锯齿），其第二代版本（CMAA2）在《反恐精英2》中发光发热。</p></aside></dd></dl></section><section class="chapter"><h3 id="taa" data-toc="taa">时域抗锯齿</h3><p id="xgc8kf_281">时域抗锯齿通常指 <span class="control" id="xgc8kf_287"><span class="tooltip" id="xgc8kf_288" title="Temporal Anti-Aliasing">TAA</span></span> 。其原理是在时间上分散采样点，然后将当前帧的渲染结果与前一帧进行比较，以确定物体的运动和变化，之后进行混合以平滑图像并减少锯齿。</p><p id="xgc8kf_282">不同于空间抗锯齿的边缘检测处理，时域抗锯齿使用在多个帧之间进行信息累积和混合的方案。是现代游戏中运用最多的抗锯齿技术类型。</p><p id="xgc8kf_283">其性能要比 MSAA 好得多，而且能<span class="control" id="xgc8kf_289">在一定程度上解决着色走样</span> 。但是由于其时间性，不可避免地会在运动场景中产生拖影和模糊，如果抗锯齿参数不够优秀，还会造成明显的抖动感。</p><p id="xgc8kf_284">TAA 是一种在向前渲染进行抖动，并在后处理进行平滑的抗锯齿。</p><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_285"><ul class="list _bullet" id="xgc8kf_290"><li class="list__item" id="xgc8kf_291"><p>在 Java 版中，几乎所有现代光影都使用 TAA 或混合使用 TAA 和 FXAA。</p></li><li class="list__item" id="xgc8kf_292"><p>时域抗锯齿通常也会混合空间算法，将抗锯齿的上升到时空域，比如 <span class="control" id="xgc8kf_293">Filmic SMAA T2X</span> ，它不仅拥有 SMAA 的优秀性能，还解决了 SMAA 的闪烁问题。</p></li></ul></aside><div class="tabs" id="xgc8kf_286" data-anchors="[xgc8kf_294,xgc8kf_295,xgc8kf_296,xgc8kf_297,xgc8kf_298,xgc8kf_299]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_294" data-title="无"><figure id="xgc8kf_300"><img alt="无抗锯齿" src="MGC_Docs/AA_NONE.png" title="无抗锯齿" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_295" data-title="FXAA"><figure id="xgc8kf_301"><img alt="FXAA" src="MGC_Docs/AA_FXAA.png" title="FXAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_296" data-title="SSAA"><figure id="xgc8kf_302"><img alt="SSAA" src="MGC_Docs/AA_SSAA.png" title="SSAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_297" data-title="TAA"><figure id="xgc8kf_303"><img alt="TAA" src="MGC_Docs/AA_TAA.png" title="TAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_298" data-title="TAA + FXAA"><figure id="xgc8kf_304"><img alt="TAA + FXAA" src="MGC_Docs/AA_TAA_FXAA.png" title="TAA+FXAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_299" data-title="条文对比"><ul class="list _bullet" id="xgc8kf_305"><li class="list__item" id="xgc8kf_306"><p id="xgc8kf_311">无抗锯齿，几何走样和着色走样都很明显。</p><figure id="xgc8kf_312"><a href="MGC_Docs/AA_NONE.png" class="lightbox"><img alt="无抗锯齿" src="MGC_Docs/AA_NONE.png" title="无抗锯齿" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_307"><p id="xgc8kf_313">光影内置的 FXAA，解决了部分几何走样的锯齿，几乎不损耗性能。</p><figure id="xgc8kf_314"><a href="MGC_Docs/AA_FXAA.png" class="lightbox"><img alt="FXAA" src="MGC_Docs/AA_FXAA.png" title="FXAA" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_308"><p id="xgc8kf_315">利用 OptiFine 提供的渲染精细度实现的 SSAA 2X，效果极佳，但是性能损耗极大。</p><figure id="xgc8kf_316"><a href="MGC_Docs/AA_SSAA.png" class="lightbox"><img alt="SSAA" src="MGC_Docs/AA_SSAA.png" title="SSAA" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_309"><p id="xgc8kf_317">光影内置的 TAA，效果和 SSAA 相当，但是几乎不损耗性能，且消除了着色走样。注意：它没有对实体进行抗锯齿（此光影防止拖影刻意为之，其他光影不一定）。</p><figure id="xgc8kf_318"><a href="MGC_Docs/AA_TAA.png" class="lightbox"><img alt="TAA" src="MGC_Docs/AA_TAA.png" title="TAA" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_310"><p id="xgc8kf_319">将光影的 TAA 和 FXAA 全部启用，实体的几何走样和着色走样都消除了，且性能几乎不损耗。</p><figure id="xgc8kf_320"><a href="MGC_Docs/AA_TAA_FXAA.png" class="lightbox"><img alt="TAA + FXAA" src="MGC_Docs/AA_TAA_FXAA.png" title="TAA+FXAA" width="1920" height="1080"></a></figure></li></ul></div></div></section><section class="chapter"><h3 id="xgc8kf_228" data-toc="xgc8kf_228">升采样</h3><p id="xgc8kf_321"><span class="control" id="xgc8kf_327">Up-sampling</span> ，是一种增加图像分辨率的技术，也分为空间升采样和时域升采样。现代的升采样技术一般用于先降低渲染分辨率，将效果处理完毕后再提升到原始分辨率，来提升性能。</p><dl id="xgc8kf_322" data-style="title-top"><dt id="dlss" data-expandable="false">DLSS</dt><dd><p id="xgc8kf_331"><span class="control" id="xgc8kf_334"><span class="tooltip" id="xgc8kf_338" title="Deep Learning Super Sampling">深度学习超级采样</span></span> ，由 <span class="emphasis" id="xgc8kf_335">英伟达</span> 开发的一种升采样技术。通过降低分辨率并调用显卡 <sup class="superscript" id="xgc8kf_336">NVIDIA</sup> 的<span class="tooltip" id="xgc8kf_337" title="Tensor Core"><span class="control" id="xgc8kf_339">张量核心</span></span>来猜测原始分辨率下该处像素的内容。</p><ul class="list _bullet" id="xgc8kf_332"><li class="list__item" id="xgc8kf_340"><p>在 2.0 以前，DLSS 主要是靠已有画面内容来&ldquo;猜&rdquo;剩下的场景应该是何样。</p></li><li class="list__item" id="xgc8kf_341"><p>自 2.0 开始，DLSS 主要是根据场景运动信息和历史帧来判断剩下的场景是何样，其计算方法从单一的空间域上升到了<span class="control" id="xgc8kf_342">时空域</span> ，不再依赖于针对单个游戏的训练，效果也比 1.0 好得多。</p></li></ul><dl id="xgc8kf_333" data-style="title-top"><dt id="dlaa" data-expandable="false">DLAA</dt><dd><p id="xgc8kf_344"><span class="control" id="xgc8kf_345"><span class="tooltip" id="xgc8kf_347" title="Deep Learning Anti-Aliasing">深度学习抗锯齿</span></span> ，在<span class="control" id="xgc8kf_346">原始分辨率</span>下进行 DLSS 来平滑边缘的抗锯齿方法。</p></dd></dl></dd><dt id="fsr" data-expandable="false">FSR</dt><dd><p id="xgc8kf_348"><span class="control" id="xgc8kf_349"><span class="tooltip" id="xgc8kf_351" title="FidelityFX Super Resolution">FidelityFX 超级分辨率</span></span> ，由 <span class="emphasis" id="xgc8kf_350">AMD</span> 开发的一种升采样技术。相比较 DLSS 来说更为常规，但效果要比其他传统升采样方法好。</p></dd><dt id="xess" data-expandable="false">XeSS</dt><dd><p id="xgc8kf_352"><span class="control" id="xgc8kf_353"><span class="tooltip" id="xgc8kf_355" title="Xe Super Sampling">Xe 超级采样</span></span> ，由 <span class="emphasis" id="xgc8kf_354">英特尔</span> 开发的一种升采样技术。在其他平台上和其本家含有特定核心的平台上所使用的算法有所区别，因而在其本家平台上能够获得更好的效果。</p></dd></dl><ul class="list _bullet" id="xgc8kf_323"><li class="list__item" id="xgc8kf_356"><p>单独的空间升采样如今已经几乎不使用了，曾经的 FSR 1.0 和 DLSS 1.0 都是空间升采样。 </p><ul class="list _bullet" id="xgc8kf_359"><li class="list__item" id="xgc8kf_360"><p>FSR 1.0 只是通过缩放、插值和锐化来试图还原，造成较为强烈的涂抹感；</p></li><li class="list__item" id="xgc8kf_361"><p>DLSS 1.0 虽然利用了 AI，但其需要针对每个游戏进行训练，泛用性差，且质量较低。 </p><ul class="list _bullet" id="xgc8kf_362"><li class="list__item" id="xgc8kf_363"><p>除了 DLSS，英伟达还有一个类似 FSR 的通用算法 <span class="tooltip" id="xgc8kf_364" title="NVIDIA Image Scaling">NIS</span> ，其也是一种自适应锐化和空间升采样技术。</p></li></ul></li></ul></li><li class="list__item" id="xgc8kf_357"><p>时域升采样一般伴随着抗锯齿进行，如 TAAU、DLSS 2.0 和 FSR 2.0 等。在 Java 版的一些光影中实现了 TAAU。</p></li><li class="list__item" id="xgc8kf_358"><p>TAAU 基于 TAA 而实现，多帧信息不仅用于抗锯齿，还用于提高图像分辨率。SEUS PTGI 所用的 <span class="tooltip" id="xgc8kf_365" title="Half-Resolution Rendering">HRR</span> （半分辨率渲染）也是类似原理。</p></li></ul><div class="tabs" id="xgc8kf_324" data-anchors="[xgc8kf_366,xgc8kf_367,xgc8kf_368,xgc8kf_369]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_366" data-title="原生分辨率"><figure id="xgc8kf_370"><img alt="原生画面" src="MGC_Docs/TAAU_OFF_100P.png" title="原生画面" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_367" data-title="50% 渲染分辨率"><figure id="xgc8kf_371"><img alt="50% 分辨率画面" src="MGC_Docs/TAAU_OFF_50P.png" title="50%分辨率画面" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_368" data-title="50% TAAU"><figure id="xgc8kf_372"><img alt="50% 分辨率 + TAAU" src="MGC_Docs/TAAU_ON_50P.png" title="50%分辨率+TAAU" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_369" data-title="条文对比"><ul class="list _bullet" id="xgc8kf_373"><li class="list__item" id="xgc8kf_374"><p id="xgc8kf_377">原生分辨率图像，画面清晰，但性能较差。</p><figure id="xgc8kf_378"><a href="MGC_Docs/TAAU_OFF_100P.png" class="lightbox"><img alt="原生画面" src="MGC_Docs/TAAU_OFF_100P.png" title="原生画面" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_375"><p id="xgc8kf_379">50% 渲染分辨率，禁用 TAAU，性能最好，但画面模糊。</p><figure id="xgc8kf_380"><a href="MGC_Docs/TAAU_OFF_50P.png" class="lightbox"><img alt="50% 分辨率画面" src="MGC_Docs/TAAU_OFF_50P.png" title="50%分辨率画面" width="1920" height="1080"></a></figure></li><li class="list__item" id="xgc8kf_376"><p id="xgc8kf_381">50% 渲染分辨率，使用 TAAU 重建到原生分辨率，性能和画质平衡。</p><figure id="xgc8kf_382"><a href="MGC_Docs/TAAU_ON_50P.png" class="lightbox"><img alt="50% 分辨率 + TAAU" src="MGC_Docs/TAAU_ON_50P.png" title="50%分辨率+TAAU" width="1920" height="1080"></a></figure></li></ul></div></div><p id="xgc8kf_325">这是 SEUS PTGI HRR 2.1 GFME 降噪和升采样（TAAU + FXAA）前后的差异，由于其是点对点地降采样，因此 TAAU 处理效果更为明显：</p><figure id="xgc8kf_326"><a href="MGC_Docs/AA_differ.png" class="lightbox"><img alt="升采样差异" src="MGC_Docs/AA_differ.png" title="升采样前后差异" width="1920" height="1080"></a></figure></section></section><section class="chapter"><h2 id="xgc8kf_18" data-toc="xgc8kf_18">光线追踪在渲染技术中的应用</h2><aside class="prompt" data-type="warning" data-title="" id="xgc8kf_383"><p id="xgc8kf_395">我们在此讨论的是相对狭义的光线追踪技术应用，即大众所认知的 <a href="raytracing.html#fullRT" id="xgc8kf_396" data-tooltip="">世界空间光线追踪</a> 。如果严格按照光线追踪渲染流程来评判，那么类似于屏幕空间反射等技术也属于光线追踪（<a href="raytracing.html#sst" id="xgc8kf_397" data-tooltip="SST，是受限于 帧缓冲 ，只能与 屏幕空间 场景求交的光线追踪算法，是一种高质量的屏幕空间效果，同时也是廉价的光线追踪解决方案。">屏幕空间追踪</a> ）范畴。</p></aside><p id="xgc8kf_384">在 Java 版中，我们主要使用 <a href="terms.html#路径追踪" id="xgc8kf_398" data-tooltip="使用蒙特卡洛随机采样并模拟光子多次反弹，经由漫反射、镜面反射、折射等直到达到退出条件所最终产生的光照。">路径追踪</a> 。在此之前的光影，考虑到 Minecraft 游戏过程的动态性和一些算法限制，没办法像其他游戏一样使用预烘焙等类似技术来改善光栅化渲染。例如光源仅能按照原版的发光机制来单色发光；反射面完全无法反射屏幕外的物体（天空除外，它们通常由光影进行处理）等。 <br> 因此，在 Java 版的传统光栅光影中，效果相比其他光栅化游戏显得较为逊色，而光线追踪的实现为 Java 版带来了光影效果的重大革新。</p><p id="xgc8kf_385">SEUS 光影作者 <span class="emphasis" id="xgc8kf_400">Cody Darr</span> 在 2018 年 2 月发布了最早的 Java 版体素化实时光线追踪实现，这甚至<span class="control" id="xgc8kf_401">早于 RTX 显卡的发布</span>。 <br> 其原理是将原本用于存储阴影的 <code class="code" id="xgc8kf_403">shadowcolor&lt;0/1&gt;</code> 缓冲区通过几何着色器来记录场景体素，不过这也导致了体素记录距离与阴影分辨率直接挂钩（每个像素记录一个方块信息）。</p><p id="xgc8kf_386">由于体素化信息不方便存储实体，自 <span class="control" id="xgc8kf_404">PTGI E3</span> 开始，其将部分分辨率用于了传统光栅阴影映射，这极大限制了光线追踪的最大距离。使用 <code class="code" id="xgc8kf_405">16384</code> 这样的极限阴影分辨率，才能支持相对远距离的光线追踪，而这几乎必然会导致性能和显存两开花，如今仍有很多光影在尝试突破这些难关。</p><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_387"><p id="xgc8kf_406">在原始版本上，PTGI 的体素分布并不能兼容除 <code class="code" id="xgc8kf_410">4096</code> 外的分辨率，修改阴影分辨率将导致体素信息出错。</p><p id="xgc8kf_407">GFME 修改了其算法，让其可以随阴影分辨率动态地分布体素，从而在扩展阴影贴图之后可以获得更大的追踪范围。</p><p id="xgc8kf_408">在 <span class="emphasis" id="xgc8kf_411">Cody Darr</span> <a href="https://www.patreon.com/posts/creative-and-84935136" id="xgc8kf_412" data-tooltip="Patreon，可能需要代理" data-external="true" rel="noopener noreferrer">最近（存疑）的日志</a>中提到，PTGI 的下一个版本将改为使用稀疏数据结构存储场景信息，这样不仅能突破体素距离限制，同时还存储实体信息。但是这篇文章距今已过去一年，而 PTGI 的下一个版本仍是遥遥无期。</p><p id="xgc8kf_409">Rethinking Voxels 使用了相对高精度的距离场而不是体素，虽然不能获取实体的纹理信息，但是可以将场景中的几何信息悉数保存，配合上 Iris 的独占特性光源信息，可以兼容（几何上的）几乎任何模组。</p></aside><p id="xgc8kf_388">由于使用的是 OpenGL，Java 版光线追踪<span class="control" id="xgc8kf_413">无法调用光线追踪加速硬件</span> 。光影作者们的应对方法是使用<span class="control" id="xgc8kf_414">辐照度缓存</span>来优化计算量，同时采用 <span class="control" id="xgc8kf_415"><span class="tooltip" id="xgc8kf_416" title="Spatiotemporal Variance-Guided Filter">SVGF</span></span> 进行降噪处理。</p><ul class="list _bullet" id="xgc8kf_389"><li class="list__item" id="xgc8kf_417"><p>辐照度（在此类场景中也可称为<span class="control" id="xgc8kf_420">照度</span> ，即光学单位 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.081ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 1362 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="75" d="M383 58Q327 -10 256 -10H249Q124 -10 105 89Q104 96 103 226Q102 335 102 348T96 369Q86 385 36 385H25V408Q25 431 27 431L38 432Q48 433 67 434T105 436Q122 437 142 438T172 441T184 442H187V261Q188 77 190 64Q193 49 204 40Q224 26 264 26Q290 26 311 35T343 58T363 90T375 120T379 144Q379 145 379 161T380 201T380 248V315Q380 361 370 372T320 385H302V431Q304 431 378 436T457 442H464V264Q464 84 465 81Q468 61 479 55T524 46H542V0Q540 0 467 -5T390 -11H383V58Z" transform="translate(278,0)"></path><path data-c="78" d="M201 0Q189 3 102 3Q26 3 17 0H11V46H25Q48 47 67 52T96 61T121 78T139 96T160 122T180 150L226 210L168 288Q159 301 149 315T133 336T122 351T113 363T107 370T100 376T94 379T88 381T80 383Q74 383 44 385H16V431H23Q59 429 126 429Q219 429 229 431H237V385Q201 381 201 369Q201 367 211 353T239 315T268 274L272 270L297 304Q329 345 329 358Q329 364 327 369T322 376T317 380T310 384L307 385H302V431H309Q324 428 408 428Q487 428 493 431H499V385H492Q443 385 411 368Q394 360 377 341T312 257L296 236L358 151Q424 61 429 57T446 50Q464 46 499 46H516V0H510H502Q494 1 482 1T457 2T432 2T414 3Q403 3 377 3T327 1L304 0H295V46H298Q309 46 320 51T331 63Q331 65 291 120L250 175Q249 174 219 133T185 88Q181 83 181 74Q181 63 188 55T206 46Q208 46 208 23V0H201Z" transform="translate(834,0)"></path></g></g></g></svg></mjx-container> ；在渲染方程的能量传输语境中，辐照度的单位是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.329ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2797.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="57" d="M792 683Q810 680 914 680Q991 680 1003 683H1009V637H996Q931 633 915 598Q912 591 863 438T766 135T716 -17Q711 -22 694 -22Q676 -22 673 -15Q671 -13 593 231L514 477L435 234Q416 174 391 92T358 -6T341 -22H331Q314 -21 310 -15Q309 -14 208 302T104 622Q98 632 87 633Q73 637 35 637H18V683H27Q69 681 154 681Q164 681 181 681T216 681T249 682T276 683H287H298V637H285Q213 637 213 620Q213 616 289 381L364 144L427 339Q490 535 492 546Q487 560 482 578T475 602T468 618T461 628T449 633T433 636T408 637H380V683H388Q397 680 508 680Q629 680 650 683H660V637H647Q576 637 576 619L727 146Q869 580 869 600Q869 605 863 612T839 627T794 637H783V683H792Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1028,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="msup" transform="translate(1528,0)"><g data-mml-node="mtext"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path></g><g data-mml-node="mn" transform="translate(866,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container> ）缓存通过时域求解多项式缓存场景的粗略照明信息。在渲染时对这些数据进行插值，与光线追踪结果相互影响，避免对大量光子进行多次反弹求交。</p></li><li class="list__item" id="xgc8kf_418"><p>SVGF 的作用是结合时间和空间上的信息对画面进行降噪。利用过去几帧的深度、颜色、法线信息，并加入计算权重，以此估计当前像素区域样本分布的方差，据此进行空间过滤，最终达到降噪目的。</p></li><li class="list__item" id="xgc8kf_419"><p>不过上述过程会导致暗光下发生闪烁、拖影和纹理细节损失等问题，这也是目前必须妥协的问题。</p></li></ul><p id="xgc8kf_390">此外，有时我们还能在一些光影中见到 <a href="raytracing.html#sst" id="xgc8kf_423" data-tooltip="SST，是受限于 帧缓冲 ，只能与 屏幕空间 场景求交的光线追踪算法，是一种高质量的屏幕空间效果，同时也是廉价的光线追踪解决方案。">屏幕空间追踪</a> ，当它们与体素光追混合使用时，可以缓解一些非完整方块的体素形态问题（例如半砖在体素中的形态是完整方块或者直接被忽略时）。</p><p id="xgc8kf_391">截止到目前， <span class="control" id="xgc8kf_424">Vulkanite</span> 为光影引入了 <span class="control" id="xgc8kf_425">Vulkan</span> ，解决了诸多技术问题，并支持调用<span class="control" id="xgc8kf_426">光线追踪加速单元（RT Core） <span class="control" id="xgc8kf_430">来提升性能。但</span>该模组本身的完成度仍是个问题，因此目前难以依赖</span>。 <br><span class="control" id="xgc8kf_428">Focal</span> 也完成了 Fabric 和 Forge 版的统一，提高模组兼容性并开始专注于 <span class="control" id="xgc8kf_429">Focal <span class="emphasis" id="xgc8kf_431"><span class="tooltip" id="xgc8kf_432" title="Vulkan">VK</span></span></span> 的开发。</p><p id="xgc8kf_392">在上文中，我们已经展示了光线追踪如何影响全局光照，这里我们再给出一些光线追踪的优势示例。</p><ul class="list _bullet" id="xgc8kf_393"><li class="list__item" id="xgc8kf_433"><p id="xgc8kf_435">反射视野外的物体</p><div class="tabs" id="xgc8kf_436" data-group="ss_rt" data-anchors="[xgc8kf_437,xgc8kf_438]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_437" data-sync-tabs="ss" data-title="屏幕空间反射"><figure id="xgc8kf_439"><img alt="屏幕空间反射" src="MGC_Docs/Ref_SS.png" title="屏幕空间反射" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_438" data-sync-tabs="rt" data-title="光线追踪反射"><figure id="xgc8kf_440"><img alt="光线追踪反射" src="MGC_Docs/Ref_PT.png" title="光线追踪反射" width="1920" height="1080"></figure><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_441"><p id="xgc8kf_442">在这张图中，你可以发现铁块近处的地面比旁边更亮，这就是由于铁块表面光滑，反射太阳光形成了 <a href="terms.html#焦散" id="xgc8kf_443" data-tooltip="">焦散</a>。</p></aside></div></div></li><li class="list__item" id="xgc8kf_434"><p id="xgc8kf_444">精确方块光源</p><div class="tabs" id="xgc8kf_445" data-group="ss_rt" data-anchors="[xgc8kf_446,xgc8kf_447]"><div class="tabs__content" data-gtm="tab" id="xgc8kf_446" data-sync-tabs="ss" data-title="原版方块光源"><figure id="xgc8kf_448"><img alt="原版光源特性" src="MGC_Docs/BL_Vanilla.png" title="原版光源" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="xgc8kf_447" data-sync-tabs="rt" data-title="光线追踪方块光源"><figure id="xgc8kf_449"><img alt="光线追踪光源特性" src="MGC_Docs/BL_PT.png" title="光线追踪光源" width="1920" height="1080"></figure></div></div></li></ul><p id="xgc8kf_394">除此之外，光线追踪还有折射、焦散、阴影和更好的 PBR 特性支持等功能，不过对画面的贡献相对更小，或者是很少有在 Java 版实现，因此不做另外展示。</p></section><section class="chapter"><h2 id="xgc8kf_19" data-toc="xgc8kf_19">技术发展与理解误区</h2><p id="xgc8kf_450">随着硬件的不断发展，现代游戏的模型面数与日俱增，同时纹理质量也在持续提升。在这种情况下，空间抗锯齿技术想要解决由于多边形边缘增多而带来的更多画面锯齿问题，需要消耗的性能将会成倍提升（现代硬件甚至仍无法完全驾驭当年一些游戏的 MSAA 8X）。 <br> 另外，随着实时渲染技术的发展，逐渐出现了着色走样的问题，而<span class="control" id="xgc8kf_455">空间抗锯齿技术专注于处理图形边缘锯齿</span> ，对于着色走样带来的闪烁和噪点问题几乎无能为力。因此， <span class="control" id="xgc8kf_456">时域抗锯齿技术在现代游戏中几乎是不可或缺的</span>。</p><p id="xgc8kf_451">然而，总有人因为时域抗锯齿带来的拖影与模糊问题，而认为这是游戏厂商懈怠优化所带来的，他们忽视了技术和硬件提升所带来的全新挑战。 <span class="control" id="xgc8kf_457">时域抗锯齿技术的应用是现代实时渲染技术发展的必然趋势，我们不能只仰慕以前游戏画面那种清晰锐利的风格，而忽视了当时渲染技术的落后性</span>。 <br> 还有人认为着色走样也是如此，然而<span class="control" id="xgc8kf_459">着色走样</span>问题实际上是现代实时渲染流程中所<span class="control" id="xgc8kf_460">无法完全避免</span>的：</p><ul class="list _bullet" id="xgc8kf_452"><li class="list__item" id="xgc8kf_461"><p id="xgc8kf_465">为了一些效果的物理准确性，一些涉及<span class="control" id="xgc8kf_466">积分</span>的算法从<span class="control" id="xgc8kf_467">离线渲染的影视领域</span>逐渐过渡到<span class="control" id="xgc8kf_468">实时渲染的游戏领域</span>。</p></li><li class="list__item" id="xgc8kf_462"><p id="xgc8kf_469">一些积分是<span class="control" id="xgc8kf_471">没有解析解</span>的，这意味着只能使用<span class="control" id="xgc8kf_472">蒙特卡洛积分法</span>进行计算。</p><aside class="prompt" data-type="tip" data-title="" id="xgc8kf_470"><p id="xgc8kf_473">所谓蒙特卡洛积分法可以简单地理解为在积分区域内随机采样然后相加。</p></aside></li><li class="list__item" id="xgc8kf_463"><p id="xgc8kf_474">如果将采样集中到<span class="control" id="xgc8kf_475">单帧</span>上，那么实时渲染要求的<span class="control" id="xgc8kf_476">帧率几乎不可能达标</span> ，于是只能退而求其次，将采样分布到时域上，每次在积分区域内选取随机的采样点。</p></li><li class="list__item" id="xgc8kf_464"><p id="xgc8kf_477">最终将每次采样的贡献进行<span class="control" id="xgc8kf_478">求和</span> ，就可以<span class="emphasis" id="xgc8kf_479">近似求解积分</span>结果，因此现代着色方法常有噪点，特别是涉及到<span class="control" id="xgc8kf_480">粗糙度</span>和<span class="control" id="xgc8kf_481">光源体积</span>时。</p></li></ul><p id="xgc8kf_453">当然也存在一些取巧的解决办法：例如预烘焙方案，在制作团队的电脑上离线烘焙好场景中的一切信息，用空间换时间。但现代游戏大量的动态场景已经导致其不再广泛适用；或者就是直接放弃新技术，不过有人真的希望在现代游戏中看到一些古早妥协的产物吗？</p></section><div class="last-modified">Last modified: 11 March 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="shaderhistoryje.html" class="navigation-links__prev">Java 版光影 发展和轶事</a><a href="howtexturework.html" class="navigation-links__next">资源包 技术科普</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>
<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#FDB71B"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-21T09:06:01.393624241"><title>着色器 技术科普 | MineGraph Docs</title><script type="application/json" id="virtual-toc-data">[{"id":"frdlum_8","level":0,"title":"全局光照","anchor":"#frdlum_8"},{"id":"rsm","level":1,"title":"RSM","anchor":"#rsm"},{"id":"lpv","level":1,"title":"LPV","anchor":"#lpv"},{"id":"vx-pt","level":1,"title":"VX(PT)","anchor":"#vx-pt"},{"id":"frdlum_125","level":0,"title":"环境光遮蔽","anchor":"#frdlum_125"},{"id":"ssao","level":1,"title":"SSAO","anchor":"#ssao"},{"id":"rtao","level":1,"title":"RTAO","anchor":"#rtao"},{"id":"frdlum_164","level":0,"title":"抗锯齿及相关技术","anchor":"#frdlum_164"},{"id":"frdlum_165","level":1,"title":"锯齿现象","anchor":"#frdlum_165"},{"id":"frdlum_176","level":1,"title":"空间抗锯齿","anchor":"#frdlum_176"},{"id":"fxaa","level":2,"title":"FXAA","anchor":"#fxaa"},{"id":"msaa","level":2,"title":"MSAA","anchor":"#msaa"},{"id":"smaa","level":2,"title":"SMAA","anchor":"#smaa"},{"id":"frdlum_199","level":1,"title":"时域抗锯齿","anchor":"#frdlum_199"},{"id":"frdlum_240","level":1,"title":"升采样","anchor":"#frdlum_240"},{"id":"frdlum_270","level":0,"title":"光线追踪在渲染技术中的应用","anchor":"#frdlum_270"},{"id":"frdlum_323","level":0,"title":"技术发展与理解误区","anchor":"#frdlum_323"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="MGC_Docs/page_logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="着色器 技术科普 | MineGraph Docs"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="MineGraph Docs Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://docs.minegraph.cn/md/测试版/shadertech.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="着色器 技术科普 | MineGraph Docs"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://docs.minegraph.cn/md/测试版/shadertech.html#webpage",
    "url": "https://docs.minegraph.cn/md/测试版/shadertech.html",
    "name": "着色器 技术科普 | MineGraph Docs",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://docs.minegraph.cn/md/#website",
    "url": "https://docs.minegraph.cn/md/",
    "name": "MineGraph Docs Help"
}</script><!-- End Schema.org --></head><body data-id="shaderTech" data-main-title="着色器 技术科普" data-article-props="{&quot;seeAlso&quot;:[{&quot;title&quot;:&quot;相关文档&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;shaderbasic.html&quot;,&quot;text&quot;:&quot;着色器 基本概念和轶事&quot;,&quot;tooltip&quot;:&quot;着色器的基本概念和它们与 MC 的历史&quot;,&quot;description&quot;:&quot;着色器的基本概念和它们与 MC 的历史&quot;},{&quot;url&quot;:&quot;terms.html#渲染技术相关&quot;,&quot;text&quot;:&quot;术语表 - 渲染技术相关&quot;,&quot;tooltip&quot;:&quot;总结了一些常用渲染技术大方向的术语&quot;,&quot;description&quot;:&quot;总结了一些常用渲染技术大方向的术语&quot;}]}],&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Library.md|知识库///PopOfScience.md|科普文档"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MineGraph Docs 测试版 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="shaderTech" id="shaderTech.md">着色器 技术科普</h1><aside class="prompt" data-type="warning" data-title="未经优化的文档" id="frdlum_3"><p id="frdlum_4">这篇文档的格式较为不规范，目前正在订正中。</p></aside><aside class="prompt" data-type="note" data-title="阅读建议" id="frdlum_5"><p id="frdlum_6">这篇文档是技术的实际应用，在阅读前你可以先阅读 <a href="shaderbasic.html" id="frdlum_7" data-tooltip="着色器 基本概念">这篇文档</a> 来了解其基本概念。</p></aside><section class="chapter"><h2 id="frdlum_8" data-toc="frdlum_8">全局光照</h2><p id="frdlum_9"><a href="terms.html#gi" id="frdlum_10" data-tooltip="术语表">全局光照</a> （<span class="control" id="frdlum_11">Global Illumination</span> ，简称 <span class="control" id="frdlum_12">GI</span> ）表现了直接照明和间接照明的综合效果，它有多种实现方法，例如辐照度、光线追踪、光子贴图、光照探针等。</p><p id="frdlum_13">当光从光源被发射出来后，碰到障碍物就反射和折射，经过无数次的反射和折射，物体表面和角落都会有光感，像真实的自然光。</p><p id="frdlum_14">全局光照的开销通常很大。渲染带有光线追踪全局光照效果的图片，耗时会较长（取决于场景复杂度）。渲染静态图片可以接受这较长的耗时，但渲染视频或者应用到游戏时，要求的渲染时间就要严格很多，于是便有了各种光栅拟合算法。</p><section class="chapter"><h3 id="rsm" data-toc="rsm">RSM</h3><p id="frdlum_15"><span class="control" id="frdlum_16">Reflective Shadow Maps</span> ，意为<span class="control" id="frdlum_17">反射阴影贴图</span> 。原理为根据表面反弹阴影纹理（从光源视角记录的带表面颜色的纹理）。</p><div class="tabs" id="frdlum_18" data-anchors="[frdlum_19,frdlum_21,frdlum_23]"><div class="tabs__content" data-gtm="tab" id="frdlum_19" data-title="无"><figure id="frdlum_20"><img alt="无 GI" src="MGC_Docs/GI_NONE.png" title="无GI" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_21" data-title="RSM"><figure id="frdlum_22"><img alt="RSM" src="MGC_Docs/GI_RSM.png" title="RSM" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_23" data-title="同屏对比"><ul class="list _bullet" id="frdlum_24"><li class="list__item" id="frdlum_25"><p>无全局光照，左侧表面仅被天空光照照亮。 </p><figure id="frdlum_26"><img alt="无 GI" src="MGC_Docs/GI_NONE.png" title="无GI" width="1920" height="1080"></figure></li><li class="list__item" id="frdlum_27"><p>RSM 全局光照，左侧表面被右侧亮处的泥土染上了黄色。 </p><figure id="frdlum_28"><img alt="RSM" src="MGC_Docs/GI_RSM.png" title="RSM" width="1920" height="1080"></figure></li></ul></div></div><aside class="prompt" data-type="tip" data-title="" id="frdlum_29"><p id="frdlum_30">参考资料： <a href="https://zhuanlan.zhihu.com/p/357259069" id="frdlum_31" data-external="true" rel="noopener noreferrer">【论文复现】Reflective Shadow Maps</a></p></aside></section><section class="chapter"><h3 id="lpv" data-toc="lpv">LPV</h3><p id="frdlum_32"><span class="control" id="frdlum_33">Light Propagation Volumes</span> ，意为<span class="control" id="frdlum_34">辐照体积传播</span> 。是 CryEngine 3 提出的一种实时的、无需任何预计算的全局光照技术，其创造性地提出了使用体素来存储、传播间接光照的方法。</p><p id="frdlum_35">LPV 首先将整个场景划分为体素，将整个场景离散开来（对 Minecraft 来说可以说是天然优势），每一个格子的光照就是其他格子光照乘以贡献的总和，最终形成一个庞大的<span class="control" id="frdlum_36">多项式</span>。 <br> 直接求解每个格子内的光照是不现实的，解决方法是让光照像墨滴一样在这些格子中弥散、传播，从而在时域上求解间接光照。</p><p id="frdlum_38">你可以将它视为一种以体素大小为精度的光线追踪数学拟合。</p><aside class="prompt" data-type="tip" data-title="" id="frdlum_39"><p id="frdlum_40"><span class="emphasis" id="frdlum_41">Cody Darr</span> 曾经发布过一个 SEUS 的测试版 <a href="https://www.patreon.com/posts/seus-lpvgi-e1-20122720" id="frdlum_42" data-external="true" rel="noopener noreferrer">SEUS LPVGI</a> ，但是我们发现如今这个光影已经无法在新驱动上运行； <br> 在 <span class="emphasis" id="frdlum_44">GeForceLegend</span> 检查代码之后，发现其中使用了很多的 <code class="code" id="frdlum_45">mod(&lt;type&gt;, int)</code></p><div class="code-block" data-lang="c">
&lt;type&gt; A;
int B;
^^^
[...];
mod(A, B);
       ^
</div><p id="frdlum_47">这在自帕斯卡架构开始的显卡上会出现异常。</p><p id="frdlum_48">要想修复这个问题，我们只需要将其第二个参数 <code class="code" id="frdlum_49">B</code> 显式转换为 <code class="code" id="frdlum_50">float</code> 类型即可：</p><div class="code-block" data-lang="c">
&lt;type&gt; A;
int B;
[...];
mod(A, float(B));
</div></aside><div class="tabs" id="frdlum_52" data-anchors="[frdlum_53,frdlum_55,frdlum_57,frdlum_59]"><div class="tabs__content" data-gtm="tab" id="frdlum_53" data-title="无"><figure id="frdlum_54"><img alt="无 GI" src="MGC_Docs/GI_NONE_2.png" title="无GI" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_55" data-title="RSM + SSAO"><figure id="frdlum_56"><img alt="RSM" src="MGC_Docs/GI_RSM_2.png" title="RSM" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_57" data-title="LPV"><figure id="frdlum_58"><img alt="LPV" src="MGC_Docs/GI_LPV.png" title="LPV" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_59" data-title="同屏对比"><ul class="list _bullet" id="frdlum_60"><li class="list__item" id="frdlum_61"><p id="frdlum_62">无全局光照，周围的环境只有天空颜色。</p><figure id="frdlum_63"><a href="MGC_Docs/GI_NONE_2.png" class="lightbox"><img alt="无 GI" src="MGC_Docs/GI_NONE_2.png" title="无GI" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_64"><p id="frdlum_65">RSM 全局光照，环境染上了品红色混凝土的颜色，但右侧近处的石头上有明显的伪影，左侧靠得更近的石头颜色反而不明显。</p><figure id="frdlum_66"><a href="MGC_Docs/GI_RSM_2.png" class="lightbox"><img alt="RSM" src="MGC_Docs/GI_RSM_2.png" title="RSM" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_67"><p id="frdlum_68">LPV 全局光照，环境更加准确地染上了颜色。</p><figure id="frdlum_69"><a href="MGC_Docs/GI_LPV.png" class="lightbox"><img alt="LPV" src="MGC_Docs/GI_LPV.png" title="LPV" width="1920" height="1080"></a></figure></li></ul></div></div><aside class="prompt" data-type="tip" data-title="" id="frdlum_70"><p id="frdlum_71">参考资料： <a href="https://zhuanlan.zhihu.com/p/412287249" id="frdlum_72" data-external="true" rel="noopener noreferrer">Light Propagation Volumes</a></p></aside></section><section class="chapter"><h3 id="vx-pt" data-toc="vx-pt">VX(PT)</h3><p id="frdlum_73"><span class="control" id="frdlum_74">Voxel (Path Tracing) Global Illumination</span> ，意为<span class="control" id="frdlum_75">体素（光追）全局光照</span> 。也是一个两趟的、实时的全局光照算法，它以体积渲染作为算法核心，将场景通过体素离散化为树状结构并存储光照计算相关信息，通常辅以路径追踪，相比 LPV 拥有更好的效果。</p><aside class="prompt" data-type="note" data-title="" id="frdlum_76"><p id="frdlum_77">室内场景为了突出场景暗部，已进行了加强曝光处理。</p></aside><div class="tabs" id="frdlum_78" data-group="VX" data-anchors="[frdlum_79,frdlum_82,frdlum_86,frdlum_89]"><div class="tabs__content" data-gtm="tab" id="frdlum_79" data-sync-tabs="RSM" data-title="RSM + AO"><figure id="frdlum_80"><img alt="RSM" src="MGC_Docs/GI_RSM_4.png" title="RSM" data-dark-src="MGC_Docs/GI_RSM_4_dark.png" width="1920" height="1080"></figure><figure id="frdlum_81"><img alt="RSM" src="MGC_Docs/GI_RSM_3.png" title="RSM" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_82" data-sync-tabs="LPV" data-title="LPV"><figure id="frdlum_83"><img alt="LPV" src="MGC_Docs/GI_LPV_2.png" title="LPV" data-dark-src="MGC_Docs/GI_LPV_2_dark.png" width="1920" height="1080"></figure><aside class="prompt" data-type="note" data-title="" id="frdlum_84"><p id="frdlum_85">由于 LPVGI 在 1.20 无法正常运行，这里只列出一张图片。</p></aside></div><div class="tabs__content" data-gtm="tab" id="frdlum_86" data-sync-tabs="VX" data-title="体素光追"><figure id="frdlum_87"><img alt="体素光追" src="MGC_Docs/GI_VXGI_2.png" title="体素光追" data-dark-src="MGC_Docs/GI_VXGI_2_dark.png" width="1920" height="1080"></figure><figure id="frdlum_88"><img alt="体素光追" src="MGC_Docs/GI_VXGI.png" title="体素光追" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_89" data-sync-tabs="Compare" data-title="同屏对比"><ul class="list _bullet" id="frdlum_90"><li class="list__item" id="frdlum_91"><p id="frdlum_92">RSM 全局光照 + GTAO：</p><ul class="list _bullet" id="frdlum_93"><li class="list__item" id="frdlum_94"><p id="frdlum_95">受原版光照和伪影影响，这个场景显得非常脏。</p><figure id="frdlum_96"><a href="MGC_Docs/GI_RSM_4.png" class="lightbox"><img alt="RSM" src="MGC_Docs/GI_RSM_4.png" title="RSM" data-dark-src="MGC_Docs/GI_RSM_4_dark.png" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_97"><p id="frdlum_98">被遮挡的场景也一股脑全亮了。</p><figure id="frdlum_99"><a href="MGC_Docs/GI_RSM_3.png" class="lightbox"><img alt="RSM 全局光照" src="MGC_Docs/GI_RSM_3.png" title="RSM全局光照" width="1920" height="1080"></a></figure></li></ul></li><li class="list__item" id="frdlum_100"><p id="frdlum_101">LPV 全局光照，受辐照体积限制，顶部露天区域的两侧看起来像是漏光了。</p><figure id="frdlum_102"><a href="MGC_Docs/GI_LPV_2.png" class="lightbox"><img alt="LPV" src="MGC_Docs/GI_LPV_2.png" title="LPV" data-dark-src="MGC_Docs/GI_LPV_2_dark.png" width="1920" height="1080"></a></figure><aside class="prompt" data-type="note" data-title="" id="frdlum_103"><p id="frdlum_104">这张图片中没有使用任何 AO，墙角产生的阴影全都来源于 LPV 的特性。</p></aside></li><li class="list__item" id="frdlum_105"><p id="frdlum_106">基于体素的光线追踪全局光照：</p><ul class="list _bullet" id="frdlum_107"><li class="list__item" id="frdlum_108"><p id="frdlum_109">产生了更加干净准确的照明。</p><figure id="frdlum_110"><a href="MGC_Docs/GI_VXGI_2.png" class="lightbox"><img alt="体素光追" src="MGC_Docs/GI_VXGI_2.png" title="体素光追" data-dark-src="MGC_Docs/GI_VXGI_2_dark.png" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_111"><p id="frdlum_112">可以注意到地毯和楼梯在床上投下了相对窗户这个间接光源位置的准确阴影。</p><figure id="frdlum_113"><a href="MGC_Docs/GI_VXGI.png" class="lightbox"><img alt="体素光追全局光照" src="MGC_Docs/GI_VXGI.png" title="体素光追全局光照" width="1920" height="1080"></a></figure></li></ul></li></ul></div></div><div class="tabs" id="frdlum_114" data-group="VX" data-anchors="[frdlum_115,frdlum_116,frdlum_117]"><div class="tabs__content" data-gtm="tab" id="frdlum_115" data-sync-tabs="RSM" data-title="RSM + AO"></div><div class="tabs__content" data-gtm="tab" id="frdlum_116" data-sync-tabs="VX" data-title="体素光追"></div><div class="tabs__content" data-gtm="tab" id="frdlum_117" data-sync-tabs="Compare" data-title="同屏对比"></div></div><aside class="prompt" data-type="tip" data-title="" id="frdlum_118"><ul class="list _bullet" id="frdlum_119"><li class="list__item" id="frdlum_120"><p>受限于 OptiFine 架构，如今的 Java 版光线追踪光影均基于体素化，并混合使用基于体素的 LPV 和 PT。</p></li><li class="list__item" id="frdlum_121"><p>使用体素不代表我们只能按方块追踪所有物体，我们可以定义每个体素的形状，从而产生符合形状的阴影。</p></li></ul></aside><aside class="prompt" data-type="tip" data-title="" id="frdlum_122"><p id="frdlum_123">参考资料： <a href="https://zhuanlan.zhihu.com/p/414691569" id="frdlum_124" data-external="true" rel="noopener noreferrer">Voxel Global Illumination 体素全局光照（一）</a></p></aside></section></section><section class="chapter"><h2 id="frdlum_125" data-toc="frdlum_125">环境光遮蔽</h2><p id="frdlum_126"><a href="terms.html#ao" id="frdlum_127" data-tooltip="术语表">环境光遮蔽</a> （<span class="control" id="frdlum_128">Ambient Occlusion</span> ，简称 <span class="control" id="frdlum_129">AO</span> ）是一种广泛用于现代游戏渲染的图形技术，其算力消耗相对较少的同时能带来非常大的画面观感改进，其模拟了现实世界中光线在物体的凹角和接缝中产生阴影的现象。</p><p id="frdlum_130">在现实中，当光线到达物体的凹角和接缝时，由于空间被物体阻挡，光线无法充分照射到一些区域，导致这些区域相对较暗，形成阴影。</p><p id="frdlum_131">在没有环境光遮蔽的情况下，画面看起来像是被均匀的强光照亮，没有阴影和深度。详情可以参考在 Minecraft 中关闭 <code class="code" id="frdlum_132">平滑光照</code> 效果后的一些表现，很多手游也有很多缺失此效果，导致画面显得非常扁平。</p><p id="frdlum_133">目前在 Java 版的光影中主要使用 SSAO，也是游戏界使用最多的环境光遮蔽技术。</p><section class="chapter"><h3 id="ssao" data-toc="ssao">SSAO</h3><p id="frdlum_134"><span class="control" id="frdlum_135">Screen-space AO</span> ，意为<span class="control" id="frdlum_136">屏幕空间环境光遮蔽</span> ，是目前业界内应用最广泛的环境光遮蔽技术。SSAO 通过分析场景中各个像素点周围的几何信息来计算该像素点处的遮蔽程度。其计算效率最高，但相对不够精确。</p><p id="frdlum_137">目前常用的环境光遮蔽技术有 SSAO、HBAO（Horizon-Based AO，水平基准环境光遮蔽）和 GTAO（Ground Truth AO，基准真相环境光遮蔽）。HBAO 和 GTAO 作为 SSAO 的衍生，能产生更加准确的遮蔽阴影。</p><div class="tabs" id="frdlum_138" data-anchors="[frdlum_139,frdlum_141,frdlum_143,frdlum_145]"><div class="tabs__content" data-gtm="tab" id="frdlum_139" data-title="无"><figure id="frdlum_140"><img alt="无 AO" src="MGC_Docs/AO_NONE.png" title="无AO" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_141" data-title="SSAO"><figure id="frdlum_142"><img alt="SSAO" src="MGC_Docs/AO_SSAO.png" title="SSAO" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_143" data-title="GTAO"><figure id="frdlum_144"><img alt="GTAO" src="MGC_Docs/AO_GTAO.png" title="GTAO" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_145" data-title="同屏对比"><ul class="list _bullet" id="frdlum_146"><li class="list__item" id="frdlum_147"><p id="frdlum_148"><span class="control" id="frdlum_149">没有 AO</span> ，场景的纵深感弱，近处栅栏看起来像悬空的。图中的明暗均由原版天空光照产生。</p><figure id="frdlum_150"><a href="MGC_Docs/AO_NONE.png" class="lightbox"><img alt="无 AO" src="MGC_Docs/AO_NONE.png" title="无AO" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_151"><p id="frdlum_152"><span class="control" id="frdlum_153">SSAO</span> ，注意房屋窗户的栅栏和村民周围，室内的光线更加昏暗，近处的栅栏也产生了阴影，产生了纵深感。</p><figure id="frdlum_154"><a href="MGC_Docs/AO_SSAO.png" class="lightbox"><img alt="SSAO" src="MGC_Docs/AO_SSAO.png" title="SSAO" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_155"><p id="frdlum_156"><span class="control" id="frdlum_157">GTAO</span> ，注意村民周围阴影与 SSAO 的区别，暗角的过渡更加均匀，近处的栅栏产生的阴影不在紧贴着横杆，其他狭缝中的阴影也更加浓厚。</p><figure id="frdlum_158"><a href="MGC_Docs/AO_GTAO.png" class="lightbox"><img alt="GTAO" src="MGC_Docs/AO_GTAO.png" title="GTAO" width="1920" height="1080"></a></figure></li></ul></div></div></section><section class="chapter"><h3 id="rtao" data-toc="rtao">RTAO</h3><p id="frdlum_159"><span class="control" id="frdlum_160">Ray Tracing AO</span> ，意为<span class="control" id="frdlum_161">光线追踪环境光遮蔽</span> 。通过光线追踪仅计算 AO，效果最好的同时性能消耗要比光线追踪全局光照低（在 AO 中仍然是最高的）。</p><aside class="prompt" data-type="tip" data-title="" id="frdlum_162"><p id="frdlum_163">在光线追踪全局光照效果相对完整的一些光影或游戏中，其不会单独列出，而是作为光线追踪间接光照流程中的一种自然产物。</p></aside></section></section><section class="chapter"><h2 id="frdlum_164" data-toc="frdlum_164">抗锯齿及相关技术</h2><section class="chapter"><h3 id="frdlum_165" data-toc="frdlum_165">锯齿现象</h3><p id="frdlum_166"><span class="control" id="frdlum_167">Aliasing</span> ，是由于渲染过程中<span class="control" id="frdlum_168">采样不足</span>而引起的，也被称为<span class="control" id="frdlum_169">走样</span> 。在游戏渲染中，主要会遇到两种类型的走样，分别是几何走样和着色走样。</p><ul class="list _bullet" id="frdlum_170"><li class="list__item" id="frdlum_171"><p>几何走样（Geometric Aliasing）是由于光栅化过程中对<span class="control" id="frdlum_172">几何图形边缘</span>的采样不足而导致的。现代屏幕由像素组成，像素的本质是一个个离散的小方格，因此当尝试表示连续的斜线或曲线时，就会出现锯齿状的走样，使得图形边缘看起来不平滑。</p></li><li class="list__item" id="frdlum_173"><p>着色走样（Shading Aliasing）是由于渲染过程中的<span class="control" id="frdlum_174">采样数不足</span>而引起的。例如在体积渲染中，如果采样数较低，就会导致体积雾和体积云等效果出现<span class="control" id="frdlum_175">闪烁和噪点</span> ，一些光线追踪光影也会在处理光照时出现这些现象。</p></li></ul></section><section class="chapter"><h3 id="frdlum_176" data-toc="frdlum_176">空间抗锯齿</h3><p id="frdlum_177">空间抗锯齿技术是针对几何走样问题的传统解决方案。由于其实现方式，通常会造成不可忽视的性能损耗，同时<span class="control" id="frdlum_178">对于着色走样问题几乎无效</span> ，因此在目前的游戏中，单独的空间抗锯齿技术已不多见。</p><p id="frdlum_179">比较主流的空间抗锯齿技术有 FXAA、MSAA、SMAA 等，在 Java 版中，OptiFine 内置实现了 FXAA。</p><aside class="prompt" data-type="note" data-title="" id="frdlum_180"><p id="frdlum_181">以下效果评判仅针对几何走样问题。</p></aside><section class="chapter"><h4 id="fxaa" data-toc="fxaa">FXAA</h4><p id="frdlum_182"><span class="control" id="frdlum_183">Fast Approximate Anti-Aliasing</span> ，即<span class="control" id="frdlum_184">快速近似抗锯齿</span> 。通过简单的卷积混合颜色来减少锯齿。</p><p id="frdlum_185">其优势在于性能消耗极低，效果在大多是时候都可以接受，但其建立在对画面所有图形边缘进行无差别柔化处理的基础上，导致观感模糊。</p></section><section class="chapter"><h4 id="msaa" data-toc="msaa">MSAA</h4><p id="frdlum_186"><span class="control" id="frdlum_187">Multisampling Anti-Aliasing</span> ，即<span class="control" id="frdlum_188">多重采样抗锯齿</span> ，属于 <span class="control" id="frdlum_189">SSAA</span> （Super-Sampling Anti-Aliasing，超级采样抗锯齿）的性能改进版。SSAA 直接将整个画面以更高分辨率渲染再降采样到画面，而 MSAA 则仅对图形边缘进行处理。</p><p id="frdlum_190">其性能消耗最高（取决于渲染倍率），效果也最好（非常鲁莽的实现，仅针对几何走样）。</p><p id="frdlum_191">其最大的问题是与现代 <a href="terms.html#延迟渲染法" id="frdlum_192" data-tooltip="将场景的各种信息存储起来，再在之后的着色器中统一计算。">延迟渲染</a> 不兼容，因此几乎没有游戏使用。</p></section><section class="chapter"><h4 id="smaa" data-toc="smaa">SMAA</h4><p id="frdlum_193"><span class="control" id="frdlum_194">Subpixel Morphological Anti-Aliasing</span> ，即<span class="control" id="frdlum_195">子像素增强抗锯齿</span> ，是 <span class="control" id="frdlum_196">MLAA</span> （Morphological Anti-Aliasing，形态学抗锯齿）的改进版。MLAA 通过分析图形边缘然后进行平滑处理，SMAA 则在此之上进一步发展，使得图像更清晰。</p><p id="frdlum_197">其性能消耗比 MSAA 低得多，接近 FXAA 的水平，而效果却比 FXAA 更好。</p><p id="frdlum_198">由于其算法特性，当物体移动时可能会产生闪烁。</p></section></section><section class="chapter"><h3 id="frdlum_199" data-toc="frdlum_199">时域抗锯齿</h3><p id="frdlum_200"><span class="control" id="frdlum_201">Temporal Anti-Aliasing</span> ，即<span class="control" id="frdlum_202">时域抗锯齿</span>／ <span class="control" id="frdlum_203">时间性抗锯齿</span> 。首先在时间上分散采样点，然后将当前帧的渲染结果与前一帧进行比较，以确定物体的运动和变化，之后进行混合以平滑图像并减少锯齿。</p><p id="frdlum_204">不同于空间抗锯齿的边缘检测处理，时域抗锯齿使用在多个帧之间进行信息累积和混合的方案。是现代游戏中运用最多的抗锯齿技术类型。</p><p id="frdlum_205">其性能要比 MSAA 好得多，而且能<span class="control" id="frdlum_206">在一定程度上解决着色走样</span> 。但是由于其时间性，不可避免地会在运动场景中产生拖影和模糊，如果抗锯齿参数不够优秀，还会造成明显的抖动感。</p><aside class="prompt" data-type="tip" data-title="" id="frdlum_207"><ul class="list _bullet" id="frdlum_208"><li class="list__item" id="frdlum_209"><p>在 Java 版中，几乎所有现代光影都使用 TAA 或混合使用 TAA 和 FXAA。</p></li><li class="list__item" id="frdlum_210"><p>时域抗锯齿通常也会混合空间算法，将抗锯齿的上升到时空域，比如 <span class="control" id="frdlum_211">Filmic SMAA T2X</span> ，它不仅拥有 SMAA 的优秀性能，还解决了 SMAA 的闪烁问题。</p></li></ul></aside><div class="tabs" id="frdlum_212" data-anchors="[frdlum_213,frdlum_215,frdlum_217,frdlum_219,frdlum_221,frdlum_223]"><div class="tabs__content" data-gtm="tab" id="frdlum_213" data-title="无"><figure id="frdlum_214"><img alt="无抗锯齿" src="MGC_Docs/AA_NONE.png" title="无抗锯齿" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_215" data-title="FXAA"><figure id="frdlum_216"><img alt="FXAA" src="MGC_Docs/AA_FXAA.png" title="FXAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_217" data-title="SSAA"><figure id="frdlum_218"><img alt="SSAA" src="MGC_Docs/AA_SSAA.png" title="SSAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_219" data-title="TAA"><figure id="frdlum_220"><img alt="TAA" src="MGC_Docs/AA_TAA.png" title="TAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_221" data-title="TAA + FXAA"><figure id="frdlum_222"><img alt="TAA + FXAA" src="MGC_Docs/AA_TAA_FXAA.png" title="TAA+FXAA" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_223" data-title="同屏对比"><ul class="list _bullet" id="frdlum_224"><li class="list__item" id="frdlum_225"><p id="frdlum_226">无抗锯齿，几何走样很明显。</p><figure id="frdlum_227"><a href="MGC_Docs/AA_NONE.png" class="lightbox"><img alt="无抗锯齿" src="MGC_Docs/AA_NONE.png" title="无抗锯齿" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_228"><p id="frdlum_229">光影内置的 FXAA，解决了部分几何走样的锯齿，几乎不损耗性能。</p><figure id="frdlum_230"><a href="MGC_Docs/AA_FXAA.png" class="lightbox"><img alt="FXAA" src="MGC_Docs/AA_FXAA.png" title="FXAA" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_231"><p id="frdlum_232">利用 OptiFine 提供的渲染精细度实现的 SSAA 2X，效果极佳，但是性能损耗极大。</p><figure id="frdlum_233"><a href="MGC_Docs/AA_SSAA.png" class="lightbox"><img alt="SSAA" src="MGC_Docs/AA_SSAA.png" title="SSAA" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_234"><p id="frdlum_235">光影内置的 TAA，效果和 SSAA 相当，但是几乎不损耗性能。注意：它没有对实体进行抗锯齿。</p><figure id="frdlum_236"><a href="MGC_Docs/AA_TAA.png" class="lightbox"><img alt="TAA" src="MGC_Docs/AA_TAA.png" title="TAA" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_237"><p id="frdlum_238">将光影的 TAA 和 FXAA 全部启用，实体的几何走样和着色走样都消除了，且性能几乎不损耗。</p><figure id="frdlum_239"><img alt="TAA + FXAA" src="MGC_Docs/AA_TAA_FXAA.png" title="TAA+FXAA" width="1920" height="1080"></figure></li></ul></div></div></section><section class="chapter"><h3 id="frdlum_240" data-toc="frdlum_240">升采样</h3><p id="frdlum_241"><span class="control" id="frdlum_242">Up-sampling</span> ，是一种增加图像分辨率的技术，也分为空间升采样和时域升采样。现代的升采样技术一般用于先降低渲染分辨率，将效果处理完毕后再提升到原始分辨率，来提升性能。</p><ul class="list _bullet" id="frdlum_243"><li class="list__item" id="frdlum_244"><p>空间升采样如今已经几乎不使用了，曾经的 FSR 1.0 和 DLSS 1.0 都是空间升采样。 </p><ul class="list _bullet" id="frdlum_245"><li class="list__item" id="frdlum_246"><p>FSR 1.0 只是通过缩放、插值和锐化来试图还原，造成较为强烈的涂抹感；</p></li><li class="list__item" id="frdlum_247"><p>DLSS 1.0 虽然利用了 AI，但其需要针对每个游戏进行训练，泛用性差，且质量较低。</p></li></ul></li><li class="list__item" id="frdlum_248"><p>时域升采样一般伴随着抗锯齿进行，如 TAAU、DLSS 2.0 和 FSR 2.0 等。在 Java 版的一些光影中实现了 TAAU。</p></li><li class="list__item" id="frdlum_249"><p>TAAU 基于 TAA 而实现，多帧信息不仅用于抗锯齿，还用于提高图像分辨率。SEUS PTGI 所用的 HRR（Half-Resolution Rendering，半分辨率渲染）也是类似原理。</p></li></ul><div class="tabs" id="frdlum_250" data-anchors="[frdlum_251,frdlum_253,frdlum_255,frdlum_257]"><div class="tabs__content" data-gtm="tab" id="frdlum_251" data-title="原生分辨率"><figure id="frdlum_252"><img alt="TAAU_OFF_100P.png" src="MGC_Docs/TAAU_OFF_100P.png" title="TAAU_OFF_100P.png" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_253" data-title="50% 渲染分辨率"><figure id="frdlum_254"><img alt="TAAU_OFF_50P.png" src="MGC_Docs/TAAU_OFF_50P.png" title="TAAU_OFF_50P.png" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_255" data-title="50% TAAU"><figure id="frdlum_256"><img alt="TAAU_ON_50P.png" src="MGC_Docs/TAAU_ON_50P.png" title="TAAU_ON_50P.png" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_257" data-title="同屏对比"><ul class="list _bullet" id="frdlum_258"><li class="list__item" id="frdlum_259"><p id="frdlum_260">原生分辨率图像，画面清晰，但性能较差。</p><figure id="frdlum_261"><a href="MGC_Docs/TAAU_OFF_100P.png" class="lightbox"><img alt="TAAU_OFF_100P.png" src="MGC_Docs/TAAU_OFF_100P.png" title="TAAU_OFF_100P.png" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_262"><p id="frdlum_263">50% 渲染分辨率，禁用 TAAU，性能最好，但画面模糊。</p><figure id="frdlum_264"><a href="MGC_Docs/TAAU_OFF_50P.png" class="lightbox"><img alt="TAAU_OFF_50P.png" src="MGC_Docs/TAAU_OFF_50P.png" title="TAAU_OFF_50P.png" width="1920" height="1080"></a></figure></li><li class="list__item" id="frdlum_265"><p id="frdlum_266">原生分辨率，启用 50% TAAU，性能和画质平衡。</p><figure id="frdlum_267"><a href="MGC_Docs/TAAU_ON_50P.png" class="lightbox"><img alt="TAAU_ON_50P.png" src="MGC_Docs/TAAU_ON_50P.png" title="TAAU_ON_50P.png" width="1920" height="1080"></a></figure></li></ul></div></div><p id="frdlum_268">这是 SEUS PTGI HRR 2.1 GFME 升采样（TAAU + FXAA）前后的差异，由于其是点对点地降采样，因此 TAAU 处理效果更为明显：</p><figure id="frdlum_269"><a href="MGC_Docs/AA_differ.png" class="lightbox"><img alt="升采样差异" src="MGC_Docs/AA_differ.png" title="升采样前后差异" width="1920" height="1080"></a></figure></section></section><section class="chapter"><h2 id="frdlum_270" data-toc="frdlum_270">光线追踪在渲染技术中的应用</h2><aside class="prompt" data-type="warning" data-title="" id="frdlum_271"><p id="frdlum_272">我们在此讨论的是相对狭义的光线追踪技术应用，即大众所认知的。如果严格按照光线追踪渲染流程来评判，那么类似于屏幕空间反射等技术也属于光线追踪范畴。</p></aside><p id="frdlum_273">在 Java 版中，我们主要使用<span class="control" id="frdlum_274">路径追踪</span> 。在此之前的光影，考虑到 Minecraft 游戏过程的动态性和一些算法限制，没办法像其他游戏一样使用预烘焙等类似技术来改善光栅化渲染。例如光源仅能按照原版的发光机制来单色发光；反射面完全无法反射屏幕外的物体（天空部分除外）等。 <br> 因此，在 Java 版的传统光栅光影中，效果相比其他光栅化游戏显得较为逊色，而光线追踪的实现为 Java 版带来了光影效果的重大革新。</p><p id="frdlum_276">SEUS 光影作者 Cody Darr 在 2018 年 2 月发布了最早的 Java 版体素化实时光线追踪实现，这甚至<span class="control" id="frdlum_277">早于 RTX 显卡的发布</span>。 <br> 其原理是将原本用于存储阴影的 <code class="code" id="frdlum_279">shadowcolor</code> 缓冲区通过几何着色器来记录场景体素，不过这也导致了体素记录距离与阴影分辨率直接挂钩（每个像素记录一个方块信息）。</p><p id="frdlum_280">由于体素化信息不方便存储实体，自 <span class="control" id="frdlum_281">PTGI E3</span> 开始，其将部分分辨率用于了传统光栅阴影映射，这极大限制了光线追踪的最大距离。使用 <code class="code" id="frdlum_282">16384</code> 这样的极限阴影分辨率，才能支持相对远距离的光线追踪，而这几乎必然会导致性能和显存两开花，如今仍有很多光影在尝试突破这些难关。</p><ul class="list _bullet" id="frdlum_283"><li class="list__item" id="frdlum_284"><p>由于使用的是 OpenGL，Java 版光线追踪<span class="control" id="frdlum_285">无法调用光线追踪加速硬件</span> 。光影作者们的应对方法是使用<span class="control" id="frdlum_286">辐照度缓存</span>来优化计算量，同时采用 <span class="control" id="frdlum_287">SVGF 过滤器</span>进行降噪处理。 </p><ul class="list _bullet" id="frdlum_288"><li class="list__item" id="frdlum_289"><p>辐照度（在此类场景中也可称为<span class="control" id="frdlum_290">照度</span> ，即光学单位 <span class="emphasis" id="frdlum_291">lux</span> ；在渲染方程的能量传输语境中，辐照度的单位是 <span class="emphasis" id="frdlum_292">W/m&sup2;</span> ）缓存通过时域求解多项式缓存场景的粗略照明信息。在渲染时对这些数据进行插值，与光线追踪结果相互影响，避免对大量光子进行多次反弹求交。</p></li><li class="list__item" id="frdlum_293"><p>SVGF 过滤器的作用是结合时间和空间上的信息对画面进行降噪。利用过去几帧的深度、颜色、法线信息，并加入计算权重，以此估计当前像素区域样本分布的方差，据此进行空间过滤，最终达到降噪目的。</p></li><li class="list__item" id="frdlum_294"><p>不过上述过程会导致暗光下发生闪烁、拖影和纹理细节损失等问题，这也是目前必须妥协的问题。</p></li></ul></li><li class="list__item" id="frdlum_295"><p>此外，有时我们还能在一些光影中见到 SSPT，当它们与体素光追混合使用时，可以缓解一些非完整方块的体素形态问题（例如半砖在体素中的形态是完整方块或者直接被忽略时）。</p></li></ul><p id="frdlum_296">截止到目前， <span class="control" id="frdlum_297">Vulkanite</span> 为光影引入了 <span class="control" id="frdlum_298">Vulkan</span> ，解决了诸多技术问题，并支持调用<span class="control" id="frdlum_299">光线追踪加速单元（RT Core） <span class="control" id="frdlum_300">来提升性能。但</span>该模组本身的完成度仍是个问题，因此目前难以依赖</span>。 <br><span class="control" id="frdlum_302">Focal</span> 也完成了 Fabric 和 Forge 版的统一，提高模组兼容性并开始专注于 Focal VK 的开发。</p><p id="frdlum_303">在上文中，我们已经展示了光线追踪如何影响全局光照，这里我们再给出一些光线追踪的优势示例。</p><ul class="list _bullet" id="frdlum_304"><li class="list__item" id="frdlum_305"><p id="frdlum_306">反射视野外的物体</p><div class="tabs" id="frdlum_307" data-anchors="[frdlum_308,frdlum_310]"><div class="tabs__content" data-gtm="tab" id="frdlum_308" data-title="屏幕空间反射"><figure id="frdlum_309"><img alt="屏幕空间反射" src="MGC_Docs/Ref_SS.png" title="屏幕空间反射" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_310" data-title="光线追踪反射"><figure id="frdlum_311"><img alt="光线追踪反射" src="MGC_Docs/Ref_PT.png" title="光线追踪反射" width="1920" height="1080"></figure><aside class="prompt" data-type="tip" data-title="" id="frdlum_312"><p id="frdlum_313">在这张图中，你可以发现铁块近处的地面比旁边更亮，这就是由于铁块表面光滑，反射太阳光形成了<span class="control" id="frdlum_314">焦散</span>。</p></aside></div></div></li><li class="list__item" id="frdlum_315"><p id="frdlum_316">精确方块光源</p><div class="tabs" id="frdlum_317" data-anchors="[frdlum_318,frdlum_320]"><div class="tabs__content" data-gtm="tab" id="frdlum_318" data-title="原版方块光源"><figure id="frdlum_319"><img alt="原版光源特性" src="MGC_Docs/BL_Vanilla.png" title="原版光源" width="1920" height="1080"></figure></div><div class="tabs__content" data-gtm="tab" id="frdlum_320" data-title="光线追踪方块光源"><figure id="frdlum_321"><img alt="光线追踪光源特性" src="MGC_Docs/BL_PT.png" title="光线追踪光源" width="1920" height="1080"></figure></div></div></li></ul><p id="frdlum_322">除此之外，光线追踪还有折射、焦散、阴影和更好的 PBR 特性支持等功能，不过对画面的贡献相对更小，或者是很少有在 Java 版实现，因此不做另外展示。</p></section><section class="chapter"><h2 id="frdlum_323" data-toc="frdlum_323">技术发展与理解误区</h2><p id="frdlum_324">随着硬件的不断发展，现代游戏的模型面数与日俱增，同时纹理质量也在持续提升。在这种情况下，空间抗锯齿技术想要解决由于多边形边缘增多而带来的更多画面锯齿问题，需要消耗的性能将会成倍提升（现代硬件甚至仍无法完全驾驭当年一些游戏的 MSAA 8X）。 <br> 另外，随着实时渲染技术的发展，逐渐出现了着色走样的问题，而<span class="control" id="frdlum_326">空间抗锯齿技术专注于处理图形边缘锯齿</span> ，对于着色走样带来的闪烁和噪点问题几乎无能为力。因此， <span class="control" id="frdlum_327">时域抗锯齿技术在现代游戏中几乎是不可或缺的</span>。</p><p id="frdlum_328">然而，总有人因为时域抗锯齿带来的拖影与模糊问题，而认为这是游戏厂商懈怠优化所带来的骗局。他们忽视了技术和硬件提升所带来的全新挑战。 <span class="control" id="frdlum_329">时域抗锯齿技术的应用是现代实时渲染技术发展的必然趋势，我们不能只仰慕以前游戏画面那种清晰锐利的风格，而忽视了当时渲染技术的落后性</span>。</p><p id="frdlum_330">还有人认为着色走样是游戏厂商懈怠优化而导致的骗局，然而<span class="control" id="frdlum_331">着色走样</span>问题实际上是现代实时渲染流程中所<span class="control" id="frdlum_332">无法完全避免</span>的：</p><ul class="list _bullet" id="frdlum_333"><li class="list__item" id="frdlum_334"><p id="frdlum_335">为了一些效果的物理准确性，一些涉及<span class="control" id="frdlum_336">积分</span>的算法从<span class="control" id="frdlum_337">离线渲染的影视领域</span>逐渐过渡到<span class="control" id="frdlum_338">实时渲染的游戏领域</span>。</p></li><li class="list__item" id="frdlum_339"><p id="frdlum_340">而一些积分是<span class="control" id="frdlum_341">没有解析解</span>的，这意味着只能在时域上使用<span class="control" id="frdlum_342">蒙特卡洛积分法</span>进行计算。</p><aside class="prompt" data-type="tip" data-title="" id="frdlum_343"><p id="frdlum_344">可以简单地理解为在积分区域内随机采样。</p></aside></li><li class="list__item" id="frdlum_345"><p id="frdlum_346">如果将采样集中到<span class="control" id="frdlum_347">单帧</span>上，那么实时渲染要求的<span class="control" id="frdlum_348">帧率几乎不可能达标</span> ，于是只能退而求其次，将采样分布到时域上，每次在积分区域内选取随机的采样位置。</p></li><li class="list__item" id="frdlum_349"><p id="frdlum_350">最终将每次采样的贡献进行<span class="control" id="frdlum_351">求和</span> ，就可以<span class="emphasis" id="frdlum_352">近似求解积分</span>结果，因此现代着色方法常有噪点，特别是涉及到<span class="control" id="frdlum_353">粗糙度</span>和<span class="control" id="frdlum_354">光源体积</span>时。</p></li></ul><p id="frdlum_355">当然也存在一些取巧的解决办法：例如预烘焙方案，在制作团队的电脑上离线烘焙好场景中的一切信息，用空间换时间。但现代游戏大量的动态场景已经导致其不再广泛适用；或者就是直接削弱细节，不过有人真的希望在现代游戏中看到一些类似于古早画面技术的东西吗？</p></section><div class="last-modified">Last modified: 21 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="shaderbasic.html" class="navigation-links__prev">着色器 基本概念和轶事</a><a href="raytracing.html" class="navigation-links__next">光线追踪专题</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>